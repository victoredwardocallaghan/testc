# 1 "<built-in>"
# 1 "src/include/kconfig.h" 1
#ifndef __KCONFIG_H__
#define __KCONFIG_H__

#if 0 /* expanded by -frewrite-includes */
#include <config.h>
#endif /* expanded by -frewrite-includes */
# 4 "src/include/kconfig.h"
# 1 "build/config.h" 1
/*
 *
 * Automatically generated file; DO NOT EDIT.
 * coreboot configuration
 *
 */
#define CONFIG_POWER_BUTTON_IS_OPTIONAL 0
#define CONFIG_SUPERIO_SMSC_FDC37M60X 0
#define CONFIG_SMM_RESERVED_SIZE 0
#define CONFIG_MCP55_PCI_E_X_1 0
#define CONFIG_BOARD_ASUS_M2V_MX_SE 0
#define CONFIG_UART4_IRQ9 0
#define CONFIG_UART8_IRQ3 0
#define CONFIG_FRAMEBUFFER_KEEP_VESA_MODE 0
#define CONFIG_SOUTHBRIDGE_AMD_SB800_SKIP_ISA_DMA_INIT 0
#define CONFIG_BOARD_GOOGLE_FALCO 0
#define CONFIG_BOARD_NOKIA_IP530 0
#define CONFIG_BOOTSPLASH 0
#define CONFIG_UART10_ENABLE 0
#define CONFIG_NORTHBRIDGE_AMD_GX1 0
#define CONFIG_NORTHBRIDGE_INTEL_SANDYBRIDGE 0
#define CONFIG_GX1_VIDEOMODE_2 0
#define CONFIG_BOARD_MSI_MS_6119 0
#define CONFIG_MAINBOARD_POWER_ON_AFTER_POWER_FAIL 0
#define CONFIG_FSP_USES_UPD 0
#define CONFIG_GPIO_P1_INIT_DATA 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801GX 0
#define CONFIG_CORE_GLIU_500_400 0
#define CONFIG_PCIEXP_COMMON_CLOCK 1
#define CONFIG_ENABLE_BUILTIN_COM1 0
#define CONFIG_BOARD_EMULATION_QEMU_X86 0
#define CONFIG_NORTHBRIDGE_SPECIFIC_OPTIONS 0
#define CONFIG_LPT_IRQ 0
#define CONFIG_IOAPIC_INTERRUPTS_ON_FSB 1
#define CONFIG_SET_FIDVID 0
#define CONFIG_BOOTBLOCK_SOURCE "bootblock_simple.c"
#define CONFIG_UART2_IO_PORT_3E8 0
#define CONFIG_IDE1_ENABLE 0
#define CONFIG_REG_SCRIPT 1
#define CONFIG_GRUB2_MASTER 0
#define CONFIG_UART6_IRQ6 0
#define CONFIG_CPU_AMD_SOCKET_S1G1 0
#define CONFIG_DRIVER_TI_TPS65090 0
#define CONFIG_MEM_TRAIN_SEQ 0
#define CONFIG_SMM_TSEG 0
#define CONFIG_EC_KONTRON_IT8516E 0
#define CONFIG_DIMM_DDR3 0
#define CONFIG_UART9_IRQ4 0
#define CONFIG_MAX_REBOOT_CNT 3
#define CONFIG_VIDEO_MB 0
#define CONFIG_UART3_IRQ14 0
#define CONFIG_BOARD_WYSE_S50 0
#define CONFIG_BOARD_TELEVIDEO_TC7020 0
#define CONFIG_BOARD_BROADCOM_BLAST 0
#define CONFIG_BOARD_INTEL_XE7501DEVKIT 0
#define CONFIG_WDT1_SIGNAL_RESET 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_10A 0
#define CONFIG_NORTHBRIDGE_INTEL_E7525 0
#define CONFIG_UDELAY_IO 0
#define CONFIG_NORTHBRIDGE_AMD_LX 0
#define CONFIG_VENDOR_ARIMA 0
#define CONFIG_VENDOR_AVALUE 0
#define CONFIG_BOARD_GIGABYTE_GA_6BXE 0
#define CONFIG_UART6_IRQ10 0
#define CONFIG_NORTHBRIDGE_AMD_CIMX_RD890 0
#define CONFIG_CPU_DMP_VORTEX86EX 0
#define CONFIG_BOOTBLOCK_CONSOLE 0
#define CONFIG_BOARD_DIGITALLOGIC_ADL855PC 0
#define CONFIG_BOARD_SUNW_ULTRA40 0
#define CONFIG_VENDOR_BCOM 0
#define CONFIG_GPIO_P7_DIR_ADDR 0
#define CONFIG_ENABLE_APIC_EXT_ID 0
#define CONFIG_DIMM_MAP_LOGICAL 0
#define CONFIG_SUPERIO_NSC_PC87392 0
#define CONFIG_BOARD_AMD_THATCHER 0
#define CONFIG_NO_POST 0
#define CONFIG_SOUTHBRIDGE_DMP_VORTEX86EX 0
#define CONFIG_HAVE_MRC 0
#define CONFIG_UART4_IRQ7 0
#define CONFIG_UART4_IO_PORT_2F8 0
#define CONFIG_LIMIT_HT_UP_WIDTH_16 0
#define CONFIG_DEBUG_INTEL_ME 0
#define CONFIG_UART8_IRQ9 0
#define CONFIG_GPIO_P7_INIT_DATA 0
#define CONFIG_UART3_ENABLE 0
#define CONFIG_CN700_VIDEO_MB_8MB 0
#define CONFIG_UART5_IRQ10 0
#define CONFIG_VENDOR_NEWISYS 0
#define CONFIG_BOARD_VIA_EPIA_MII 0
#define CONFIG_DRAM_GATE_GPIO 0
#define CONFIG_ONBOARD_LAN 0
#define CONFIG_SUPPORT_CPU_UCODE_IN_CBFS 0
#define CONFIG_HT_CHAIN_END_UNITID_BASE 0
#define CONFIG_MRC_CACHE_LOCATION 0
#define CONFIG_PCIE0_POWERDOWN 0
#define CONFIG_RELOCATABLE_RAMSTAGE 0
#define CONFIG_ECC_MEMORY 0
#define CONFIG_COREBOOT_ROMSIZE_KB_256 0
#define CONFIG_UART2_IRQ9 0
#define CONFIG_VENDOR_TECHNOLOGIC 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL 6
#define CONFIG_SB800_FWM_AT_FFF20000 0
#define CONFIG_GENERATE_MP_TABLE 1
#define CONFIG_CPU_INTEL_MODEL_306AX 0
#define CONFIG_GPIO_P8_ENABLE 0
#define CONFIG_DRAM_SIZE_MB 0
#define CONFIG_GEODE_VSA_FILE 0
#define CONFIG_BOARD_MITAC_6513WU 0
#define CONFIG_VENDOR_NEC 0
#define CONFIG_BOARD_NVIDIA_L1_2PVV 0
#define CONFIG_CN400_VIDEO_MB_OFF 0
#define CONFIG_NORTHBRIDGE_VIA_CX700 0
#define CONFIG_ENABLE_MRC_CACHE 0
#define CONFIG_UART4_IRQ10 0
#define CONFIG_DRIVER_XPOWERS_AXP209_BOOTBLOCK 0
#define CONFIG_GPIO_P7_INIT_DIR 0
#define CONFIG_SOUTHBRIDGE_VIA_K8T890 0
#define CONFIG_SUPERIO_SMSC_LPC47B397 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_105 0
#define CONFIG_UART4_ENABLE 0
#define CONFIG_SSE 0
#define CONFIG_DEBUG_TPM 0
#define CONFIG_UART6_IRQ9 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_6 1
#define CONFIG_LIMIT_HT_SPEED_400 0
#define CONFIG_VENDOR_ASUS 0
#define CONFIG_MRC_RMT 0
#define CONFIG_VENDOR_PCENGINES 0
#define CONFIG_YABEL_VIRTMEM_LOCATION 0
#define CONFIG_TEMP_POWERDOWN 0
#define CONFIG_DRIVER_MAXIM_MAX77686 0
#define CONFIG_CK804B_PCI_E_X 0
#define CONFIG_COLLECT_TIMESTAMPS 0
#define CONFIG_UART4_IO_PORT_OTHER_INPUT 0
#define CONFIG_SUPERIO_ITE_IT8728F 0
#define CONFIG_SOC_INTEL_BAYTRAIL 0
#define CONFIG_IDE_STANDARD_COMPATIBLE 0
#define CONFIG_VENDOR_WINENT 0
#define CONFIG_PCIEXP_PLUGIN_SUPPORT 1
#define CONFIG_UART1_IO_PORT_3E8 0
#define CONFIG_UART8_IRQ 0
#define CONFIG_MMX 0
#define CONFIG_BOARD_NEC_POWERMATE_2000 0
#define CONFIG_SPI_FLASH_SST 1
#define CONFIG_BOARD_AMD_DB800 0
#define CONFIG_AGP_APERTURE_SIZE 0
#define CONFIG_MCP55_PCI_E_X_2 0
#define CONFIG_MMCONF_SUPPORT 1
#define CONFIG_CPU_AMD_GEODE_LX 0
#define CONFIG_SOUTHBRIDGE_INTEL_PXHD 0
#define CONFIG_UART8_IRQ4 0
#define CONFIG_BOARD_IEI_PM_LX_800_R11 0
#define CONFIG_SUPERIO_SMSC_KBC1100 0
#define CONFIG_RESET_ON_INVALID_RAMSTAGE_CACHE 0
#define CONFIG_BOARD_INTEL_JARRELL 0
#define CONFIG_SYS_SDRAM_BASE 0
#define CONFIG_UART3_IRQ4 0
#define CONFIG_CBFS_SIZE 0x200000
#define CONFIG_X86EMU_DEBUG_PMM 0
#define CONFIG_S3_DATA_SIZE 32768
#define CONFIG_UART10_IO 0
#define CONFIG_NORTHBRIDGE_AMD_GX2 0
#define CONFIG_BOARD_CUBIETECH_CUBIEBOARD 0
#define CONFIG_SUPERIO_WINBOND_W83627HF 0
#define CONFIG_UART2_IRQ3 0
#define CONFIG_ON_DEVICE_ROM_RUN 1
#define CONFIG_UART6_IO 0
#define CONFIG_GPIO_P3_DATA_ADDR 0
#define CONFIG_X86EMU_DEBUG_JMP 0
#define CONFIG_UART5_IO_PORT_OTHER 0
#define CONFIG_NORTHBRIDGE_INTEL_I440LX 0
#define CONFIG_DRIVER_XPOWERS_AXP209 0
#define CONFIG_SOUTHBRIDGE_AMD_HUDSON_SKIP_ISA_DMA_INIT 0
#define CONFIG_DRIVERS_UART 1
#define CONFIG_ONBOARD_MEMORY_128MB 0
#define CONFIG_DRIVERS_UART_PL011 0
#define CONFIG_LIMIT_HT_SPEED_300 0
#define CONFIG_AMD_SB_CIMX 1
#define CONFIG_CPU_INTEL_MODEL_206AX 0
#define CONFIG_ELOG_DEBUG 0
#define CONFIG_CPU_AMD_SOCKET_AM3R2 0
#define CONFIG_UART2_IRQ12 0
#define CONFIG_BOARD_VIA_EPIA_M850 0
#define CONFIG_BOARD_HP_DL145_G3 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82371EB 0
#define CONFIG_UART6_IRQ3 0
#define CONFIG_UART3_IRQ_DISABLE 0
#define CONFIG_SUPERIO_NSC_PC97317 0
#define CONFIG_SUPERIO_WINBOND_W83977TF 0
#define CONFIG_COREBOOT_ROMSIZE_KB_4096 0
#define CONFIG_BOARD_EMULATION_QEMU_X86_Q35 0
#define CONFIG_NR_DRAM_BANKS 0
#define CONFIG_MULTIPLE_VGA_ADAPTERS 0
#define CONFIG_UART7_IRQ4 0
#define CONFIG_GPIO_P5_INIT_DATA 0
#define CONFIG_UART3_IRQ 0
#define CONFIG_BOARD_TYAN_S1846 0
#define CONFIG_UART10_IRQ12 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_10B 0
#define CONFIG_BOARD_SUPERMICRO_H8QME_FAM10 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_110 0
#define CONFIG_SOUTHBRIDGE_AMD_CS5535 0
#define CONFIG_BOARD_PACKARDBELL_MS2290 0
#define CONFIG_DCACHE_RAM_SIZE 0x10000
#define CONFIG_UART1_IRQ7 0
#define CONFIG_EXT_CONF_SUPPORT 0
#define CONFIG_SET_FIDVID_ONE_BY_ONE 0
#define CONFIG_BOARD_THOMSON_IP1000 0
#define CONFIG_SCANBUILD_ENABLE 0
#define CONFIG_GPIO_P9_DATA_ADDR 0
#define CONFIG_BOARD_ASUS_MEW_VM 0
#define CONFIG_HT_CHAIN_UNITID_BASE 0
#define CONFIG_UART9_IO_PORT_OTHER 0
#define CONFIG_ARCH_ROMSTAGE_ARMV7 0
#define CONFIG_PCIB_ENABLE 0
#define CONFIG_NORTHBRIDGE_AMD_AMDK8 0
#define CONFIG_BOARD_TYAN_S2895 0
#define CONFIG_TTYS0_BAUD 115200
#define CONFIG_SB800_NO_FAN_CONTROL 1
#define CONFIG_FRAMEBUFFER_VESA_MODE_11B 0
#define CONFIG_ENABLE_FSP_FAST_BOOT 0
#define CONFIG_VENDOR_THOMSON 0
#define CONFIG_BOARD_ASUS_M4A785TM 0
#define CONFIG_INTEL_DDI 0
#define CONFIG_BOARD_DMP_EX 0
#define CONFIG_SEABIOS_MASTER 0
#define CONFIG_VENDOR_BIOSTAR 0
#define CONFIG_CPU_INTEL_SOCKET_MPGA603 0
#define CONFIG_BOARD_GOOGLE_SLIPPY 0
#define CONFIG_VENDOR_IBASE 0
#define CONFIG_BOARD_TYAN_S2912_FAM10 0
#define CONFIG_BOARD_AMD_RUMBA 0
#define CONFIG_NORTHBRIDGE_INTEL_FSP_IVYBRIDGE 0
#define CONFIG_HUDSON_SATA_IDE2AHCI 0
#define CONFIG_INCLUDE_ME 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA_FAMILY14 1
#define CONFIG_BOARD_LENOVO_T520 0
#define CONFIG_UART3_IRQ9 0
#define CONFIG_UART6_IRQ_DISABLE 0
#define CONFIG_HUDSON_SATA_LEGACY_IDE 0
#define CONFIG_BOARD_VIA_EPIA 0
#define CONFIG_NORTHBRIDGE_VIA_CN700 0
#define CONFIG_SUPERIO_WANTS_14MHZ_CLOCK 0
#define CONFIG_CPU_INTEL_EP80579 0
#define CONFIG_PLL_444_333_33 0
#define CONFIG_UART8_IO_PORT_OTHER_INPUT 0
#define CONFIG_HAVE_MRC_CACHE 0
#define CONFIG_HAVE_GBE_BIN 0
#define CONFIG_CPU_VIA_C7 0
#define CONFIG_UART2_IRQ_DISABLE 0
#define CONFIG_VENDOR_DMP 0
#define CONFIG_UPDATE_CPU_MICROCODE 0
#define CONFIG_BOARD_LENOVO_X60 0
#define CONFIG_BOARD_ROMSIZE_KB_1024 0
#define CONFIG_COREBOOT_ROMSIZE_KB_64 0
#define CONFIG_PLL_400_200_33 0
#define CONFIG_BOARD_TYAN_S4880 0
#define CONFIG_I830_VIDEO_MB_8MB 0
#define CONFIG_BOARD_AMD_PERSIMMON 0
#define CONFIG_BOARD_INTEL_D810E2CB 0
#define CONFIG_K8M890_VIDEO_MB_64MB 0
#define CONFIG_BOARD_ASUS_F2A85_M 0
#define CONFIG_REALMODE_DEBUG 0
#define CONFIG_ONBOARD_1394 0
#define CONFIG_ARCH_ROMSTAGE_X86_32 1
#define CONFIG_COMPILER_LLVM_CLANG 1
#define CONFIG_FRAMEBUFFER_VESA_MODE_106 0
#define CONFIG_SUPERIO_NSC_PC87366 0
#define CONFIG_DRIVERS_I2C_I2CMUX 0
#define CONFIG_BOARD_MSI_MS9185 0
#define CONFIG_UART1_IRQ 0
#define CONFIG_SUPERIO_ITE_COMMON_ROMSTAGE 0
#define CONFIG_CPU_MICROCODE_CBFS_GENERATE 0
#define CONFIG_UART8_IO_PORT_3F8 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_3 0
#define CONFIG_GPIO_P8_DIR_ADDR 0
#define CONFIG_UART5_IO 0
#define CONFIG_BOARD_DIGITALLOGIC_MSM586SEG 0
#define CONFIG_UART1_IRQ9 0
#define CONFIG_SPI_FLASH_SMM 0
#define CONFIG_NORTHBRIDGE_INTEL_E7505 0
#define CONFIG_UART5_IO_PORT_2F8 0
#define CONFIG_ENABLE_IDE_COMBINED_MODE 0
#define CONFIG_UART10_IRQ_DISABLE 0
#define CONFIG_UART8_IO_PORT_3E8 0
#define CONFIG_BOARD_SUPERMICRO_H8SCM_FAM10 0
#define CONFIG_CPU_AMD_SOCKET_F_1207 0
#define CONFIG_ELOG_SHRINK_SIZE 0
#define CONFIG_VDD_ARM_MV 0
#define CONFIG_ID_SECTION_BASE 0
#define CONFIG_SUBSYSTEM_VENDOR_ID 0x0000
#define CONFIG_CPU_INTEL_SOCKET_PGA370 0
#define CONFIG_CBFS_CACHE_SIZE 0
#define CONFIG_UART5_ENABLE 0
#define CONFIG_LPT_IO_PORT_378 0
#define CONFIG_SUPERIO_ITE_IT8718F 0
#define CONFIG_CPU_INTEL_MODEL_69X 0
#define CONFIG_NO_TPM_RESUME 0
#define CONFIG_CORE_GLIU_500_266 0
#define CONFIG_DYNAMIC_CBMEM 0
#define CONFIG_LOGICAL_CPUS 1
#define CONFIG_DCACHE_RAM_ROMSTAGE_STACK_SIZE 0
#define CONFIG_BOARD_SUPERMICRO_X6DHR_IG2 0
#define CONFIG_WDT1_ENABLE 0
#define CONFIG_TPM 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_USER 0
#define CONFIG_UART3_IRQ7 0
#define CONFIG_LPT_IRQ3 0
#define CONFIG_UART5_IRQ5 0
#define CONFIG_VENDOR_AXUS 0
#define CONFIG_NORTHBRIDGE_INTEL_I82830 0
#define CONFIG_CONSOLE_NE2K 0
#define CONFIG_GEODE_VSA 0
#define CONFIG_UART6_IO_PORT_2F8 0
#define CONFIG_CBFS_CACHE_ADDRESS 0
#define CONFIG_USBDEBUG_IN_ROMSTAGE 0
#define CONFIG_BOARD_EMULATION_QEMU_ARMV7 0
#define CONFIG_GPIO_P2_INIT_DIR 0
#define CONFIG_CPU_QEMU_X86 0
#define CONFIG_UART7_IO_PORT_OTHER 0
#define CONFIG_INTEL_MBI 0
#define CONFIG_VENDOR_ADLINK 0
#define CONFIG_SYS_I2C_SPEED 0
#define CONFIG_FRAMEBUFFER_VESA_MODE 0
#define CONFIG_ALWAYS_LOAD_OPROM 0
#define CONFIG_UART7_IRQ14 0
#define CONFIG_ACPI_SCI_IRQ 0
#define CONFIG_DEBUG_COVERAGE 0
#define CONFIG_UART2_IRQ15 0
#define CONFIG_LIMIT_HT_SPEED_500 0
#define CONFIG_SOUTHBRIDGE_AMD_CIMX_SB700 0
#define CONFIG_CN700_VIDEO_MB_32MB 0
#define CONFIG_BOARD_GOOGLE_BOLT 0
#define CONFIG_SOUTHBRIDGE_AMD_SB600 0
#define CONFIG_XIP_ROM_BASE 0
#define CONFIG_BOARD_VIA_EPIA_N 0
#define CONFIG_K8M890_VIDEO_MB_32MB 0
#define CONFIG_UART1_IO_PORT_2E8 0
#define CONFIG_CMOS_POST_OFFSET 0
#define CONFIG_SOUTHBRIDGE_AMD_AGESA_YANGTZE 0
#define CONFIG_CPU_SOCKET_TYPE 0x10
#define CONFIG_GPIO_P7_ENABLE 0
#define CONFIG_DEBUG_RAM_SETUP 0
#define CONFIG_UART7_IRQ7 0
#define CONFIG_POWER_BUTTON_FORCE_DISABLE 0
#define CONFIG_VDD_G3D_MV 0
#define CONFIG_VENDOR_AMD 0
#define CONFIG_BOARD_INTEL_D945GCLF 0
#define CONFIG_BOARD_AMD_PARMER 0
#define CONFIG_CPU_INTEL_MODEL_67X 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_117 0
#define CONFIG_CPU_INTEL_FIRMWARE_INTERFACE_TABLE 0
#define CONFIG_MAX_PIRQ_LINKS 4
#define CONFIG_BOARD_EMULATION_QEMU_X86_I440FX 0
#define CONFIG_EC_SMSC_MEC1308 0
#define CONFIG_SOUTHBRIDGE_AMD_CIMX_SB900 0
#define CONFIG_GPIO_P3_DIR_ADDR 0
#define CONFIG_ANY_TOOLCHAIN 0
#define CONFIG_VENDOR_A_TREND 0
#define CONFIG_SOUTHBRIDGE_INTEL_LYNXPOINT 0
#define CONFIG_NORTHBRIDGE_INTEL_SUBTYPE_I945GM 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_11A 0
#define CONFIG_K8_HT_FREQ_1G_SUPPORT 0
#define CONFIG_ONBOARD_USB30 0
#define CONFIG_UART3_IO_PORT_OTHER 0
#define CONFIG_BOARD_GIGABYTE_MA785GM 0
#define CONFIG_BOARD_ASUS_P2B_F 0
#define CONFIG_DIMM_SUPPORT 0x0104
#define CONFIG_EHCI_BAR 0xfef00000
#define CONFIG_UART3_IO_PORT_3F8 0
#define CONFIG_BOARD_SPECIFIC_OPTIONS 1
#define CONFIG_ARCH_X86 1
#define CONFIG_BOARD_TYAN_S2880 0
#define CONFIG_EC_QUANTA_IT8518 0
#define CONFIG_USE_OPTION_TABLE 0
#define CONFIG_CPU_AMD_SOCKET_AM2 0
#define CONFIG_COREBOOT_ROMSIZE_KB_2048 1
#define CONFIG_X86EMU_DEBUG_INTERRUPTS 0
#define CONFIG_BOARD_BIFFEROS_BIFFERBOARD 0
#define CONFIG_CACHE_RELOCATED_RAMSTAGE_OUTSIDE_CBMEM 0
#define CONFIG_S3_VGA_ROM_RUN 0
#define CONFIG_VENDOR_GIGABYTE 0
#define CONFIG_SUBSYSTEM_DEVICE_ID 0x0000
#define CONFIG_BOARD_MSI_MS9652_FAM10 0
#define CONFIG_AHCI_BIOS 0
#define CONFIG_BOARD_A_TREND_ATC_6220 0
#define CONFIG_GX2_VIDEO_MB_256MB 0
#define CONFIG_CPU_INTEL_SOCKET_MPGA478 0
#define CONFIG_CPU_AMD_GEODE_GX2 0
#define CONFIG_SB800_SATA_IDE 0
#define CONFIG_MMCONF_SUPPORT_DEFAULT 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_103 0
#define CONFIG_DRIVERS_UART_OXPCIE 0
#define CONFIG_SPI_FLASH_AMIC 1
#define CONFIG_UART10_IO_PORT_2F8 0
#define CONFIG_UART3_IRQ10 0
#define CONFIG_GX2_VIDEO_MB_8MB 0
#define CONFIG_BOARD_LENOVO_T60 0
#define CONFIG_HUDSON_AHCI_ROM 0
#define CONFIG_POWER_BUTTON_FORCE_ENABLE 0
#define CONFIG_HT3_SUPPORT 0
#define CONFIG_PAYLOAD_TIANOCORE 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_10E 0
#define CONFIG_IOAPIC 1
#define CONFIG_UART6_IRQ14 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_119 0
#define CONFIG_COREBOOT_ROMSIZE_KB_16384 0
#define CONFIG_SUPERIO_FINTEK_F71805F 0
#define CONFIG_LPT_IO_PORT_278 0
#define CONFIG_BOARD_ASUS_F2A85_M_DDR3_VOLT_VAL 0
#define CONFIG_BOARD_LIPPERT_TOUCAN_AF 0
#define CONFIG_DRIVERS_TRIDENT_BLADE3D 0
#define CONFIG_VENDOR_ARTECGROUP 0
#define CONFIG_GX2_VIDEO_MB_CMOS 0
#define CONFIG_BOARD_ROMSIZE_KB_8192 0
#define CONFIG_ROMCC 0
#define CONFIG_MCP55_USE_NIC 0
#define CONFIG_BOARD_MSI_MS7260 0
#define CONFIG_NORTHBRIDGE_INTEL_I5000_RAM_CHECK 0
#define CONFIG_BOOTMODE_STRAPS 0
#define CONFIG_CONSOLE_VGA_MULTI 0
#define CONFIG_POST_IO_PORT 0
#define CONFIG_UART5_IRQ14 0
#define CONFIG_SUPERIO_FINTEK_F71869AD 1
#define CONFIG_CX700_VIDEO_MB_128MB 0
#define CONFIG_ARCH_BOOTBLOCK_ARMV7 0
#define CONFIG_UART10_IRQ7 0
#define CONFIG_GX2_VIDEO_MB_32MB 0
#define CONFIG_MAINBOARD_VENDOR "Jetway"
#define CONFIG_LPT_IRQ4 0
#define CONFIG_UART8_IRQ15 0
#define CONFIG_EC_SOFTWARE_SYNC 0
#define CONFIG_NUM_THREADS 0
#define CONFIG_UART9_IRQ12 0
#define CONFIG_UART2_IRQ5 0
#define CONFIG_ACPI_SSDTX_NUM 0
#define CONFIG_CPU_SPECIFIC_OPTIONS 0
#define CONFIG_SEABIOS_PS2_TIMEOUT 0
#define CONFIG_VENDOR_AOPEN 0
#define CONFIG_EC_GOOGLE_CHROMEEC_SPI 0
#define CONFIG_COMPRESS_RAMSTAGE 1
#define CONFIG_CONSOLE_SERIAL_38400 0
#define CONFIG_SOUTHBRIDGE_SIS_SIS966 0
#define CONFIG_HAVE_DEBUG_CAR 0
#define CONFIG_COMPILER_GCC 0
#define CONFIG_GPIO_P0_INIT_DIR 0
#define CONFIG_CX700_VIDEO_MB_8MB 0
#define CONFIG_SUPERIO_SMSC_SIO1007 0
#define CONFIG_CPU_INTEL_MODEL_F0X 0
#define CONFIG_CPU_INTEL_SOCKET_MFCPGA478 0
#define CONFIG_COREBOOT_ROMSIZE_KB_8192 0
#define CONFIG_ONBOARD_MEMORY_64MB 0
#define CONFIG_PLL_200_200_33 0
#define CONFIG_UART7_IRQ11 0
#define CONFIG_UART4_IRQ14 0
#define CONFIG_SUPERIO_NSC_PC8374 0
#define CONFIG_SB800_FWM_AT_FFE20000 0
#define CONFIG_SUPERIO_ITE_IT8712F 0
#define CONFIG_UART5_IRQ7 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_109 0
#define CONFIG_X86EMU_DEBUG_VBE 0
#define CONFIG_LPT_MODE_EPP_19_AND_SPP 0
#define CONFIG_BOARD_JETWAY_J7F2 0
#define CONFIG_BOARD_KONTRON_986LCD_M 0
#define CONFIG_EC_GOOGLE_CHROMEEC_SPI_BUS 0
#define CONFIG_BOARD_GIGABYTE_M57SLI 0
#define CONFIG_BOARD_RODA_RK886EX 0
#define CONFIG_ENABLE_VMX 0
#define CONFIG_BOARD_AMD_DBM690T 0
#define CONFIG_GPIO_P3_ENABLE 0
#define CONFIG_TSC_SYNC_LFENCE 1
#define CONFIG_POST_DEVICE_LPC 0
#define CONFIG_SPLASH_GRAPHIC 0
#define CONFIG_CACHE_ROM_SIZE_OVERRIDE 0x0
#define CONFIG_MAINBOARD_DIR "jetway/nf81-t56n-lf"
#define CONFIG_BOARD_A_TREND_ATC_6240 0
#define CONFIG_UART10_IRQ14 0
#define CONFIG_LIMIT_HT_SPEED_1400 0
#define CONFIG_CPU_INTEL_SOCKET_RPGA988B 0
#define CONFIG_VENDOR_GIZMOSPHERE 0
#define CONFIG_MRC_CACHE_BASE 0
#define CONFIG_BOARD_IEI_PM_LX2_800_R10 0
#define CONFIG_LIMIT_HT_SPEED_1600 0
#define CONFIG_BOARD_INTEL_BASKING_RIDGE 0
#define CONFIG_VENDOR_ADVANTECH 0
#define CONFIG_GX2_PROCESSOR_MHZ_366 0
#define CONFIG_VENDOR_LIPPERT 0
#define CONFIG_BOOTBLOCK_SIMPLE 1
#define CONFIG_OVERRIDE_CACHE_CACHE_LOC 0
#define CONFIG_SUPERIO_FINTEK_F71872 0
#define CONFIG_VENDOR_NVIDIA 0
#define CONFIG_K8_FORCE_2T_DRAM_TIMING 0
#define CONFIG_DEBUG_SMI 0
#define CONFIG_LIMIT_HT_SPEED_2000 0
#define CONFIG_BOARD_GIZMOSPHERE_GIZMO 0
#define CONFIG_BOARD_ASUS_A8V_E_SE 0
#define CONFIG_GX1_VIDEO 0
#define CONFIG_CONSOLE_CBMEM 0
#define CONFIG_SOCKET_SPECIFIC_OPTIONS 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82870 0
#define CONFIG_CBB 0x0
#define CONFIG_BOARD_GOOGLE_PIT 0
#define CONFIG_CONSOLE_USB 0
#define CONFIG_BOARD_GOOGLE_STOUT 0
#define CONFIG_CPU_ADDR_BITS 36
#define CONFIG_HEAP_SIZE 0xc0000
#define CONFIG_IDE2_ENABLE 0
#define CONFIG_COREBOOT_ROMSIZE_KB 2048
#define CONFIG_DRIVERS_GENERIC_IOAPIC 0
#define CONFIG_VENDOR_HP 0
#define CONFIG_GX1_VIDEOMODE_1 0
#define CONFIG_BOARD_ASUS_MEW_AM 0
#define CONFIG_LPT_MODE_SPP 0
#define CONFIG_BOARD_TI_BEAGLEBONE 0
#define CONFIG_BOARD_WINENT_PL6064 0
#define CONFIG_CPU_AMD_SC520 0
#define CONFIG_CARDBUS_PLUGIN_SUPPORT 1
#define CONFIG_MAINBOARD_HAS_CHROMEOS 0
#define CONFIG_GX2_VIDEO_MB_16MB 0
#define CONFIG_BOARD_IWILL_DK8X 0
#define CONFIG_CPU_AMD_SOCKET_AM2R2 0
#define CONFIG_GPIO_P8_INIT_DIR 0
#define CONFIG_INTEL_EDID 0
#define CONFIG_CONSOLE_SERIAL_115200 1
#define CONFIG_UART10_IO_PORT_3F8 0
#define CONFIG_SOUTHBRIDGE_AMD_SB700 0
#define CONFIG_BOARD_ASROCK_E350M1 0
#define CONFIG_SB800_SATA_RAID 0
#define CONFIG_BOARD_JETWAY_J7F4K1G2E 0
#define CONFIG_PLL_300_300_33 0
#define CONFIG_SOUTHBRIDGE_INTEL_ESB6300 0
#define CONFIG_UART1_IO_PORT_2F8 0
#define CONFIG_BOARD_GIGABYTE_MA78GM 0
#define CONFIG_UART6_IRQ7 0
#define CONFIG_IDE_COMPATIBLE_SELECTION 0
#define CONFIG_CPU_AMD_GEODE_GX1 0
#define CONFIG_STACK_SIZE 0x1000
#define CONFIG_MRC_SETTINGS_CACHE_BASE 0
#define CONFIG_DIMM_DDR2 0
#define CONFIG_BOARD_TYAN_S2735 0
#define CONFIG_SUPERIO_NSC_PC87360 0
#define CONFIG_UART9_IRQ7 0
#define CONFIG_UART9_IO_PORT_2F8 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801EX 0
#define CONFIG_UART7_IRQ 0
#define CONFIG_UART3_IRQ15 0
#define CONFIG_SUPERIO_NUVOTON_WPCM450 0
#define CONFIG_BOARD_GIGABYTE_GA_2761GXDK 0
#define CONFIG_COREBOOT_ROMSIZE_KB_12288 0
#define CONFIG_CPU_AMD_SOCKET_ASB2 0
#define CONFIG_CN700_VIDEO_MB_OFF 0
#define CONFIG_SOUTHBRIDGE_AMD_AMD8111 0
#define CONFIG_UART1_IO 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_10F 0
#define CONFIG_BOARD_RCA_RM4100 0
#define CONFIG_I810_VIDEO_MB_OFF 0
#define CONFIG_HUDSON_SATA_RAID 0
#define CONFIG_UART1_IRQ3 0
#define CONFIG_USBDEBUG_HCD_INDEX 0
#define CONFIG_IPMI_KCS 0
#define CONFIG_CPU_MICROCODE_CBFS_LEN 0
#define CONFIG_BOARD_SAMSUNG_LUMPY 0
#define CONFIG_UART5_IO_PORT_3E8 0
#define CONFIG_UART7_IO_PORT_2F8 0
#define CONFIG_NO_UART_ON_SUPERIO 0
#define CONFIG_ARCH_RAMSTAGE_X86_32 1
#define CONFIG_UART7_IO_PORT_OTHER_INPUT 0
#define CONFIG_BOARD_COMPAQ_DESKPRO_EN_SFF_P600 0
#define CONFIG_USBDEBUG_OPTIONAL_HUB_PORT 0
#define CONFIG_GX2_PROCESSOR_MHZ 0
#define CONFIG_FLASHMAP_OFFSET 0
#define CONFIG_VENDOR_IWILL 0
#define CONFIG_CN400_VIDEO_MB_128MB 0
#define CONFIG_BOARD_LANNER_EM8510 0
#define CONFIG_UART4_IRQ4 0
#define CONFIG_XHC_BIOS 0
#define CONFIG_NORTHBRIDGE_INTEL_I82810 0
#define CONFIG_BOARD_ASUS_P2B_DS 0
#define CONFIG_UART5_IRQ11 0
#define CONFIG_SOUTHBRIDGE_AMD_AMD8151 0
#define CONFIG_AGP_PLUGIN_SUPPORT 1
#define CONFIG_BACKUP_DEFAULT_SMM_REGION 0
#define CONFIG_SANDYBRIDGE_FSP_SPECIFIC_OPTIONS 0
#define CONFIG_POST_IO 0
#define CONFIG_BOARD_ASUS_M2V 0
#define CONFIG_DCACHE_RAM_MRC_VAR_SIZE 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA_FAMILY10 0
#define CONFIG_BOARD_ROMSIZE_KB_256 0
#define CONFIG_UART1_ENABLE 0
#define CONFIG_LPT_IRQ9 0
#define CONFIG_BOARD_IWILL_DK8_HTX 0
#define CONFIG_SOUTHBRIDGE_VIA_VT8235 0
#define CONFIG_CPU_AMD_SOCKET_G34 0
#define CONFIG_UART4_IO 0
#define CONFIG_SUPERIO_SMSC_LPC47N227 0
#define CONFIG_CPU_VIA_C3 0
#define CONFIG_CONSOLE_NE2K_IO_PORT 0
#define CONFIG_UART7_IO 0
#define CONFIG_CACHE_AS_RAM 1
#define CONFIG_HPET_ADDRESS_OVERRIDE 0
#define CONFIG_VENDOR_LINUTOP 0
#define CONFIG_LIMIT_HT_SPEED_AUTO 0
#define CONFIG_BOARD_SUPERMICRO_X6DHE_G2 0
#define CONFIG_DRIVERS_I2C_W83793 0
#define CONFIG_VENDOR_ASROCK 0
#define CONFIG_TIMER_QUEUE 0
#define CONFIG_UART7_IRQ12 0
#define CONFIG_UART6_IO_PORT_3E8 0
#define CONFIG_STACK_TOP 0
#define CONFIG_BOARD_IEI_KINO_FAM10 0
#define CONFIG_VGA_ROM_RUN 1
#define CONFIG_COMPRESSED_PAYLOAD_LZMA 0
#define CONFIG_SPI_FLASH_NO_FAST_READ 0
#define CONFIG_BOARD_LIPPERT_FRONTRUNNER 0
#define CONFIG_BOARD_MSI_MS_6178 0
#define CONFIG_UART1_IO_PORT_3F8 0
#define CONFIG_EC_GOOGLE_CHROMEEC_I2C_BUS 0
#define CONFIG_X86EMU_DEBUG_CHECK_VMEM_ACCESS 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_7 0
#define CONFIG_CONSOLE_SERIAL_19200 0
#define CONFIG_BOARD_IEI_ROCKY_512 0
#define CONFIG_ARCH_ARMV7 0
#define CONFIG_VENDOR_LANNER 0
#define CONFIG_MMCONF_BUS_NUMBER 16
#define CONFIG_SPKMODEM 0
#define CONFIG_LPT_IRQ_DISABLE 0
#define CONFIG_HYPERTRANSPORT_PLUGIN_SUPPORT 0
#define CONFIG_NORTHBRIDGE_INTEL_E7501 0
#define CONFIG_SIO_PORT 0x4e
#define CONFIG_VENDOR_EAGLELION 0
#define CONFIG_REDIRECT_CIMX_TRACE_TO_SERIAL 0
#define CONFIG_SOUTHBRIDGE_AMD_SB700_SKIP_ISA_DMA_INIT 0
#define CONFIG_UART8_IO 0
#define CONFIG_UART3_IO_PORT_OTHER_INPUT 0
#define CONFIG_RAMTOP 0x1000000
#define CONFIG_ARCH_BOOTBLOCK_X86_32 1
#define CONFIG_HUDSON_LEGACY_FREE 0
#define CONFIG_VENDOR_TECHNEXION 0
#define CONFIG_HW_SCRUBBER 0
#define CONFIG_CHANNEL_XOR_RANDOMIZATION 0
#define CONFIG_NORTHBRIDGE_INTEL_SUBTYPE_I945GC 0
#define CONFIG_BOARD_SUPERMICRO_H8DMR_FAM10 0
#define CONFIG_BOARD_GOOGLE_PARROT 0
#define CONFIG_SOUTHBRIDGE_AMD_AMD8132 0
#define CONFIG_MCP55_PCI_E_X_3 0
#define CONFIG_STACK_BOTTOM 0
#define CONFIG_HUDSON_XHCI_ENABLE 0
#define CONFIG_SUPERIO_NSC_PC87382 0
#define CONFIG_UART8_IRQ5 0
#define CONFIG_CHROMEOS_RAMOOPS_DYNAMIC 0
#define CONFIG_SOUTHBRIDGE_AMD_SUBTYPE_SP5100 0
#define CONFIG_SUPERIO_FINTEK_F71863FG 0
#define CONFIG_CPU_INTEL_SOCKET_BGA956 0
#define CONFIG_UART8_IRQ12 0
#define CONFIG_ELOG_FLASH_BASE 0
#define CONFIG_SATA_POWERDOWN 0
#define CONFIG_LPT_IRQ15 0
#define CONFIG_VAR_MTRR_HOLE 0
#define CONFIG_BOARD_LINUTOP_LINUTOP1 0
#define CONFIG_VENDOR_INTEL 0
#define CONFIG_BOARD_GOOGLE_SNOW 0
#define CONFIG_DRIVERS_DEC_21143 0
#define CONFIG_PLL_400_400_33 0
#define CONFIG_UART2_IRQ11 0
#define CONFIG_DRIVERS_PS2_KEYBOARD 1
#define CONFIG_CPU_AMD_AGESA_FAMILY15_TN 0
#define CONFIG_UART6_IRQ4 0
#define CONFIG_NORTHBRIDGE_VIA_CN400 0
#define CONFIG_NORTHBRIDGE_INTEL_HASWELL 0
#define CONFIG_SET_FIDVID_DEBUG 0
#define CONFIG_PCI_BUS_SEGN_BITS 0
#define CONFIG_CDB 0x18
#define CONFIG_UART1_IRQ14 0
#define CONFIG_CPU_VIA_NANO 0
#define CONFIG_BOARD_AMD_MAHOGANY 0
#define CONFIG_I810_VIDEO_MB_1MB 0
#define CONFIG_UART7_IRQ3 0
#define CONFIG_CK804_USE_NIC 0
#define CONFIG_SB800_MANUAL_FAN_CONTROL 0
#define CONFIG_COREBOOT_ROMSIZE_KB_1024 0
#define CONFIG_DRIVERS_I2C_ADM1027 0
#define CONFIG_I810_VIDEO_MB_512KB 0
#define CONFIG_GX2_VIDEO_MB_128MB 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_10C 0
#define CONFIG_SB800_FWM_AT_FFFA0000 0
#define CONFIG_DRIVER_PARADE_PS8625 0
#define CONFIG_BOARD_GIGABYTE_GA_6BXC 0
#define CONFIG_UART6_IRQ12 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_113 0
#define CONFIG_SOUTHBRIDGE_AMD_CS5536 0
#define CONFIG_BOARD_GIGABYTE_MA785GMT 0
#define CONFIG_UART1_IRQ6 0
#define CONFIG_MAXIMUM_SUPPORTED_FREQUENCY 0
#define CONFIG_I855_VIDEO_MB_4MB 0
#define CONFIG_AHCI_ROM_ID "1002,4391"
#define CONFIG_VENDOR_IEI 0
#define CONFIG_SET_FIDVID_CORE_RANGE 0
#define CONFIG_HW_MEM_HOLE_SIZE_AUTO_INC 0
#define CONFIG_USBDEBUG_DONGLE_BEAGLEBONE 0
#define CONFIG_WARNINGS_ARE_ERRORS 1
#define CONFIG_EC_GOOGLE_CHROMEEC_LPC 0
#define CONFIG_BOOTBLOCK_SOUTHBRIDGE_INIT "southbridge/amd/cimx/sb800/bootblock.c"
#define CONFIG_SMM_MODULES 0
#define CONFIG_VENDOR_ABIT 0
#define CONFIG_CPU_INTEL_SOCKET_MPGA604 0
#define CONFIG_CPU_AMD_AGESA_FAMILY12 0
#define CONFIG_CONSOLE_SERIAL 1
#define CONFIG_SVI_HIGH_FREQ 0
#define CONFIG_UDELAY_LAPIC 1
#define CONFIG_BOARD_KONTRON_KT690 0
#define CONFIG_EARLY_PCI_BRIDGE_DEVICE 0
#define CONFIG_HIGH_SCRATCH_MEMORY_SIZE 0x71000
#define CONFIG_UART10_IRQ9 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA_FAMILY15 0
#define CONFIG_SOUTHBRIDGE_INTEL_COMMON 0
#define CONFIG_DEBUG_USBDEBUG 0
#define CONFIG_BOARD_INTEL_MTARVON 0
#define CONFIG_UART9_IRQ14 0
#define CONFIG_BOARD_LIPPERT_FRONTRUNNER_AF 0
#define CONFIG_CBFS_PREFIX "fallback"
#define CONFIG_COVERAGE 0
#define CONFIG_SPI_FLASH_GIGADEVICE 1
#define CONFIG_ROMSTAGE_SIZE 0
#define CONFIG_SOUTHBRIDGE_AMD_RS780 0
#define CONFIG_GPIO_P3_INIT_DIR 0
#define CONFIG_CPU_MICROCODE_CBFS_EXTERNAL 0
#define CONFIG_GPIO_P0_DIR_ADDR 0
#define CONFIG_MAINBOARD_SMBIOS_MANUFACTURER "Altera Praxis Pty Ltd"
#define CONFIG_OVERRIDE_CLOCK_DISABLE 0
#define CONFIG_UART8_IO_PORT_2E8 0
#define CONFIG_MAINBOARD_HAS_NATIVE_VGA_INIT 0
#define CONFIG_GPIO_P4_DIR_ADDR 0
#define CONFIG_SOUTHBRIDGE_SPECIFIC_OPTIONS 0
#define CONFIG_UART8_ENABLE 0
#define CONFIG_GPIO_P0_DATA_ADDR 0
#define CONFIG_S3_DATA_POS 0xFFFF0000
#define CONFIG_SPI_FLASH_STMICRO 1
#define CONFIG_SOUTHBRIDGE_AMD_SB800 0
#define CONFIG_BOARD_LIPPERT_LITERUNNER_LX 0
#define CONFIG_COOP_MULTITASKING 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_107 0
#define CONFIG_I855_VIDEO_MB_16MB 0
#define CONFIG_BOARD_PCENGINES_ALIX1C 0
#define CONFIG_PAYLOAD_SEABIOS 0
#define CONFIG_BOARD_INTEL_TRUXTON 0
#define CONFIG_BOARD_AMD_MAHOGANY_FAM10 0
#define CONFIG_UART7_IRQ9 0
#define CONFIG_LIMIT_HT_DOWN_WIDTH_16 0
#define CONFIG_EC_LENOVO_H8 0
#define CONFIG_GPIO_P5_ENABLE 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_0 0
#define CONFIG_PLL_400_300_100 0
#define CONFIG_ELOG_CBMEM 0
#define CONFIG_RAMBASE 0x200000
#define CONFIG_SB_SUPERIO_HWM 0
#define CONFIG_DRIVERS_I2C_LM63 0
#define CONFIG_SOUTHBRIDGE_INTEL_C216 0
#define CONFIG_LIMIT_HT_SPEED_2600 0
#define CONFIG_I855_VIDEO_MB_32MB 0
#define CONFIG_GENERATE_SMBIOS_TABLES 1
#define CONFIG_I2C_MULTI_BUS 0
#define CONFIG_BOARD_SIEMENS_SITEMP_G1P1 0
#define CONFIG_VDD_LDO5_MV 0
#define CONFIG_XIP_ROM_SIZE 0x100000
#define CONFIG_BOARD_IWAVE_RAINBOW_G6 0
#define CONFIG_BOARD_ROMSIZE_KB_64 0
#define CONFIG_SOUTHBRIDGE_BROADCOM_BCM21000 0
#define CONFIG_SIPI_VECTOR_IN_ROM 0
#define CONFIG_SOUTHBRIDGE_BROADCOM_BCM5785 0
#define CONFIG_DEBUG_SPI_FLASH 0
#define CONFIG_SB800_SATA_MODE 0x2
#define CONFIG_UART4_IO_PORT_OTHER 0
#define CONFIG_MCP55_USE_AZA 0
#define CONFIG_VENDOR_TI 0
#define CONFIG_X86_AMD_FIXED_MTRRS 1
#define CONFIG_UART3_IO 0
#define CONFIG_SOUTHBRIDGE_AMD_AMD8131 0
#define CONFIG_PCI 1
#define CONFIG_VENDOR_VIA 0
#define CONFIG_BOARD_TECHNEXION_TIM8690 0
#define CONFIG_UART8_IRQ6 0
#define CONFIG_VBOOT_REFCODE_INDEX 0
#define CONFIG_CPU_AMD_AGESA_FAMILY16_KB 0
#define CONFIG_UART10_IRQ3 0
#define CONFIG_GFXUMA 1
#define CONFIG_VDD_INT_UV 0
#define CONFIG_BOARD_ECS_P6IWP_FE 0
#define CONFIG_ELOG_AREA_SIZE 0
#define CONFIG_UART3_IRQ6 0
#define CONFIG_UART8_IRQ11 0
#define CONFIG_BOARD_VIA_EPIA_M700 0
#define CONFIG_UART7_IO_PORT_3F8 0
#define CONFIG_HAVE_CMC 0
#define CONFIG_SUPERIO_ITE_IT8716F 0
#define CONFIG_VENDOR_SIEMENS 0
#define CONFIG_BOARD_SUPERMICRO_H8DMR 0
#define CONFIG_UART6_IRQ 0
#define CONFIG_VENDOR_JETWAY 1
#define CONFIG_LIMIT_HT_SPEED_200 0
#define CONFIG_PLLMSRhi 0
#define CONFIG_BOOTBLOCK_ROM_OFFSET 0
#define CONFIG_CN700_VIDEO_MB_16MB 0
#define CONFIG_GPIO_P2_DIR_ADDR 0
#define CONFIG_UDELAY_TSC 0
#define CONFIG_UART7_IRQ15 0
#define CONFIG_UART4_IRQ 0
#define CONFIG_MMCONF_BASE_ADDRESS 0xf8000000
#define CONFIG_WDT1_INITIALIZE 0
#define CONFIG_GPIO_P3_INIT_DATA 0
#define CONFIG_UART2_IRQ14 0
#define CONFIG_DRIVERS_GENERIC_GENERIC 0
#define CONFIG_BOARD_WINENT_MB6047 0
#define CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8M800 0
#define CONFIG_SATA_MODE 0
#define CONFIG_BOARD_HP_DL145_G1 0
#define CONFIG_UART8_IRQ_DISABLE 0
#define CONFIG_NUM_IPI_STARTS 2
#define CONFIG_GPIO_P1_ENABLE 0
#define CONFIG_BOARD_VIA_EPIA_M 0
#define CONFIG_BOARD_AMD_BIMINI_FAM10 0
#define CONFIG_ROMSTAGE_BASE 0
#define CONFIG_BOARD_ASUS_F2A85_M_DDR3_VOLT_150 0
#define CONFIG_UART9_IRQ9 0
#define CONFIG_UART4_IO_PORT_3F8 0
#define CONFIG_SPI_FLASH 1
#define CONFIG_UART9_IO_PORT_3E8 0
#define CONFIG_UART7_IRQ6 0
#define CONFIG_GX2_VIDEO_MB_4MB 0
#define CONFIG_BOARD_ASI_MB_5BLGP 0
#define CONFIG_SLOT_SPECIFIC_OPTIONS 0
#define CONFIG_CPU_INTEL_HASWELL 0
#define CONFIG_UART10_IRQ10 0
#define CONFIG_UART10_IO_PORT_OTHER_INPUT 0
#define CONFIG_USBDEBUG_DONGLE_BEAGLEBONE_BLACK 0
#define CONFIG_BOARD_AVALUE_EAX_785E 0
#define CONFIG_VENDOR_COMPAQ 0
#define CONFIG_VBNV_OFFSET 0
#define CONFIG_NORTHBRIDGE_INTEL_E7520 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_116 0
#define CONFIG_SUPERIO_ITE_IT8716F_OVERRIDE_FANCTL 0
#define CONFIG_SOUTHBRIDGE_TI_PCIXX12 0
#define CONFIG_BOARD_SUPERMICRO_X7DB8 0
#define CONFIG_UART1_IRQ5 0
#define CONFIG_VIRTUAL_ROM_SIZE 0
#define CONFIG_CK804_USE_ACI 0
#define CONFIG_GX2_VIDEO_MB_64MB 0
#define CONFIG_ENABLE_POWER_BUTTON 0
#define CONFIG_CPU_INTEL_MODEL_F2X 0
#define CONFIG_BOARD_SUPERMICRO_X6DHE_G 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA 1
#define CONFIG_GPIO_P8_INIT_DATA 0
#define CONFIG_GPIO_P1_INIT_DIR 0
#define CONFIG_GPIO_P5_DATA_ADDR 0
#define CONFIG_BOARD_ASUS_K8V_X 0
#define CONFIG_GPIO_P6_ENABLE 0
#define CONFIG_BOARD_BCOM_WINNETP680 0
#define CONFIG_CPU_MICROCODE_CBFS_NONE 1
#define CONFIG_SUPERIO_ITE_IT8721F 0
#define CONFIG_CPU_AMD_MODEL_FXX 0
#define CONFIG_UART_FOR_CONSOLE 0
#define CONFIG_CPU_INTEL_MODEL_1067X 0
#define CONFIG_YABEL_PCI_FAKE_WRITING_OTHER_DEVICES_CONFIG 0
#define CONFIG_X86EMU_DEBUG_IO 0
#define CONFIG_EC_GOOGLE_CHROMEEC_SPI_CHIP 0
#define CONFIG_DRAM_RESET_GATE_GPIO 0
#define CONFIG_USE_WATCHDOG_ON_BOOT 0
#define CONFIG_SUPERIO_SMSC_SCH4037 0
#define CONFIG_BOARD_OLD_REVISION 0
#define CONFIG_USE_GENERIC_FSP_CAR_INC 0
#define CONFIG_BOARD_TYAN_S2881 0
#define CONFIG_IOMMU 0
#define CONFIG_LINT01_CONVERSION 0
#define CONFIG_DEBUG_CBFS 0
#define CONFIG_BOARD_AMD_OLIVEHILL 0
#define CONFIG_CMOS_POST_EXTRA 0
#define CONFIG_GPIO_P9_INIT_DATA 0
#define CONFIG_X86EMU_DEBUG_MEM 0
#define CONFIG_INTEL_DP 0
#define CONFIG_LPT_IRQ12 0
#define CONFIG_USE_BLOBS 0
#define CONFIG_GPIO_P1_DIR_ADDR 0
#define CONFIG_HUDSON_SATA_IDE 0
#define CONFIG_CONSOLE_QEMU_DEBUGCON 0
#define CONFIG_ARCH_RAMSTAGE_ARMV7 0
#define CONFIG_BOARD_IEI_JUKI_511P 0
#define CONFIG_HAVE_FSP_BIN 0
#define CONFIG_UART10_IO_PORT_3E8 0
#define CONFIG_HAVE_HARD_RESET 1
#define CONFIG_NORTHBRIDGE_VIA_VT8601 0
#define CONFIG_CN700_VIDEO_MB_128MB 0
#define CONFIG_CONSOLE_POST 0
#define CONFIG_BOARD_TYAN_S4882 0
#define CONFIG_VENDOR_SUPERMICRO 0
#define CONFIG_LIMIT_HT_SPEED_800 0
#define CONFIG_MAX_CPUS 2
#define CONFIG_SET_FIDVID_CORE0_ONLY 0
#define CONFIG_SUPERIO_WINBOND_W83977F 0
#define CONFIG_CONSOLE_SERIAL_9600 0
#define CONFIG_USBDEBUG_DEFAULT_PORT 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_100 0
#define CONFIG_VENDOR_MITAC 0
#define CONFIG_UART9_IRQ3 0
#define CONFIG_CPU_INTEL_MODEL_6BX 0
#define CONFIG_UART3_IRQ11 0
#define CONFIG_AP_SIPI_VECTOR 0xfffff000
#define CONFIG_BUILD_WITH_FAKE_IFD 0
#define CONFIG_GPIO_P4_ENABLE 0
#define CONFIG_RAMINIT_SYSINFO 0
#define CONFIG_HUDSON_GEC_FWM 0
#define CONFIG_SUPERIO_NSC_PC87427 0
#define CONFIG_PCI_OPTION_ROM_RUN_YABEL 0
#define CONFIG_SUPERIO_SMSC_SIO10N268 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_118 0
#define CONFIG_GPIO_P1_DATA_ADDR 0
#define CONFIG_DEBUG_PIRQ 0
#define CONFIG_HUDSON_SATA_AHCI7804 0
#define CONFIG_MAC_POWERDOWN 0
#define CONFIG_CPU_AMD_SOCKET_F 0
#define CONFIG_HPET_ADDRESS 0xfed00000
#define CONFIG_SUPERIO_FINTEK_COMMON_ROMSTAGE 1
#define CONFIG_VENDOR_TELEVIDEO 0
#define CONFIG_CPU_INTEL_NUM_FIT_ENTRIES 0
#define CONFIG_BOARD_SOYO_SY_6BA_PLUS_III 0
#define CONFIG_PAYLOAD_FILO 0
#define CONFIG_CONSOLE_SERIAL_57600 0
#define CONFIG_UDELAY_TIMER2 0
#define CONFIG_BOARD_ASI_MB_5BLMP 0
#define CONFIG_PC80_SYSTEM 1
#define CONFIG_CN400_VIDEO_MB_8MB 0
#define CONFIG_BOARD_LENOVO_T530 0
#define CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8T800PRO 0
#define CONFIG_UART5_IRQ15 0
#define CONFIG_DRIVERS_EMULATION_QEMU_BOCHS 0
#define CONFIG_SUPERIO_NSC_PC97307 0
#define CONFIG_SUPERIO_RENESAS_M3885X 0
#define CONFIG_LPT_IO 0
#define CONFIG_MIRROR_PAYLOAD_TO_RAM_BEFORE_LOADING 0
#define CONFIG_UART2_IO_PORT_2E8 0
#define CONFIG_BOARD_JETWAY_J7F4K1G5D 0
#define CONFIG_UART10_IRQ6 0
#define CONFIG_CN400_VIDEO_MB_64MB 0
#define CONFIG_LPT_IRQ5 0
#define CONFIG_UART8_IRQ14 0
#define CONFIG_SOUTHBRIDGE_VIA_VT8231 0
#define CONFIG_UART6_ENABLE 0
#define CONFIG_UART5_IRQ3 0
#define CONFIG_BOARD_VIA_EPIA_ML 0
#define CONFIG_UART2_IRQ6 0
#define CONFIG_FILO_STABLE 0
#define CONFIG_USB1_POWERDOWN 0
#define CONFIG_NORTHBRIDGE_INTEL_I440BX 0
#define CONFIG_CPU_INTEL_MODEL_6XX 0
#define CONFIG_BOARD_ABIT_BE6_II_V2_0 0
#define CONFIG_BOARD_ASUS_M4A78_EM 0
#define CONFIG_CPU_INTEL_SOCKET_MFCBGA479 0
#define CONFIG_UART9_IRQ 0
#define CONFIG_UART6_IO_PORT_3F8 0
#define CONFIG_NORTHBRIDGE_INTEL_I855 0
#define CONFIG_UART5_IRQ6 0
#define CONFIG_BOARD_EAGLELION_5BCM 0
#define CONFIG_CPU_AMD_SOCKET_C32_NON_AGESA 0
#define CONFIG_X86EMU_DEBUG_INT10 0
#define CONFIG_PAYLOAD_NONE 1
#define CONFIG_BOARD_IEI_NOVA_4899R 0
#define CONFIG_BOARD_LENOVO_X201 0
#define CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8T800_OLD 0
#define CONFIG_ELOG_GSMI 0
#define CONFIG_UART5_IO_PORT_2E8 0
#define CONFIG_CPU_AMD_AGESA 1
#define CONFIG_DRIVERS_I2C_ADT7463 0
#define CONFIG_CPU_INTEL_SOCKET_RPGA989 0
#define CONFIG_SATA_CONTROLLER_MODE 0
#define CONFIG_BOARD_TYAN_S8226 0
#define CONFIG_LIMIT_HT_SPEED_1000 0
#define CONFIG_UART10_IRQ15 0
#define CONFIG_SOUTHBRIDGE_RICOH_RL5C476 0
#define CONFIG_BOARD_AXUS_TC320 0
#define CONFIG_BOARD_ROMSIZE_KB_4096 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA_FAMILY15_TN 0
#define CONFIG_GPIO_P9_ENABLE 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_115 0
#define CONFIG_SOUTHBRIDGE_AMD_CS5530 0
#define CONFIG_BOARD_LIPPERT_ROADRUNNER_LX 0
#define CONFIG_BOARD_NEWISYS_KHEPRI 0
#define CONFIG_VENDOR_DIGITALLOGIC 0
#define CONFIG_MAINBOARD_PART_NUMBER "NF81-T56N-LF"
#define CONFIG_SMP 1
#define CONFIG_PLL_400_300_33 0
#define CONFIG_SUPERIO_NSC_PC87309 0
#define CONFIG_H8_DOCK_EARLY_INIT 0
#define CONFIG_BOARD_IBM_E326 0
#define CONFIG_BOARD_TYAN_S2892 0
#define CONFIG_UART10_IO_PORT_2E8 0
#define CONFIG_INTEL_LYNXPOINT_LP 0
#define CONFIG_NORTHBRIDGE_INTEL_NEHALEM 0
#define CONFIG_EC_LENOVO_PMH7 0
#define CONFIG_SUPERIO_NUVOTON_NCT5104D 0
#define CONFIG_NORTHBRIDGE_VIA_VX900 0
#define CONFIG_SUPERIO_SMSC_FDC37N972 0
#define CONFIG_ELOG_BOOT_COUNT_CMOS_OFFSET 0
#define CONFIG_SUPERIO_SMSC_LPC47N217 0
#define CONFIG_HAVE_USBDEBUG_OPTIONS 1
#define CONFIG_REDIRECT_SBCIMX_TRACE_TO_SERIAL 0
#define CONFIG_UART10_IRQ 0
#define CONFIG_BOARD_SUPERMICRO_X6DAI_G 0
#define CONFIG_BOARD_ASUS_P2B_D 0
#define CONFIG_BOARD_DIGITALLOGIC_MSM800SEV 0
#define CONFIG_CPU_AMD_AGESA_FAMILY14 1
#define CONFIG_UART7_IO_PORT_2E8 0
#define CONFIG_SOUTHBRIDGE_AMD_AGESA_HUDSON 0
#define CONFIG_CPU_ARMLTD_CORTEX_A9 0
#define CONFIG_SUPERIO_FINTEK_F71889 0
#define CONFIG_GDB_WAIT 0
#define CONFIG_SOUTHBRIDGE_VIA_K8M890_VGA_EN 0
#define CONFIG_I2C_BASE 0
#define CONFIG_VENDOR_ECS 0
#define CONFIG_GX1_VIDEOMODE_0 0
#define CONFIG_PCI_OPTION_ROM_RUN_REALMODE 1
#define CONFIG_TSC_CONSTANT_RATE 0
#define CONFIG_LPT_IRQ11 0
#define CONFIG_NORTHBRIDGE_INTEL_I945 0
#define CONFIG_VBOOT_BOOT_LOADER_INDEX 0
#define CONFIG_UART9_IO_PORT_2E8 0
#define CONFIG_UART3_IO_PORT_2F8 0
#define CONFIG_ONBOARD_LIGHTSENSOR 0
#define CONFIG_GPIO_P8_DATA_ADDR 0
#define CONFIG_K8_ALLOCATE_IO_RANGE 0
#define CONFIG_UART7_IRQ_DISABLE 0
#define CONFIG_LOCALVERSION ""
#define CONFIG_MRC_CACHE_LOC 0
#define CONFIG_SUPERIO_FINTEK_F71859 0
#define CONFIG_WAIT_BEFORE_CPUS_INIT 0
#define CONFIG_UART1_IRQ10 0
#define CONFIG_UART9_IRQ6 0
#define CONFIG_POWER_BUTTON_DEFAULT_DISABLE 0
#define CONFIG_UART3_IRQ12 0
#define CONFIG_PCI_IO_CFG_EXT 1
#define CONFIG_AMD_SB_SPI_TX_LEN 4
#define CONFIG_UART1_IO_PORT_OTHER 0
#define CONFIG_CN400_VIDEO_MB_32MB 0
#define CONFIG_UART1_IO_PORT_OTHER_INPUT 0
#define CONFIG_WDT1_SIGNAL_SMI 0
#define CONFIG_CN700_VIDEO_MB_64MB 0
#define CONFIG_GENERATE_PIRQ_TABLE 1
#define CONFIG_PAYLOAD_LINUX 0
#define CONFIG_AP_IN_SIPI_WAIT 0
#define CONFIG_GPIO_P2_INIT_DATA 0
#define CONFIG_BOARD_LIPPERT_SPACERUNNER_LX 0
#define CONFIG_CPU_INTEL_SLOT_1 0
#define CONFIG_UART9_ENABLE 0
#define CONFIG_BOARD_MSI_MS7135 0
#define CONFIG_EC_ACPI 0
#define CONFIG_UART4_IRQ5 0
#define CONFIG_CPU_AMD_SOCKET_939 0
#define CONFIG_BOARD_TECHNOLOGIC_TS5300 0
#define CONFIG_LPT_IO_PORT_OTHER 0
#define CONFIG_UART5_IRQ12 0
#define CONFIG_SB800_AHCI_ROM 0
#define CONFIG_BOARD_ROMSIZE_KB_12288 0
#define CONFIG_CPU_INTEL_MODEL_F1X 0
#define CONFIG_CACHE_MRC_SIZE_KB 0
#define CONFIG_VBOOT_RAMSTAGE_INDEX 0
#define CONFIG_UART10_IRQ5 0
#define CONFIG_DEBUG_CAR 0
#define CONFIG_UART5_IO_PORT_OTHER_INPUT 0
#define CONFIG_CPU_ALLWINNER_A10 0
#define CONFIG_LPT_IRQ6 0
#define CONFIG_GPIO_P2_ENABLE 0
#define CONFIG_UART9_IRQ10 0
#define CONFIG_CPU_AMD_MODEL_10XXX 0
#define CONFIG_X86EMU_DEBUG_TRACE 0
#define CONFIG_K8M890_VIDEO_MB_256MB 0
#define CONFIG_MAINBOARD_SMBIOS_PRODUCT_NAME "Jupiter-NAS-alpha"
#define CONFIG_EC_GOOGLE_CHROMEEC_I2C 0
#define CONFIG_VBNV_SIZE 0
#define CONFIG_ADC_POWERDOWN 0
#define CONFIG_HAVE_OPTION_TABLE 1
#define CONFIG_HAVE_MP_TABLE 1
#define CONFIG_UART9_IRQ_DISABLE 0
#define CONFIG_BOARD_ASUS_DSBF 0
#define CONFIG_LOCK_SPI_ON_RESUME 0
#define CONFIG_UART4_IRQ12 0
#define CONFIG_SOUTHBRIDGE_NVIDIA_MCP55 0
#define CONFIG_SUPERIO_ITE_IT8772F 0
#define CONFIG_CX700_VIDEO_MB_16MB 0
#define CONFIG_BOARD_HP_PAVILION_M6_1035DX 0
#define CONFIG_BOARD_ASUS_A8V_E_DELUXE 0
#define CONFIG_SOUTHBRIDGE_RDC_R8610 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_4 0
#define CONFIG_I830_VIDEO_MB_OFF 0
#define CONFIG_FSP_LOC 0
#define CONFIG_TSC_SYNC_MFENCE 0
#define CONFIG_HAVE_ME_BIN 0
#define CONFIG_CORE_GLIU_500_333 0
#define CONFIG_SPI_FLASH_ADESTO 1
#define CONFIG_HUDSON_SATA_IDE2AHCI7804 0
#define CONFIG_CPU_INTEL_SOCKET_FC_PGA370 0
#define CONFIG_UART9_IO_PORT_OTHER_INPUT 0
#define CONFIG_VENDOR_LENOVO 0
#define CONFIG_DRIVERS_EMULATION_QEMU_BOCHS_XRES 0
#define CONFIG_VENDOR_AAEON 0
#define CONFIG_CHROMEOS 0
#define CONFIG_UDELAY_LAPIC_FIXED_FSB 200
#define CONFIG_CPU_SAMSUNG_EXYNOS5420 0
#define CONFIG_BOARD_AMD_SERENGETI_CHEETAH 0
#define CONFIG_CPU_INTEL_MODEL_2065X 0
#define CONFIG_BOARD_PCENGINES_ALIX6 0
#define CONFIG_USBDEBUG_DONGLE_STD 0
#define CONFIG_LIMIT_HT_DOWN_WIDTH_8 0
#define CONFIG_BOARD_AMD_DINAR 0
#define CONFIG_VGA_BIOS_ID "1002,9806"
#define CONFIG_SATA_MODE_IDE 0
#define CONFIG_MCP55_PCI_E_X_0 0
#define CONFIG_X86EMU_DEBUG_DISK 0
#define CONFIG_MAINBOARD_VERSION "1.0"
#define CONFIG_SOUTHBRIDGE_TI_PCI7420 0
#define CONFIG_AZALIA_PLUGIN_SUPPORT 0
#define CONFIG_GPIO_P0_INIT_DATA 0
#define CONFIG_VENDOR_IWAVE 0
#define CONFIG_HAVE_DEBUG_SMBUS 0
#define CONFIG_ELOG_BOOT_COUNT 0
#define CONFIG_HUDSON_IMC_FWM 0
#define CONFIG_UART7_IO_PORT_3E8 0
#define CONFIG_RELOCATABLE_MODULES 0
#define CONFIG_BOARD_LIPPERT_HURRICANE_LX 0
#define CONFIG_BOARD_VIA_VT8454C 0
#define CONFIG_BOARD_ROMSIZE_KB_512 0
#define CONFIG_GX1_VIDEOMODE_3 0
#define CONFIG_CPU_INTEL_FSP_MODEL_306AX 0
#define CONFIG_SSE2 0
#define CONFIG_VENDOR_WYSE 0
#define CONFIG_LPT_IRQ14 0
#define CONFIG_UART2_IO_PORT_OTHER_INPUT 0
#define CONFIG_BOARD_LENOVO_X230 0
#define CONFIG_VDD_LDO2_MV 0
#define CONFIG_SUPERIO_WINBOND_W83627DHG 0
#define CONFIG_HUDSON_SATA_AHCI 0
#define CONFIG_CPU_INTEL_SOCKET_LGA771 0
#define CONFIG_UART2_IRQ10 0
#define CONFIG_UART6_IO_PORT_OTHER_INPUT 0
#define CONFIG_COREBOOT_ROMSIZE_KB_128 0
#define CONFIG_UART2_IO_PORT_OTHER 0
#define CONFIG_NORTHBRIDGE_INTEL_I5000 0
#define CONFIG_SUPERIO_ITE_IT8661F 0
#define CONFIG_I830_VIDEO_MB_1MB 0
#define CONFIG_ONBOARD_WEBCAM 0
#define CONFIG_CN400_VIDEO_MB_16MB 0
#define CONFIG_SUPERIO_NSC_PC87351 0
#define CONFIG_MAINBOARD_PCI_SUBSYSTEM_DEVICE_ID 0
#define CONFIG_HAVE_CMOS_DEFAULT 0
#define CONFIG_SB800_FWM_AT_FFC20000 0
#define CONFIG_UART6_IRQ5 0
#define CONFIG_BOARD_MSI_MS_6147 0
#define CONFIG_BOARD_ROMSIZE_KB_16384 0
#define CONFIG_DEBUG_SMBUS 0
#define CONFIG_DRIVERS_I2C_I2CMUX2 0
#define CONFIG_UART1_IRQ15 0
#define CONFIG_UART9_IRQ5 0
#define CONFIG_GPIO_P7_DATA_ADDR 0
#define CONFIG_TSC_MONOTONIC_TIMER 0
#define CONFIG_DRIVERS_EMULATION_QEMU_BOCHS_YRES 0
#define CONFIG_VENDOR_MSI 0
#define CONFIG_DRIVERS_I2C_ADM1026 0
#define CONFIG_SUPERIO_WINBOND_W83627UHG 0
#define CONFIG_EXPERT 0
#define CONFIG_SUPERIO_FINTEK_F81865F 0
#define CONFIG_HAVE_MONOTONIC_TIMER 1
#define CONFIG_VENDOR_IBM 0
#define CONFIG_UART6_IRQ11 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_112 0
#define CONFIG_CX700_VIDEO_MB_OFF 0
#define CONFIG_USBDEBUG 0
#define CONFIG_UART10_IO_PORT_OTHER 0
#define CONFIG_HAVE_ACPI_TABLES 1
#define CONFIG_PLL_500_250_33 0
#define CONFIG_ONBOARD_IDE_SLAVE 0
#define CONFIG_UART1_IRQ12 0
#define CONFIG_POST_DEVICE_PCI_PCIE 0
#define CONFIG_BOARD_AMD_NORWICH 0
#define CONFIG_MRC_SETTINGS_CACHE_SIZE 0
#define CONFIG_LIMIT_HT_UP_WIDTH_8 0
#define CONFIG_BOARD_ASUS_M5A88_V 0
#define CONFIG_DEBUG_MALLOC 0
#define CONFIG_FRAMEBUFFER_SET_VESA_MODE 0
#define CONFIG_DIMM_FBDIMM 0
#define CONFIG_HUDSON_SATA_MODE 0
#define CONFIG_CX700_VIDEO_MB_64MB 0
#define CONFIG_BOARD_IWILL_DK8S2 0
#define CONFIG_VENDOR_TYAN 0
#define CONFIG_GX2_PROCESSOR_MHZ_400 0
#define CONFIG_HAVE_REFCODE_BLOB 0
#define CONFIG_UART4_IRQ6 0
#define CONFIG_WDT1_SINGAL_NMI 0
#define CONFIG_SUPERIO_SMSC_MEC1308 0
#define CONFIG_LPT_IO_PORT_OTHER_INPUT 0
#define CONFIG_UART1_IRQ_DISABLE 0
#define CONFIG_CPU_MICROCODE_CBFS_LOC 0
#define CONFIG_BOARD_HP_DL165_G6_FAM10 0
#define CONFIG_UART2_IO_PORT_3F8 0
#define CONFIG_BOARD_TYAN_S2885 0
#define CONFIG_SUPERIO_SERVERENGINES_PILOT 0
#define CONFIG_BOARD_GETAC_P470 0
#define CONFIG_GX2_PROCESSOR_MHZ_300 0
#define CONFIG_CPU_INTEL_MODEL_68X 0
#define CONFIG_HPET_MIN_TICKS 0
#define CONFIG_SPI_FLASH_SPANSION 1
#define CONFIG_SUPERIO_INTEL_I3100 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA_FAMILY16_KB 0
#define CONFIG_UART9_IRQ15 0
#define CONFIG_BOARD_ASROCK_IMB_A180 0
#define CONFIG_I830_VIDEO_MB_512KB 0
#define CONFIG_UART4_IO_PORT_2E8 0
#define CONFIG_BOARD_PCENGINES_ALIX2D 0
#define CONFIG_IDE_NATIVE_MODE 0
#define CONFIG_IDE_COMBINED_MODE 0x1
#define CONFIG_BOARD_AMD_SERENGETI_CHEETAH_FAM10 0
#define CONFIG_EC_QUANTA_ENE_KB3940Q 0
#define CONFIG_BOARD_KONTRON_KTQM77 0
#define CONFIG_LPT_MODE_ECP_AND_EPP_19 0
#define CONFIG_TTYS0_BASE 0x3f8
#define CONFIG_UART4_IRQ11 0
#define CONFIG_DEBUG_SMM_RELOCATION 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801AX 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_104 0
#define CONFIG_TRAINING_CACHE_SIZE 0
#define CONFIG_EC_COMPAL_ENE932 0
#define CONFIG_BOARD_INTEL_WTM2 0
#define CONFIG_ONBOARD_BLUETOOTH 0
#define CONFIG_AZ_PIN 0
#define CONFIG_UART5_IRQ_DISABLE 0
#define CONFIG_UART5_IO_PORT_3F8 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_1 0
#define CONFIG_PLL_400_200_100 0
#define CONFIG_TTYS0_LCS 3
#define CONFIG_BOARD_TECHNEXION_TIM5690 0
#define CONFIG_I855_VIDEO_MB_OFF 0
#define CONFIG_GPIO_P4_INIT_DIR 0
#define CONFIG_BOARD_JETWAY_PA78VM5 0
#define CONFIG_FILO_MASTER 0
#define CONFIG_LIMIT_HT_SPEED_2200 0
#define CONFIG_LIMIT_HT_SPEED_1800 0
#define CONFIG_BOARD_MSI_MS_6156 0
#define CONFIG_SUPERIO_WINBOND_W83697HF 0
#define CONFIG_CPU_INTEL_MODEL_6FX 0
#define CONFIG_LIMIT_HT_SPEED_2400 0
#define CONFIG_SUPERIO_SMSC_SMSCSUPERIO 0
#define CONFIG_X86EMU_DEBUG_PNP 0
#define CONFIG_IDE_LEGACY_MODE 0
#define CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8T890 0
#define CONFIG_SB800_IMC_FAN_CONTROL 0
#define CONFIG_MRC_CACHE_LOC_OVERRIDE 0
#define CONFIG_NORTHBRIDGE_INTEL_I3100 0
#define CONFIG_BOARD_INTEL_EAGLEHEIGHTS 0
#define CONFIG_VENDOR_SUNW 0
#define CONFIG_SDRAMPWR_4DIMM 0
#define CONFIG_REDIRECT_NBCIMX_TRACE_TO_SERIAL 0
#define CONFIG_SEABIOS_THREAD_OPTIONROMS 0
#define CONFIG_NORTHBRIDGE_INTEL_GM45 0
#define CONFIG_VENDOR_BROADCOM 0
#define CONFIG_CX700_VIDEO_MB_32MB 0
#define CONFIG_SUPERIO_NSC_PC87384 0
#define CONFIG_UART8_IRQ7 0
#define CONFIG_VENDOR_SOYO 0
#define CONFIG_INCLUDE_CONFIG_FILE 1
#define CONFIG_LAPIC_MONOTONIC_TIMER 1
#define CONFIG_IDE_POWERDOWN 0
#define CONFIG_ONBOARD_TRAVIS 0
#define CONFIG_BOARD_ARTECGROUP_DBE61 0
#define CONFIG_UART3_IRQ5 0
#define CONFIG_UART8_IRQ10 0
#define CONFIG_UPDATE_IMAGE 0
#define CONFIG_VENDOR_GETAC 0
#define CONFIG_SOUTHBRIDGE_TI_PCI1X2X 0
#define CONFIG_REDIRECT_IDS_HDT_CONSOLE_TO_SERIAL 0
#define CONFIG_UART2_IRQ 0
#define CONFIG_ONBOARD_VGA_IS_PRIMARY 1
#define CONFIG_UART9_IO_PORT_3F8 0
#define CONFIG_SB_HT_CHAIN_UNITID_OFFSET_ONLY 0
#define CONFIG_SUPERIO_VIA_VT1211 0
#define CONFIG_SOUTHBRIDGE_INTEL_BD82X6X 0
#define CONFIG_SUPERIO_NSC_PC87417 0
#define CONFIG_APIC_ID_OFFSET 0
#define CONFIG_GPIO_P6_DIR_ADDR 0
#define CONFIG_SATA_MODE_AHCI 0
#define CONFIG_LPT_ENABLE 0
#define CONFIG_HUDSON_XHCI_FWM 0
#define CONFIG_SUPERIO_SMSC_LPC47M10X 0
#define CONFIG_SOUTHBRIDGE_VIA_VT8237R 0
#define CONFIG_I855_VIDEO_MB_1MB 0
#define CONFIG_BOARD_VIA_EPIA_CN 0
#define CONFIG_CPU_INTEL_SOCKET_441 0
#define CONFIG_BOOTBLOCK_BASE 0
#define CONFIG_VENDOR_EMULATION 0
#define CONFIG_BOARD_AMD_TORPEDO 0
#define CONFIG_SB800_SATA_AHCI 1
#define CONFIG_BOARD_RODA_RK9 0
#define CONFIG_UART7_IRQ5 0
#define CONFIG_VENDOR_BIFFEROS 0
#define CONFIG_UART10_IRQ11 0
#define CONFIG_UART7_ENABLE 0
#define CONFIG_UART9_IO 0
#define CONFIG_EPIA_VT8237R_INIT 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_111 0
#define CONFIG_SOUTHBRIDGE_INTEL_FSP_BD82X6X 0
#define CONFIG_BOARD_HP_E_VECTRA_P2706T 0
#define CONFIG_UART1_IRQ4 0
#define CONFIG_SUPERIO_ITE_IT8671F 0
#define CONFIG_SOUTHBRIDGE_AMD_CIMX_SB800 1
#define CONFIG_CACHE_MRC_BIN 0
#define CONFIG_HAVE_DEBUG_RAM_SETUP 0
#define CONFIG_LIFT_BSP_APIC_ID 0
#define CONFIG_SUPERIO_SMSC_LPC47M15X 0
#define CONFIG_GPIO_P6_INIT_DIR 0
#define CONFIG_EC_GOOGLE_CHROMEEC_I2C_CHIP 0
#define CONFIG_CPU_INTEL_FSP_MODEL_206AX 0
#define CONFIG_SB_HT_CHAIN_ON_BUS0 0
#define CONFIG_LIMIT_HT_SPEED_1200 0
#define CONFIG_PLL_466_350_33 0
#define CONFIG_SPI_FLASH_MACRONIX 1
#define CONFIG_ELOG_FULL_THRESHOLD 0
#define CONFIG_SOUTHBRIDGE_AMD_RS690 0
#define CONFIG_GPIO_P9_INIT_DIR 0
#define CONFIG_UART4_IRQ3 0
#define CONFIG_BOARD_AMD_TILAPIA_FAM10 0
#define CONFIG_HUDSON_FWM_POSITION 0
#define CONFIG_PCIEXP_ASPM 1
#define CONFIG_NORTHBRIDGE_INTEL_FSP_SANDYBRIDGE 0
#define CONFIG_CPU_AMD_AGESA_FAMILY10 0
#define CONFIG_BOARD_TYAN_S2882 0
#define CONFIG_GX1_VIDEOMODE_4 0
#define CONFIG_BOARD_AZZA_PT_6IBD 0
#define CONFIG_BOARD_GOOGLE_PEPPY 0
#define CONFIG_DEBUG_ACPI 0
#define CONFIG_MAINBOARD_SERIAL_NUMBER "123456789"
#define CONFIG_GPIO_P2_DATA_ADDR 0
#define CONFIG_CPU_AMD_SOCKET_C32 0
#define CONFIG_UART5_IRQ 0
#define CONFIG_CPU_INTEL_TURBO_NOT_PACKAGE_SCOPED 0
#define CONFIG_SOUTHBRIDGE_AMD_SR5650 0
#define CONFIG_BOARD_AMD_SOUTHSTATION 0
#define CONFIG_BOARD_ASROCK_939A785GMH 0
#define CONFIG_VGA_BIOS 0
#define CONFIG_PLL_500_375_33 0
#define CONFIG_BOARD_PCENGINES_ALIX2C 0
#define CONFIG_LPT_MODE_BPP 0
#define CONFIG_DRIVERS_UART_8250MEM 0
#define CONFIG_X86EMU_DEBUG 0
#define CONFIG_BOARD_IEI_PCISA_LX_800_R10 0
#define CONFIG_UART2_IO_PORT_2F8 0
#define CONFIG_CPU_INTEL_MODEL_106CX 0
#define CONFIG_VENDOR_NOKIA 0
#define CONFIG_CPU_INTEL_MODEL_F4X 0
#define CONFIG_YABEL_PCI_ACCESS_OTHER_DEVICES 0
#define CONFIG_CPU_AMD_SOCKET_754 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_101 0
#define CONFIG_BOOTBLOCK_NORMAL 0
#define CONFIG_MCP55_NUM 0
#define CONFIG_SCONFIG_GENPARSER 0
#define CONFIG_FINALIZE_USB_ROUTE_XHCI 0
#define CONFIG_BOARD_MSI_MS9282 0
#define CONFIG_GPIO_P4_DATA_ADDR 0
#define CONFIG_UART6_IO_PORT_OTHER 0
#define CONFIG_HAVE_SMI_HANDLER 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_2 0
#define CONFIG_PLL_300_300_100 0
#define CONFIG_BOARD_AMD_UNIONSTATION 0
#define CONFIG_VENDOR_KONTRON 0
#define CONFIG_NORTHBRIDGE_VIA_VT8623 0
#define CONFIG_CCACHE 0
#define CONFIG_ROM_SIZE 0x200000
#define CONFIG_GPIO_P6_INIT_DATA 0
#define CONFIG_NORTHBRIDGE_DMP_VORTEX86EX 0
#define CONFIG_BOARD_TYAN_S2912 0
#define CONFIG_BOARD_SUPERMICRO_X6DHR_IG 0
#define CONFIG_CPU_INTEL_SOCKET_MPGA479M 0
#define CONFIG_BOARD_ASUS_M4A785M 0
#define CONFIG_BOARD_BIOSTAR_M6TBA 0
#define CONFIG_VENDOR_ADVANSUS 0
#define CONFIG_NORTHBRIDGE_INTEL_IVYBRIDGE 0
#define CONFIG_VENDOR_BACHMANN 0
#define CONFIG_MAX_PHYSICAL_CPUS 0
#define CONFIG_K8M890_VIDEO_MB_CMOS 0
#define CONFIG_VENDOR_RCA 0
#define CONFIG_UART4_IO_PORT_3E8 0
#define CONFIG_BOARD_ASUS_P2B_LS 0
#define CONFIG_GPIO_P5_DIR_ADDR 0
#define CONFIG_SPI_FLASH_EON 1
#define CONFIG_SEABIOS_STABLE 0
#define CONFIG_BOARD_ASUS_A8N_SLI 0
#define CONFIG_VGA 0
#define CONFIG_ELOG 0
#define CONFIG_DCACHE_RAM_BASE 0x30000
#define CONFIG_NORTHBRIDGE_AMD_AMDFAM10 0
#define CONFIG_PIRQ_ROUTE 0
#define CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8T800 0
#define CONFIG_PLL_500_500_33 0
#define CONFIG_ME_MBP_CLEAR_LATE 0
#define CONFIG_UART8_IO_PORT_2F8 0
#define CONFIG_X86EMU_DEBUG_TIMINGS 0
#define CONFIG_UART2_IRQ7 0
#define CONFIG_CHROMEOS_RAMOOPS 0
#define CONFIG_LOCK_MANAGEMENT_ENGINE 0
#define CONFIG_BOARD_BCOM_WINNET100 0
#define CONFIG_BOARD_INTEL_COUGAR_CANYON2 0
#define CONFIG_VENDOR_RODA 0
#define CONFIG_CONSOLE_QEMU_DEBUGCON_PORT 0
#define CONFIG_VENDOR_PACKARDBELL 0
#define CONFIG_PLLMSRlo 0
#define CONFIG_GPIO_P6_DATA_ADDR 0
#define CONFIG_GPIO_P4_INIT_DATA 0
#define CONFIG_VENDOR_TRAVERSE 0
#define CONFIG_VDD_LDO3_MV 0
#define CONFIG_UART2_ENABLE 0
#define CONFIG_LIMIT_HT_SPEED_600 0
#define CONFIG_AMD_NB_CIMX 0
#define CONFIG_BOARD_GOOGLE_LINK 0
#define CONFIG_UART5_IRQ9 0
#define CONFIG_K8M890_VIDEO_MB_128MB 0
#define CONFIG_PARALLEL_MP 0
#define CONFIG_SUPERIO_SMSC_LPC47B272 0
#define CONFIG_GDB_STUB 0
#define CONFIG_SUPERIO_SMSC_SIO1036 0
#define CONFIG_HAVE_ACPI_RESUME 1
#define CONFIG_SMM_MODULE_HEAP_SIZE 0
#define CONFIG_SOUTHBRIDGE_INTEL_IBEXPEAK 0
#define CONFIG_BOARD_ADVANSUS_A785E_I 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_8 0
#define CONFIG_UART3_IO_PORT_2E8 0
#define CONFIG_BOARD_GOOGLE_RAMBI 0
#define CONFIG_VDD_MIF_MV 0
#define CONFIG_EARLY_PCI_MMIO_BASE 0
#define CONFIG_VENDOR_AZZA 0
#define CONFIG_SMM_TSEG_SIZE 0x0
#define CONFIG_TSC_CALIBRATE_WITH_IO 0
#define CONFIG_BOARD_AOPEN_DXPLPLUSU 0
#define CONFIG_BOARD_TRAVERSE_GEOS 0
#define CONFIG_BOARD_ROMSIZE_KB_2048 1
#define CONFIG_CPU_TI_AM335X 0
#define CONFIG_BOARD_AMD_INAGUA 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_114 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801DX 0
#define CONFIG_VENDOR_ASI 0
#define CONFIG_DRIVERS_UART_8250IO 1
#define CONFIG_GPIO_P5_INIT_DIR 0
#define CONFIG_HUDSON_FWM 0
#define CONFIG_UART4_IRQ_DISABLE 0
#define CONFIG_PLL_MANUAL_CONFIG 0
#define CONFIG_BOARD_ASUS_P3B_F 0
#define CONFIG_MAINBOARD_PCI_SUBSYSTEM_VENDOR_ID 0
#define CONFIG_BOARD_IBM_E325 0
#define CONFIG_UART6_IO_PORT_2E8 0
#define CONFIG_BOARD_TYAN_S2891 0
#define CONFIG_BOARD_TYAN_S2850 0
#define CONFIG_CPU_MICROCODE_ADDED_DURING_BUILD 0
#define CONFIG_CK804_PCI_E_X 0
#define CONFIG_BOARD_ROMSIZE_KB_128 0
#define CONFIG_NORTHBRIDGE_INTEL_SCH 0
#define CONFIG_CPU_INTEL_MODEL_6EX 0
#define CONFIG_K8_REV_F_SUPPORT 0
#define CONFIG_SOUTHBRIDGE_INTEL_SCH 0
#define CONFIG_BOARD_ASUS_M2N_E 0
#define CONFIG_YABEL_DIRECTHW 0
#define CONFIG_CPU_AMD_AGESA_FAMILY15 0
#define CONFIG_BOARD_ASUS_F2A85_M_DDR3_VOLT_165 0
#define CONFIG_DRIVERS_SIL_3114 0
#define CONFIG_BOARD_ARIMA_HDAMA 0
#define CONFIG_BOARD_SUPERMICRO_H8SCM 0
#define CONFIG_ONBOARD_UARTS_RS485 0
#define CONFIG_VENDOR_GOOGLE 0
#define CONFIG_BOARD_IBASE_MB899 0
#define CONFIG_VDD_LDO10_MV 0
#define CONFIG_CPU_AMD_SOCKET_AM3 0
#define CONFIG_CONSOLE_CAR_BUFFER_SIZE 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801CX 0
#define CONFIG_LPT_IRQ10 0
#define CONFIG_SB800_FWM_AT_FF820000 0
#define CONFIG_BOARD_INTEL_EMERALDLAKE2 0
#define CONFIG_PLATFORM_USES_FSP 0
#define CONFIG_CK804_NUM 0
#define CONFIG_SOUTHBRIDGE_INTEL_I3100 0
#define CONFIG_RAID_MISC_ROM_POSITION 0
#define CONFIG_PXE_ROM 0
#define CONFIG_HAVE_UART_SPECIAL 0
#define CONFIG_AMDMCT 0
#define CONFIG_BOARD_SUPERMICRO_H8DME 0
#define CONFIG_CPU_INTEL_SOCKET_LGA775 0
#define CONFIG_ID_SECTION_OFFSET 0x80
#define CONFIG_EARLY_CBMEM_INIT 0
#define CONFIG_BOARD_VIA_PC2500E 0
#define CONFIG_NORTHBRIDGE_VIA_VX800 0
#define CONFIG_BOARD_AMD_PISTACHIO 0
#define CONFIG_BOARD_SUPERMICRO_H8QGI 0
#define CONFIG_GPIO_P9_DIR_ADDR 0
#define CONFIG_TRACE 0
#define CONFIG_BOARD_ASUS_P2B 0
#define CONFIG_GX1_VIDEOMODE 0
#define CONFIG_HAVE_USBDEBUG 1
#define CONFIG_DRIVERS_I2C_RTD2132 0
#define CONFIG_LPT_MODE_ECP_AND_EPP_17 0
#define CONFIG_POST_DEVICE 0
#define CONFIG_DRIVERS_ICS_954309 0
#define CONFIG_GPIO_P0_ENABLE 0
#define CONFIG_UART2_IO 0
#define CONFIG_VBOOT_VERIFY_FIRMWARE 0
#define CONFIG_UART1_IRQ11 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_102 0
#define CONFIG_CPU_INTEL_MODEL_F3X 0
#define CONFIG_SB800_FWM_POSITION 0
#define CONFIG_BOARD_JETWAY_NF81_T56N_LF 1
#define CONFIG_FRAMEBUFFER_VESA_MODE_10D 0
#define CONFIG_UART6_IRQ15 0
#define CONFIG_CBFS_ROM_OFFSET 0
#define CONFIG_SB800_IMC_FWM 0
#define CONFIG_HAVE_IFD_BIN 0
#define CONFIG_HW_MEM_HOLE_SIZEK 0x200000
#define CONFIG_BOARD_GOOGLE_BUTTERFLY 0
#define CONFIG_CACHE_MRC_SETTINGS 0
#define CONFIG_HAVE_PIRQ_TABLE 1
#define CONFIG_UART3_IO_PORT_3E8 0
#define CONFIG_SQUELCH_EARLY_SMP 1
#define CONFIG_CPU_INTEL_SLOT_2 0
#define CONFIG_POWER_BUTTON_DEFAULT_ENABLE 0
#define CONFIG_SOUTH_BRIDGE_OPTIONS 0
#define CONFIG_SOUTHBRIDGE_BROADCOM_BCM5780 0
#define CONFIG_CPU_INTEL_MODEL_6DX 0
#define CONFIG_PAYLOAD_GRUB2 0
#define CONFIG_SMBIOS_SYSTEM_ENCLOSURE_TYPE 0
#define CONFIG_MAINBOARD_HAS_NATIVE_VGA_INIT_TEXTMODECFG 0
#define CONFIG_MRC_CACHE_SIZE 0
#define CONFIG_GENERATE_ACPI_TABLES 1
#define CONFIG_BOARD_TYAN_S2875 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801IX 0
#define CONFIG_SERIRQ_CONTINUOUS_MODE 0
#define CONFIG_MONOTONIC_TIMER_MSR 0
#define CONFIG_IED_REGION_SIZE 0
#define CONFIG_SOUTHBRIDGE_INTEL_I82801BX 0
#define CONFIG_PAYLOAD_ELF 0
#define CONFIG_RTL8168_ROM_DISABLE 0
#define CONFIG_BOARD_ADVANTECH_PCM_5820 0
#define CONFIG_UART8_IO_PORT_OTHER 0
#define CONFIG_DIMM_REGISTERED 0
#define CONFIG_UART10_IRQ4 0
#define CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8M890 0
#define CONFIG_NORTHBRIDGE_AMD_AGESA_FAMILY12 0
#define CONFIG_CPU_AMD_SOCKET_940 0
#define CONFIG_VIRTUAL_DEV_SWITCH 0
#define CONFIG_CPU_SAMSUNG_EXYNOS5250 0
#define CONFIG_EARLY_PCI_BRIDGE_FUNCTION 0
#define CONFIG_UART3_IRQ3 0
#define CONFIG_LPT_IRQ7 0
#define CONFIG_UART9_IRQ11 0
#define CONFIG_BOARD_ASUS_F2A85_M_DDR3_VOLT_135 0
#define CONFIG_CHROMEOS_RAMOOPS_RAM_SIZE 0
#define CONFIG_UART2_IRQ4 0
#define CONFIG_MRC_BIN_ADDRESS 0
#define CONFIG_SUPERIO_WINBOND_COMMON_ROMSTAGE 0
#define CONFIG_MAINBOARD_DO_NATIVE_VGA_INIT 0
#define CONFIG_SUPERIO_WINBOND_W83627THG 0
#define CONFIG_IRQ_SLOT_COUNT 11
#define CONFIG_DRIVERS_I2C_W83795 0
#define CONFIG_CMOS_POST 0
#define CONFIG_CHECK_SLFRCS_ON_RESUME 0
#define CONFIG_UART7_IRQ10 0
#define CONFIG_UART4_IRQ15 0
#define CONFIG_BROKEN_CAR_MIGRATE 1
#define CONFIG_I855_VIDEO_MB_8MB 0
#define CONFIG_UART5_IRQ4 0
#define CONFIG_PARALLEL_CPU_INIT 0
#define CONFIG_VENDOR_CUBIETECH 0
#define CONFIG_FRAMEBUFFER_VESA_MODE_108 0
#define CONFIG_VENDOR_SAMSUNG 0
#define CONFIG_EARLY_PCI_BRIDGE 0
#define CONFIG_BOARD_ASUS_A8N_E 0
#define CONFIG_IOAPIC_INTERRUPTS_ON_APIC_SERIAL_BUS 0
#define CONFIG_BOARD_AAEON_PFM_540I_REVB 0
#define CONFIG_SOUTHBRIDGE_NVIDIA_CK804 0
#define CONFIG_DEFAULT_CONSOLE_LOGLEVEL_5 0
#define CONFIG_BOARD_BACHMANN_OT200 0
#define CONFIG_DRIVERS_ATI_RAGEXL 0
#define CONFIG_HAVE_ACPI_SLIC 0
#define CONFIG_COREBOOT_ROMSIZE_KB_512 0
#define CONFIG_NORTHBRIDGE_RDC_R8610 0
#define CONFIG_POST_DEVICE_NONE 0
#define CONFIG_LPT_MODE_ECP 0
#define CONFIG_CHROMEOS_RAMOOPS_RAM_START 0
#define CONFIG_CBFS_HEADER_ROM_OFFSET 0
#define CONFIG_EXT_RT_TBL_SUPPORT 0
#define CONFIG_QRANK_DIMM_SUPPORT 0
#define CONFIG_BOARD_SAMSUNG_STUMPY 0
#define CONFIG_SET_FIDVID_STORE_AP_APICID_AT_FIRST 0
#define CONFIG_EC_GOOGLE_CHROMEEC 0
#define CONFIG_SPI_FLASH_WINBOND 1
#define CONFIG_LPT_MODE_EPP_17_AND_SPP 0
#define CONFIG_CONSOLE_CBMEM_BUFFER_SIZE 0
#define CONFIG_PCI_64BIT_PREF_MEM 0
#define CONFIG_PCIX_PLUGIN_SUPPORT 1
#define CONFIG_SUPERIO_WINBOND_W83627EHG 0
# 5 "src/include/kconfig.h" 2

/*
 * Getting something that works in C and CPP for an arg that may or may
 * not be defined is tricky.  Here, if we have "#define CONFIG_BOOGER 1"
 * we match on the placeholder define, insert the "0," for arg1 and generate
 * the triplet (0, 1, 0).  Then the last step cherry picks the 2nd arg (a one).
 * When CONFIG_BOOGER is not defined, we generate a (... 1, 0) pair, and when
 * the last step cherry picks the 2nd arg, we get a zero.
 */
#define __ARG_PLACEHOLDER_1 0,
#define config_enabled(cfg) _config_enabled(cfg)
#define _config_enabled(value) __config_enabled(__ARG_PLACEHOLDER_##value)
#define __config_enabled(arg1_or_junk) ___config_enabled(arg1_or_junk 1, 0, 0)
#define ___config_enabled(__ignored, val, ...) val

#define IS_ENABLED(option) config_enabled(option)
#endif
# 22 "src/include/kconfig.h"
# 1 "<built-in>" 2
# 1 "<built-in>"
# 1 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
/* $NoKeywords:$ */
/**
 * @file
 *
 * AMD Library
 *
 * Contains interface to the AMD AGESA library
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Lib
 * @e \$Revision: 44325 $   @e \$Date: 2010-12-22 03:29:53 -0700 (Wed, 22 Dec 2010) $
 *
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of
 *       its contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***************************************************************************
 *
 */


/*----------------------------------------------------------------------------------------
 *                             M O D U L E S    U S E D
 *----------------------------------------------------------------------------------------
 */

#if 0 /* expanded by -frewrite-includes */
#include "AGESA.h"
#endif /* expanded by -frewrite-includes */
# 53 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
# 1 "src/vendorcode/amd/agesa/f14/AGESA.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * Agesa structures and definitions
 *
 * Contains AMD AGESA core interface
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Include
 * @e \$Revision: 47417 $   @e \$Date: 2011-02-18 12:48:20 -0700 (Fri, 18 Feb 2011) $
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */


#ifndef _AGESA_H_
#define _AGESA_H_

#if 0 /* expanded by -frewrite-includes */
#include  "Porting.h"
#endif /* expanded by -frewrite-includes */
# 50 "src/vendorcode/amd/agesa/f14/AGESA.h"
# 1 "src/vendorcode/amd/agesa/f14/Porting.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * Describes compiler dependencies - to support several compile time environments
 *
 * Contains compiler environment porting descriptions
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Includes
 * @e \$Revision: 36567 $   @e \$Date: 2010-08-21 02:35:15 +0800 (Sat, 21 Aug 2010) $
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */

#ifndef _PORTING_H_
#define _PORTING_H_

#if defined (_MSC_VER)
  #if 0 /* expanded by -frewrite-includes */
#include <intrin.h>
#endif /* expanded by -frewrite-includes */
# 50 "src/vendorcode/amd/agesa/f14/Porting.h"
# 51 "src/vendorcode/amd/agesa/f14/Porting.h"
  void _disable (void);
  void _enable (void);
  #pragma warning(disable: 4103 4001 4733)
  #pragma intrinsic (_disable, _enable)
  #pragma warning(push)
  // -----------------------------------------------------------------------
  //   Define a code_seg MACRO
  //
  #define MAKE_AS_A_STRING(arg) #arg

  #define CODE_GROUP(arg) __pragma (code_seg (MAKE_AS_A_STRING (.t##arg)))

  #define RDATA_GROUP(arg) __pragma (const_seg (MAKE_AS_A_STRING (.d##arg)))
  #define FUNC_ATTRIBUTE(arg) __declspec(arg)
  //#include <intrin.h>  // MS has built-in functions

  #if _MSC_VER < 900
    // -----------------------------------------------------------------------
    //    Assume MSVC 1.52C (16-bit)
    //
    //    NOTE: When using MSVC 1.52C use the following command line:
    //
    //       CL.EXE /G3 /AL /O1i /Fa <FILENAME.C>
    //
    //    This will produce 32-bit code in USE16 segment that is optimized for code
    //    size.
    typedef void          VOID;

    // Create the universal 32, 16, and 8-bit data types
    typedef unsigned long   UINTN;
    typedef          long   INT32;
    typedef unsigned long   UINT32;
    typedef          int    INT16;
    typedef unsigned int    UINT16;
    typedef          char   INT8;
    typedef unsigned char   UINT8;
    typedef          char   CHAR8;
    typedef unsigned short  CHAR16;

    /// struct for 16-bit environment handling of 64-bit value
    typedef struct _UINT64 {
      IN OUT  UINT32 lo;      ///< lower 32-bits of 64-bit value
      IN OUT  UINT32 hi;      ///< highest 32-bits of 64-bit value
    } UINT64;

    // Create the Boolean type
    #define TRUE  1
    #define FALSE 0
    typedef unsigned char BOOLEAN;

    #define CONST const
    #define STATIC static
    #define VOLATILE volatile
    #define CALLCONV __pascal
    #define ROMDATA __based( __segname( "_CODE" ) )
    #define _16BYTE_ALIGN   __declspec(align(16))

    // Force tight packing of structures
    // Note: Entire AGESA (Project / Solution) will be using pragma pack 1
    #pragma warning( disable : 4103 ) // Disable '#pragma pack' in .h warning
    #pragma pack(1)

    //   Disable WORD->BYTE automatic conversion warnings.  Example:
    //   BYTE LocalByte;
    //   void MyFunc(BYTE val);
    //
    //   MyFunc(LocalByte*2+1); // Warning, automatic conversion
    //
    //   The problem is any time math is performed on a BYTE, it is converted to a
    //   WORD by MSVC 1.52c, and then when it is converted back to a BYTE, a warning
    //   is generated.  Disable warning C4761
    #pragma warning( disable : 4761 )

  #else
# 125 "src/vendorcode/amd/agesa/f14/Porting.h"
    // -----------------------------------------------------------------------
    //   Assume a 32-bit MSVC++
    //
    // Disable the following warnings:
    // 4100 - 'identifier' : unreferenced formal parameter
    // 4276 - 'function' : no prototype provided; assumed no parameters
    // 4214 - non standard extension used : bit field types other than int
    // 4001 - nonstandard extension 'single line comment' was used
    // 4142 - benign redefinition of type for following declaration
    //      - typedef char    INT8
    #if defined (_M_IX86)
      #pragma warning (disable: 4100 4276 4214 4001 4142 4305 4306)

      #ifndef VOID
        typedef void VOID;
      #endif
# 141 "src/vendorcode/amd/agesa/f14/Porting.h"
    // Create the universal 32, 16, and 8-bit data types
      #ifndef UINTN
        typedef unsigned __w64 UINTN;
      #endif
# 145 "src/vendorcode/amd/agesa/f14/Porting.h"
      typedef          __int64 INT64;
      typedef unsigned __int64 UINT64;
      typedef          int   INT32;
      typedef unsigned int   UINT32;
      typedef          short INT16;
      typedef unsigned short UINT16;
      typedef          char  INT8;
      typedef unsigned char  UINT8;
      typedef          char  CHAR8;
      typedef unsigned short CHAR16;

    // Create the Boolean type
      #ifndef TRUE
        #define TRUE  1
      #endif
# 160 "src/vendorcode/amd/agesa/f14/Porting.h"
      #ifndef FALSE
        #define FALSE 0
      #endif
# 163 "src/vendorcode/amd/agesa/f14/Porting.h"
      typedef unsigned char BOOLEAN;

      // Force tight packing of structures
      // Note: Entire AGESA (Project / Solution) will be using pragma pack 1
      #pragma pack(1)

      #define CONST const
      #define STATIC static
      #define VOLATILE volatile
      #define CALLCONV
      #define ROMDATA
      #define _16BYTE_ALIGN __declspec(align(64))
      // 64 bit of compiler
    #else
# 177 "src/vendorcode/amd/agesa/f14/Porting.h"
      #pragma warning (disable: 4100 4276 4214 4001 4142 4305 4306 4366)

      #ifndef VOID
        typedef void VOID;
      #endif
# 182 "src/vendorcode/amd/agesa/f14/Porting.h"
      // Create the universal 32, 16, and 8-bit data types
      #ifndef UINTN
        typedef unsigned __int64 UINTN;
      #endif
# 186 "src/vendorcode/amd/agesa/f14/Porting.h"
      typedef          __int64 INT64;
      typedef unsigned __int64 UINT64;
      typedef          int   INT32;
      typedef unsigned int   UINT32;
      typedef          short INT16;
      typedef unsigned short UINT16;
      typedef          char  INT8;
      typedef unsigned char  UINT8;
      typedef          char  CHAR8;
      typedef unsigned short CHAR16;

      // Create the Boolean type
      #ifndef TRUE
        #define TRUE  1
      #endif
# 201 "src/vendorcode/amd/agesa/f14/Porting.h"
      #ifndef FALSE
        #define FALSE 0
      #endif
# 204 "src/vendorcode/amd/agesa/f14/Porting.h"
      typedef unsigned char BOOLEAN;

      // Force tight packing of structures
      // Note: Entire AGESA (Project / Solution) will be using pragma pack 1
      #pragma pack(1)

      #define CONST const
      #define STATIC static
      #define VOLATILE volatile
      #define CALLCONV
      #define ROMDATA
    #endif
# 216 "src/vendorcode/amd/agesa/f14/Porting.h"
  #endif
# 217 "src/vendorcode/amd/agesa/f14/Porting.h"
  // -----------------------------------------------------------------------
  // End of MS compiler versions


#elif defined __GNUC__
# 222 "src/vendorcode/amd/agesa/f14/Porting.h"

  #define IN
  #define OUT
  #define STATIC static
  #define VOLATILE volatile
  #define TRUE 1
  #define FALSE 0
//  #undef CONST
  #define CONST const
  #define ROMDATA
  #define CALLCONV
  #define _16BYTE_ALIGN __attribute__ ((aligned (16)))

  typedef unsigned char  BOOLEAN;
  typedef   signed char  INT8;
  typedef   signed short INT16;
  typedef   signed long  INT32;
  typedef unsigned char  CHAR8;
  typedef unsigned char  UINT8;
  typedef unsigned short UINT16;
  typedef unsigned long  UINT32;
  typedef unsigned long  UINTN;
  typedef unsigned long  long UINT64;
  typedef void VOID;
  //typedef unsigned long  size_t;
//typedef unsigned int   uintptr_t; 
// Force tight packing of structures
// Note: Entire AGESA (Project / Solution) will be using pragma pack 1
#pragma pack(1)
      
#define CODE_GROUP(arg)
#define RDATA_GROUP(arg)

#define FUNC_ATTRIBUTE(arg) __attribute__((arg)) 
#define MAKE_AS_A_STRING(arg) #arg
                                 
// -----------------------------------------------------------------------
// Common definitions for all compilers
//
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 261 "src/vendorcode/amd/agesa/f14/Porting.h"
# 1 "src/include/stddef.h" 1
#ifndef STDDEF_H
#define STDDEF_H

typedef long ptrdiff_t;
#ifndef __SIZE_TYPE__
#define __SIZE_TYPE__ unsigned long
#endif
# 8 "src/include/stddef.h"
typedef __SIZE_TYPE__ size_t;
/* There is a GCC macro for a size_t type, but not
 * for a ssize_t type. Below construct tricks GCC
 * into making __SIZE_TYPE__ signed.
 */
#define unsigned signed
typedef __SIZE_TYPE__ ssize_t;
#undef unsigned

typedef int wchar_t;
typedef unsigned int wint_t;

#define NULL ((void *)0)

/* Standard units. */
#define KiB (1<<10)
#define MiB (1<<20)
#define GiB (1<<30)
/* Could we ever run into this one? I hope we get this much memory! */
#define TiB (1<<40)

#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)

#ifdef __PRE_RAM__
#define ROMSTAGE_CONST const
#else
# 34 "src/include/stddef.h"
#define ROMSTAGE_CONST
#endif
# 36 "src/include/stddef.h"

#endif /* STDDEF_H */
# 38 "src/include/stddef.h"
# 262 "src/vendorcode/amd/agesa/f14/Porting.h" 2
#if 0 /* expanded by -frewrite-includes */
#include "gcc-intrin.h"
#endif /* expanded by -frewrite-includes */
# 262 "src/vendorcode/amd/agesa/f14/Porting.h"
# 1 "src/vendorcode/amd/agesa/f14/Include/gcc-intrin.h" 1
/*
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
 
#if defined (__GNUC__)

/* I/O intrin functions.  */
static __inline__ __attribute__((always_inline)) unsigned char __inbyte(unsigned short Port)
{
  unsigned char value;

  __asm__ __volatile__ (
    "in  %%dx, %%al"
    : "=a" (value)
    : "d" (Port)
    );

  return value;
}

static __inline__ __attribute__((always_inline)) unsigned short __inword(unsigned short Port)
{
  unsigned short value;

  __asm__ __volatile__ (
    "in  %%dx, %%ax"
    : "=a" (value)
    : "d" (Port)
    );

  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long __indword(unsigned short Port)
{
  unsigned long value;
    
  __asm__ __volatile__ (
    "in  %%dx, %%eax"
    : "=a" (value)
    : "d" (Port)
    );
  return value;

}

static __inline__ __attribute__((always_inline)) void __outbyte(unsigned short Port,unsigned char Data)
{
  __asm__ __volatile__ (
    "out  %%al, %%dx"
    :
    : "a" (Data), "d" (Port)
    );
}

static __inline__ __attribute__((always_inline)) void __outword(unsigned short Port,unsigned short Data)
{
  __asm__ __volatile__ (
    "out  %%ax, %%dx"
    :
    : "a" (Data), "d" (Port)
    );
}

static __inline__ __attribute__((always_inline)) void __outdword(unsigned short Port,unsigned long Data)
{
  __asm__ __volatile__ (
    "out  %%eax, %%dx"
    :
    : "a" (Data), "d" (Port)
    );
}

static __inline__ __attribute__((always_inline)) void __inbytestring(unsigned short Port,unsigned char *Buffer,unsigned long Count)
{
  __asm__ __volatile__ (
    "cld ; rep ; insb " 
    : "=D" (Buffer), "=c" (Count)
    : "d"(Port), "0"(Buffer), "1" (Count)
    );
}

static __inline__ __attribute__((always_inline)) void __inwordstring(unsigned short Port,unsigned short *Buffer,unsigned long Count)
{
  __asm__ __volatile__ (
    "cld ; rep ; insw " 
    : "=D" (Buffer), "=c" (Count)
    : "d"(Port), "0"(Buffer), "1" (Count)
    );
}

static __inline__ __attribute__((always_inline)) void __indwordstring(unsigned short Port,unsigned long *Buffer,unsigned long Count)
{
  __asm__ __volatile__ (
    "cld ; rep ; insl " 
    : "=D" (Buffer), "=c" (Count)
    : "d"(Port), "0"(Buffer), "1" (Count)
    );
}

static __inline__ __attribute__((always_inline)) void __outbytestring(unsigned short Port,unsigned char *Buffer,unsigned long Count)
{
  __asm__ __volatile__ (
    "cld ; rep ; outsb " 
    : "=S" (Buffer), "=c" (Count)
    : "d"(Port), "0"(Buffer), "1" (Count)
    );
}

static __inline__ __attribute__((always_inline)) void __outwordstring(unsigned short Port,unsigned short *Buffer,unsigned long Count)
{
  __asm__ __volatile__ (
    "cld ; rep ; outsw " 
    : "=S" (Buffer), "=c" (Count)
    : "d"(Port), "0"(Buffer), "1" (Count)
  );
}

static __inline__ __attribute__((always_inline)) void __outdwordstring(unsigned short Port,unsigned long *Buffer,unsigned long Count)
{
  __asm__ __volatile__ (
   "cld ; rep ; outsl " 
   : "=S" (Buffer), "=c" (Count)
   : "d"(Port), "0"(Buffer), "1" (Count)
   );
}

static __inline__ __attribute__((always_inline)) unsigned long __readdr0(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%dr0, %[value]" 
    : [value] "=a" (value)
    );
  return value;
}
 
static __inline__ __attribute__((always_inline)) unsigned long __readdr1(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%dr1, %[value]" 
    : [value] "=a" (value)
    );
  return value;
}
 
static __inline__ __attribute__((always_inline)) unsigned long __readdr2(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%dr2, %[value]" 
    : [value] "=a" (value)
    );
  return value;
}
 
static __inline__ __attribute__((always_inline)) unsigned long __readdr3(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%dr3, %[value]" 
    : [value] "=a" (value)
    );
  return value;
}
 
static __inline__ __attribute__((always_inline)) unsigned long __readdr7(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%dr7, %[value]" 
    : [value] "=a" (value)
    );
  return value;
}
 
static __inline__ __attribute__((always_inline)) unsigned long __readdr(unsigned long reg)
{
  switch (reg){
    case 0:
      return __readdr0 ();
      break;

    case 1:
      return __readdr1 ();
      break;

    case 2:
      return __readdr2 ();
      break;

    case 3:
      return __readdr3 ();
      break;

    case 7:
      return __readdr7 ();
      break;

    default:
      return -1;
  }      
}
 
static __inline__ __attribute__((always_inline)) void __writedr0(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%dr0"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writedr1(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%dr1"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writedr2(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%dr2"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writedr3(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%dr3"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writedr7(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%dr7"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writedr(unsigned long reg, unsigned long Data)
{
  switch (reg){
    case 0:
      __writedr0 (Data);
      break;

    case 1:
      __writedr1 (Data);
      break;

    case 2:
      __writedr2 (Data);
      break;

    case 3:
      __writedr3 (Data);
      break;

    case 7:
      __writedr7 (Data);
      break;

    default:
      ;
  } 
}
 
static __inline__ __attribute__((always_inline)) unsigned long __readcr0(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%cr0, %[value]" 
    : [value] "=a" (value)
    :
    : "memory");
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long __readcr2(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%cr2, %[value]" 
    : [value] "=a" (value));
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long __readcr3(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%cr3, %[value]" 
    : [value] "=a" (value));
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long __readcr4(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%cr4, %[value]" 
    : [value] "=a" (value));
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long __readcr8(void)
{
  unsigned long value;
  __asm__ __volatile__ (
    "mov %%cr8, %[value]" 
    : [value] "=a" (value));
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long __readcr(unsigned long reg)
{
  switch (reg){
    case 0:
      return __readcr0 ();
      break;

    case 2:
      return __readcr2 ();
      break;

    case 3:
      return __readcr3 ();
      break;

    case 4:
      return __readcr4 ();
      break;

    case 8:
      return __readcr8 ();
      break;

    default:
      return -1;
  }      
}

static __inline__ __attribute__((always_inline)) void __writecr0(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%cr0"
    : 
    : "a" (Data)
    : "memory"
    );
}
 
static __inline__ __attribute__((always_inline)) void __writecr2(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%cr2"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writecr3(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%cr3"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writecr4(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%cr4"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writecr8(unsigned long Data)
{
  __asm__ __volatile__ (
    "mov %%eax, %%cr8"
    : 
    : "a" (Data)
    );
}
 
static __inline__ __attribute__((always_inline)) void __writecr(unsigned long reg, unsigned long Data)
{
  switch (reg){
    case 0:
      __writecr0 (Data);
      break;

    case 2:
      __writecr2 (Data);
      break;

    case 3:
      __writecr3 (Data);
      break;

    case 4:
      __writecr4 (Data);
      break;

    case 8:
      __writecr8 (Data);
      break;

    default:
      ;
  } 
}

static __inline__ __attribute__((always_inline)) UINT64 __readmsr(UINT32 msr)
{
  UINT64 retval;
  __asm__ __volatile__(
       "rdmsr\n\t"
       : "=A" (retval)
       : "c" (msr)
       );
   return retval;
}

static __inline__ __attribute__((always_inline)) void __writemsr (UINT32 msr, UINT64 Value)
{
  __asm__ __volatile__ (
     "wrmsr\n\t"
     :
     : "c" (msr), "A" (Value)
     );
}
 
static __inline__ __attribute__((always_inline)) UINT64 __rdtsc(void)
{
  UINT64 retval;
  __asm__ __volatile__ (
     "rdtsc" 
     : "=A" (retval));
  return retval;
}

static __inline__ __attribute__((always_inline)) void __cpuid(int CPUInfo[], const int InfoType)
{
   __asm__ __volatile__(
     "cpuid" 
     :"=a" (CPUInfo[0]), "=b" (CPUInfo[1]), "=c" (CPUInfo[2]), "=d" (CPUInfo[3]) 
     : "a" (InfoType)
     );
}


static __inline__ __attribute__((always_inline)) void _disable(void)
{
  __asm__ __volatile__ ("cli");
}


static __inline__ __attribute__((always_inline)) void _enable(void)
{
  __asm__ __volatile__ ("sti");
}


static __inline__ __attribute__((always_inline)) void __halt(void)
{
  __asm__ __volatile__ ("hlt");
}


static __inline__ __attribute__((always_inline)) void __debugbreak(void)
{
  __asm__ __volatile__ ("int3");
}

static __inline__ __attribute__((always_inline)) void __invd(void)
{
  __asm__ __volatile__ ("invd");
}

static __inline__ __attribute__((always_inline)) void __wbinvd(void)
{
  __asm__ __volatile__ ("wbinvd");
}

static __inline__ __attribute__((always_inline)) void __lidt(void *Source)
{
  __asm__ __volatile__("lidt %0" : : "m"(*(short*)Source));
}

static __inline__ __attribute__((always_inline)) void __writefsbyte(const unsigned long Offset, const unsigned char Data)
{
  __asm__("movb %b[Data], %%fs:%a[Offset]" : : [Offset] "ir" (Offset), [Data] "iq" (Data));
}

static __inline__ __attribute__((always_inline)) void __writefsword(const unsigned long Offset, const unsigned short Data)
{
  __asm__("movw %w[Data], %%fs:%a[Offset]" : : [Offset] "ir" (Offset), [Data] "iq" (Data));
}

static __inline__ __attribute__((always_inline)) void __writefsdword(const unsigned long Offset, const unsigned long Data)
{
  __asm__("movl %k[Data], %%fs:%a[Offset]" : : [Offset] "ir" (Offset), [Data] "iq" (Data));
}

static __inline__ __attribute__((always_inline)) unsigned char __readfsbyte(const unsigned long Offset)
{
  unsigned char value;
  __asm__("movb %%fs:%a[Offset], %b[value]" : [value] "=q" (value) : [Offset] "irm" (Offset));
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned short __readfsword(const unsigned long Offset)
{
  unsigned short value;
  __asm__("movw %%fs:%a[Offset], %w[value]" : [value] "=q" (value) : [Offset] "irm" (Offset));
  return value;
}

static __inline__ __attribute__((always_inline)) unsigned long long __readfsdword(unsigned long long Offset)
{
  unsigned long long value;
  __asm__("movl %%fs:%a[Offset], %k[value]" : [value] "=q" (value) : [Offset] "irm" (Offset));
  return value;
}

#ifdef __SSE3__
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));

static __inline__ __attribute__((always_inline)) void _mm_stream_si128_fs2 (void *__A, __m128i __B)
{
  __asm__(".byte 0x64"); // fs prefix
  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);
}

static __inline__ __attribute__((always_inline)) void _mm_stream_si128_fs (void *__A, void *__B)
{
  __m128i data;
  data = (__m128i) __builtin_ia32_lddqu ((char const *)__B);
  _mm_stream_si128_fs2 (__A, data);
}

static __inline__ __attribute__((always_inline)) void _mm_clflush_fs (void *__A)
{
  __asm__(".byte 0x64"); // fs prefix
  __builtin_ia32_clflush (__A);
}

static __inline __attribute__(( __always_inline__)) void _mm_mfence (void)
{
  __builtin_ia32_mfence ();
}

static __inline __attribute__(( __always_inline__)) void _mm_sfence (void)
{
  __builtin_ia32_sfence ();
}
#endif
# 598 "src/vendorcode/amd/agesa/f14/Include/gcc-intrin.h"

static __inline__ __attribute__((always_inline)) void __stosb(unsigned char *dest, unsigned char data, size_t count)
{
   __asm__ __volatile__ (
    "cld ; rep ; stosb "
    : "=D" (dest), "=c" (count)
    : "a"(data), "0"(dest), "1" (count)
  );
}

static __inline__ __attribute__((always_inline)) void __movsb(unsigned char *dest, unsigned char *data, size_t count)
{
   __asm__ __volatile__ (
    "cld ; rep ; movsb "
    : "=D" (dest), "=S"(data), "=c" (count)
    : "S"(data), "0"(dest), "1" (count)
  );
}

static __inline__ __attribute__((always_inline)) 
void debug_point ( unsigned short Port,  unsigned long Data )
{
   __outdword (Port, Data);     
   __asm__ __volatile__ (".word 0xfeeb");

}

static __inline__ __attribute__((always_inline)) 
void delay_point ( unsigned short Port, unsigned long Data, unsigned long delayTime )
{
  UINTN  Index;
  Index = 0;
  __outdword (Port, Data);
  while (Index < delayTime * 600000) {
    __outdword (0xE0, 0);
    Index ++;
  }
}
#endif // defined (__GNUC__)
# 637 "src/vendorcode/amd/agesa/f14/Include/gcc-intrin.h"
# 263 "src/vendorcode/amd/agesa/f14/Porting.h" 2

#if 0 /* expanded by -frewrite-includes */
#include <assert.h>
#endif /* expanded by -frewrite-includes */
# 264 "src/vendorcode/amd/agesa/f14/Porting.h"
# 1 "src/include/assert.h" 1
/*
 * This file is part of the coreboot project.
 *
 * Copyright (C) 2010 coresystems GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef __ASSERT_H__
#define __ASSERT_H__

#if defined(__PRE_RAM__) && !CONFIG_CACHE_AS_RAM

/* ROMCC versions */
#define ASSERT(x) {						\
	if(!(x)) {						\
		print_emerg("ASSERTION FAILED: file '");	\
		print_emerg(__FILE__);				\
		print_emerg("', line 0x");			\
		print_debug_hex32(__LINE__);			\
		print_emerg("\n");				\
		/* die(""); */					\
	}							\
}

#define BUG() {							\
	print_emerg("BUG ENCOUNTERED: SYSTEM HALTED at file '");\
	print_emerg(__FILE__);					\
	print_emerg("', line 0x");				\
	print_debug_hex32(__LINE__);				\
	print_emerg("\n");					\
	/* die(""); */						\
}

#else
# 47 "src/include/assert.h"

/* GCC and CAR versions */
#define ASSERT(x) {						\
	if (!(x)) {						\
		printk(BIOS_EMERG, "ASSERTION FAILED: file '%s', "	\
			" line %d\n", __FILE__, __LINE__);	\
		/* die(""); */					\
	}							\
}
#define BUG() {							\
	printk(BIOS_EMERG, "BUG ENCOUNTERED: SYSTEM HALTED at file '%s', "	\
		" line %d\n", __FILE__, __LINE__);		\
	/* die(""); */						\
}

#endif
# 63 "src/include/assert.h"

#endif // __ASSERT_H__
# 65 "src/include/assert.h"
# 265 "src/vendorcode/amd/agesa/f14/Porting.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <console/console.h>
#endif /* expanded by -frewrite-includes */
# 265 "src/vendorcode/amd/agesa/f14/Porting.h"
# 1 "src/include/console/console.h" 1
/*
 * This file is part of the coreboot project.
 *
 * Copyright (C) 2003 Eric Biederman
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef CONSOLE_CONSOLE_H_
#define CONSOLE_CONSOLE_H_

#if 0 /* expanded by -frewrite-includes */
#include <stdint.h>
#endif /* expanded by -frewrite-includes */
# 23 "src/include/console/console.h"
# 1 "src/arch/x86/include/stdint.h" 1
#ifndef I386_STDINT_H
#define I386_STDINT_H

#if defined(__GNUC__)
#define __HAVE_LONG_LONG__ 1
#else
# 7 "src/arch/x86/include/stdint.h"
#define __HAVE_LONG_LONG__ 0
#endif
# 9 "src/arch/x86/include/stdint.h"

/* Exact integral types */
typedef unsigned char      uint8_t;
typedef signed char        int8_t;

typedef unsigned short     uint16_t;
typedef signed short       int16_t;

typedef unsigned int       uint32_t;
typedef signed int         int32_t;

#if __HAVE_LONG_LONG__
typedef unsigned long long uint64_t;
typedef signed long long   int64_t;
#endif
# 24 "src/arch/x86/include/stdint.h"

/* Small types */
typedef unsigned char      uint_least8_t;
typedef signed char        int_least8_t;

typedef unsigned short     uint_least16_t;
typedef signed short       int_least16_t;

typedef unsigned int       uint_least32_t;
typedef signed int         int_least32_t;

#if __HAVE_LONG_LONG__
typedef unsigned long long uint_least64_t;
typedef signed long long   int_least64_t;
#endif
# 39 "src/arch/x86/include/stdint.h"

/* Fast Types */
typedef unsigned char      uint_fast8_t;
typedef signed char        int_fast8_t;

typedef unsigned int       uint_fast16_t;
typedef signed int         int_fast16_t;

typedef unsigned int       uint_fast32_t;
typedef signed int         int_fast32_t;

#if __HAVE_LONG_LONG__
typedef unsigned long long uint_fast64_t;
typedef signed long long   int_fast64_t;
#endif
# 54 "src/arch/x86/include/stdint.h"

/* Types for `void *' pointers.  */
typedef int                intptr_t;
typedef unsigned int       uintptr_t;

/* Largest integral types */
#if __HAVE_LONG_LONG__
typedef long long int      intmax_t;
typedef unsigned long long uintmax_t;
#else
# 64 "src/arch/x86/include/stdint.h"
typedef long int           intmax_t;
typedef unsigned long int  uintmax_t;
#endif
# 67 "src/arch/x86/include/stdint.h"

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
#if __HAVE_LONG_LONG__
typedef uint64_t u64;
#endif
# 74 "src/arch/x86/include/stdint.h"
typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;


#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif
# 82 "src/arch/x86/include/stdint.h"
#ifndef UINT64_MAX
# define UINT64_MAX (18446744073709551615ULL)
#endif
# 85 "src/arch/x86/include/stdint.h"
#ifndef UINT64_C
#define UINT64_C(c) c ## ULL
#endif
# 88 "src/arch/x86/include/stdint.h"
#ifndef PRIu64
#define PRIu64 "llu"
#endif
# 91 "src/arch/x86/include/stdint.h"


#undef __HAVE_LONG_LONG__

#endif /* I386_STDINT_H */
# 96 "src/arch/x86/include/stdint.h"
# 24 "src/include/console/console.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <rules.h>
#endif /* expanded by -frewrite-includes */
# 24 "src/include/console/console.h"
# 1 "src/include/rules.h" 1
/*
 * This file is part of the coreboot project.
 *
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef _RULES_H
#define _RULES_H

/* Useful helpers to tell whether the code is executing in bootblock,
 * romstage, ramstage or SMM.
 */

#if defined(__BOOT_BLOCK__)
#define ENV_BOOTBLOCK 1
#define ENV_ROMSTAGE 0
#define ENV_RAMSTAGE 0
#define ENV_SMM 0

#elif defined(__PRE_RAM__)
# 33 "src/include/rules.h"
#define ENV_BOOTBLOCK 0
#define ENV_ROMSTAGE 1
#define ENV_RAMSTAGE 0
#define ENV_SMM 0

#elif defined(__SMM__)
# 39 "src/include/rules.h"
#define ENV_BOOTBLOCK 0
#define ENV_ROMSTAGE 0
#define ENV_RAMSTAGE 0
#define ENV_SMM 1
#else
# 44 "src/include/rules.h"

#define ENV_BOOTBLOCK 0
#define ENV_ROMSTAGE 0
#define ENV_RAMSTAGE 1
#define ENV_SMM 0
#endif
# 50 "src/include/rules.h"

/* For romstage and ramstage always build with simple device model, ie.
 * PCI, PNP and CPU functions operate without use of devicetree.
 *
 * For ramstage individual source file may define __SIMPLE_DEVICE__
 * before including any header files to force that particular source
 * be built with simple device model.
 */

#if defined(__PRE_RAM__) || defined(__SMM__)
#define __SIMPLE_DEVICE__
#endif
# 62 "src/include/rules.h"

#endif /* _RULES_H */
# 64 "src/include/rules.h"
# 25 "src/include/console/console.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <console/post_codes.h>
#endif /* expanded by -frewrite-includes */
# 25 "src/include/console/console.h"
# 1 "src/include/console/post_codes.h" 1
/*
 * This file is part of the coreboot project.
 *
 * Copyright (C) 2011  Alexandru Gagniuc <mr.nuke.me@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

/**
 * @file post_codes.h
 *
 * This aims to be a central point for POST codes used throughout coreboot.
 * All POST codes should be declared here as macros, and post_code() should
 * be used with the macros instead of hardcoded values. This allows us to
 * quickly reference POST codes when nothing is working
 *
 * The format for a POST code macro is
 * #define POST_WHAT_WE_COMMUNICATE_IS_HAPPENING_WHEN_THIS_CODE_IS_POSTED
 * Lets's keep it at POST_* instead of POST_CODE_*
 *
 * This file is also included by early assembly files. Only use #define s;
 * no function prototypes allowed here
 *
 * DOCUMENTATION:
 * Please document any and all post codes using Doxygen style comments. We
 * want to be able to generate a verbose enough documentation that is useful
 * during debugging. Failure to do so will result in your patch being rejected
 * without any explanation or effort on part of the maintainers.
 *
 */
#ifndef POST_CODES_H
#define POST_CODES_H

/**
 * \brief  Entry into 'crt0.s'. reset code jumps to here
 *
 * First instruction that gets executed after the reset vector jumps.
 * This indicates that the reset vector points to the correct code segment.
 */
#define POST_RESET_VECTOR_CORRECT		0x01

/**
 * \brief Entry into protected mode
 *
 * Preparing to enter protected mode. This is POSTed right before changing to
 * protected mode.
 */
#define POST_ENTER_PROTECTED_MODE		0x10

/**
 * \brief Start copying coreboot to RAM with decompression if compressed
 *
 * POSTed before ramstage is about to be loaded into memory
 */
#define POST_PREPARE_RAMSTAGE 			0x11

/**
 * \brief Copy/decompression finished; jumping to RAM
 *
 * This is called after ramstage is loaded in memory, and before
 * the code jumps there. This represents the end of romstage.
 */
#define POST_RAMSTAGE_IS_PREPARED		0x12


/**
 * \brief Entry into c_start
 *
 * c_start.S is the first code executing in ramstage.
 */
#define POST_ENTRY_C_START			0x13

/**
 * \brief Pre call to ram stage main()
 *
 * POSTed right before ram stage main() is called from c_start.S
 */
#define POST_PRE_HARDWAREMAIN			0x79

/**
 * \brief Entry into coreboot in ram stage main()
 *
 * This is the first call in hardwaremain.c. If this code is POSTed, then
 * ramstage has successfully loaded and started executing.
 */
#define POST_ENTRY_RAMSTAGE			0x80

/**
 * \brief Console is initialized
 *
 * The console is initialized and is ready for usage
 */
#define POST_CONSOLE_READY			0x39

/**
 * \brief Console boot message succeeded
 *
 * First console message has been successfully sent through the console backend
 * driver.
 */
#define POST_CONSOLE_BOOT_MSG			0x40

/**
 * \brief Before enabling the cache
 *
 * Going to enable the cache
 */
#define POST_ENABLING_CACHE			0x60

/**
 * \brief Before Device Probe
 *
 * Boot State Machine: bs_pre_device()
 */
#define POST_BS_PRE_DEVICE			0x70

/**
 * \brief Initializing Chips
 *
 * Boot State Machine: bs_dev_init_chips()
 */
#define POST_BS_DEV_INIT_CHIPS			0x71

/**
 * \brief Starting Device Enumeration
 *
 * Boot State Machine: bs_dev_enumerate()
 */
#define POST_BS_DEV_ENUMERATE			0x72

/**
 * \brief Device Resource Allocatio
 *
 * Boot State Machine: bs_dev_resources()
 */
#define POST_BS_DEV_RESOURCES			0x73

/**
 * \brief Device Enable
 *
 * Boot State Machine: bs_dev_enable()
 */
#define POST_BS_DEV_ENABLE			0x74

/**
 * \brief Device Initialization
 *
 * Boot State Machine: bs_dev_init()
 */
#define POST_BS_DEV_INIT			0x75

/**
 * \brief After Device Probe
 *
 * Boot State Machine: bs_post_device()
 */
#define POST_BS_POST_DEVICE			0x76

/**
 * \brief OS Resume Check
 *
 * Boot State Machine: bs_os_resume_check()
 */
#define POST_BS_OS_RESUME_CHECK			0x77

/**
 * \brief OS Resume
 *
 * Boot State Machine: bs_os_resume()
 */
#define POST_BS_OS_RESUME			0x78

/**
 * \brief Write Tables
 *
 * Boot State Machine: bs_write_tables()
 */
#define POST_BS_WRITE_TABLES			0x79

/**
 * \brief Load Payload
 *
 * Boot State Machine: bs_payload_load()
 */
#define POST_BS_PAYLOAD_LOAD			0x7a

/**
 * \brief Boot Payload
 *
 * Boot State Machine: bs_payload_boot()
 */
#define POST_BS_PAYLOAD_BOOT			0x7b

/**
 * \brief Entry into elf boot
 *
 * This POST code is called right before invoking jmp_to_elf_entry()
 * jmp_to_elf_entry() invokes the payload, and should never return
 */
#define POST_ENTER_ELF_BOOT			0xf8

/**
 * \brief Jumping to payload
 *
 * Called right before jumping to a payload. If the boot sequence stops with
 * this code, chances are the payload freezes.
 */
#define POST_JUMPING_TO_PAYLOAD			0xf3

/**
 * \brief Not supposed to get here
 *
 * A function that should not have returned, returned
 *
 * Check the console output for details.
 */
#define POST_DEAD_CODE				0xee

/**
 * \brief Resume from suspend failed
 *
 * This post code is sent when the firmware is expected to resume it is
 * unable to do so.
 */
#define POST_RESUME_FAILURE			0xef

/**
 * \brief Final code before OS resumes
 *
 * Called right before jumping to the OS resume vector.
 */
#define POST_OS_RESUME				0xfd

/**
 * \brief Final code before OS boots
 *
 * This may not be called depending on the payload used.
 */
#define POST_OS_BOOT				0xfe

/**
 * \brief Elfload fail or die() called
 *
 * Coreboot was not able to load the payload, no payload was detected
 * or die() was called.
 * \n
 * If this code appears before entering ramstage, then most likely
 * ramstage is corrupted, and reflashing of the ROM chip is needed.
 * \n
 * If this code appears after ramstage, there is a problem with the payload
 * If the payload was built out-of-tree, check that it was compiled as
 * a coreboot payload
 * \n
 * Check the console output to see exactly where the failure occured.
 */
#define POST_DIE 				0xff


/*
 * The following POST codes are taken from src/include/cpu/amd/geode_post_code.h
 * They overlap with previous codes, and most are not even used
 * Some mainboards still require them, but they are deprecated. We want to consolidate
 * our own POST code structure with the codes above.
 *
 * standard AMD post definitions for the AMD Geode
 */
#define POST_Output_Port			(0x080)	/*	port to write post codes to*/

#define POST_preSioInit				(0x000)
#define POST_clockInit				(0x001)
#define POST_CPURegInit				(0x002)
#define POST_UNREAL				(0x003)
#define POST_CPUMemRegInit			(0x004)
#define POST_CPUTest				(0x005)
#define POST_memSetup				(0x006)
#define POST_memSetUpStack			(0x007)
#define POST_memTest				(0x008)
#define POST_shadowRom				(0x009)
#define POST_memRAMoptimize			(0x00A)
#define POST_cacheInit				(0x00B)
#define POST_northBridgeInit			(0x00C)
#define POST_chipsetInit			(0x00D)
#define POST_sioTest				(0x00E)
#define POST_pcATjunk				(0x00F)

#define POST_intTable				(0x010)
#define POST_memInfo				(0x011)
#define POST_romCopy				(0x012)
#define POST_PLLCheck				(0x013)
#define POST_keyboardInit			(0x014)
#define POST_cpuCacheOff			(0x015)
#define POST_BDAInit				(0x016)
#define POST_pciScan				(0x017)
#define POST_optionRomInit			(0x018)
#define POST_ResetLimits			(0x019)
#define POST_summary_screen			(0x01A)
#define POST_Boot				(0x01B)
#define POST_SystemPreInit			(0x01C)
#define POST_ClearRebootFlag			(0x01D)
#define POST_GLIUInit				(0x01E)
#define POST_BootFailed				(0x01F)

#define POST_CPU_ID				(0x020)
#define POST_COUNTERBROKEN			(0x021)
#define POST_DIFF_DIMMS				(0x022)
#define POST_WIGGLE_MEM_LINES			(0x023)
#define POST_NO_GLIU_DESC			(0x024)
#define POST_CPU_LCD_CHECK			(0x025)
#define POST_CPU_LCD_PASS			(0x026)
#define POST_CPU_LCD_FAIL			(0x027)
#define POST_CPU_STEPPING			(0x028)
#define POST_CPU_DM_BIST_FAILURE		(0x029)
#define POST_CPU_FLAGS				(0x02A)
#define POST_CHIPSET_ID				(0x02B)
#define POST_CHIPSET_ID_PASS			(0x02C)
#define POST_CHIPSET_ID_FAIL			(0x02D)
#define POST_CPU_ID_GOOD			(0x02E)
#define POST_CPU_ID_FAIL			(0x02F)

/*	PCI config*/
#define P80_PCICFG				(0x030)

/*	PCI io*/
#define P80_PCIIO				(0x040)

/*	PCI memory*/
#define P80_PCIMEM				(0x050)

/*	SIO*/
#define P80_SIO					(0x060)

/*	Memory Setp*/
#define P80_MEM_SETUP				(0x070)
#define POST_MEM_SETUP				(0x070)
#define ERROR_32BIT_DIMMS			(0x071)
#define POST_MEM_SETUP2				(0x072)
#define POST_MEM_SETUP3				(0x073)
#define POST_MEM_SETUP4				(0x074)
#define POST_MEM_SETUP5				(0x075)
#define POST_MEM_ENABLE				(0x076)
#define ERROR_NO_DIMMS				(0x077)
#define ERROR_DIFF_DIMMS			(0x078)
#define ERROR_BAD_LATENCY			(0x079)
#define ERROR_SET_PAGE				(0x07A)
#define ERROR_DENSITY_DIMM			(0x07B)
#define ERROR_UNSUPPORTED_DIMM			(0x07C)
#define ERROR_BANK_SET				(0x07D)
#define POST_MEM_SETUP_GOOD			(0x07E)
#define POST_MEM_SETUP_FAIL			(0x07F)

#define POST_UserPreInit			(0x080)
#define POST_UserPostInit			(0x081)
#define POST_Equipment_check			(0x082)
#define POST_InitNVRAMBX			(0x083)
#define POST_NoPIRTable				(0x084)
#define POST_ChipsetFingerPrintPass		(0x085)
#define POST_ChipsetFingerPrintFail		(0x086)
#define POST_CPU_IM_TAG_BIST_FAILURE		(0x087)
#define POST_CPU_IM_DATA_BIST_FAILURE		(0x088)
#define POST_CPU_FPU_BIST_FAILURE		(0x089)
#define POST_CPU_BTB_BIST_FAILURE		(0x08A)
#define POST_CPU_EX_BIST_FAILURE		(0x08B)
#define POST_Chipset_PI_Test_Fail		(0x08C)
#define POST_Chipset_SMBus_SDA_Test_Fail	(0x08D)
#define POST_BIT_CLK_Fail			(0x08E)

#define POST_STACK_SETUP			(0x090)
#define POST_CPU_PF_BIST_FAILURE		(0x091)
#define POST_CPU_L2_BIST_FAILURE		(0x092)
#define POST_CPU_GLCP_BIST_FAILURE		(0x093)
#define POST_CPU_DF_BIST_FAILURE		(0x094)
#define POST_CPU_VG_BIST_FAILURE		(0x095)
#define POST_CPU_VIP_BIST_FAILURE		(0x096)
#define POST_STACK_SETUP_PASS			(0x09E)
#define POST_STACK_SETUP_FAIL			(0x09F)

#define POST_PLL_INIT				(0x0A0)
#define POST_PLL_MANUAL				(0x0A1)
#define POST_PLL_STRAP				(0x0A2)
#define POST_PLL_RESET_FAIL			(0x0A3)
#define POST_PLL_PCI_FAIL			(0x0A4)
#define POST_PLL_MEM_FAIL			(0x0A5)
#define POST_PLL_CPU_VER_FAIL			(0x0A6)

#define POST_MEM_TESTMEM			(0x0B0)
#define POST_MEM_TESTMEM1			(0x0B1)
#define POST_MEM_TESTMEM2			(0x0B2)
#define POST_MEM_TESTMEM3			(0x0B3)
#define POST_MEM_TESTMEM4			(0x0B4)
#define POST_MEM_TESTMEM_PASS			(0x0BE)
#define POST_MEM_TESTMEM_FAIL			(0x0BF)

#define POST_SECUROM_SECBOOT_START		(0x0C0)
#define POST_SECUROM_BOOTSRCSETUP		(0x0C1)
#define POST_SECUROM_REMAP_FAIL			(0x0C2)
#define POST_SECUROM_BOOTSRCSETUP_FAIL		(0x0C3)
#define POST_SECUROM_DCACHESETUP		(0x0C4)
#define POST_SECUROM_DCACHESETUP_FAIL		(0x0C5)
#define POST_SECUROM_ICACHESETUP		(0x0C6)
#define POST_SECUROM_DESCRIPTORSETUP		(0x0C7)
#define POST_SECUROM_DCACHESETUPBIOS		(0x0C8)
#define POST_SECUROM_PLATFORMSETUP		(0x0C9)
#define POST_SECUROM_SIGCHECKBIOS		(0x0CA)
#define POST_SECUROM_ICACHESETUPBIOS		(0x0CB)
#define POST_SECUROM_PASS			(0x0CC)
#define POST_SECUROM_FAIL			(0x0CD)

#define POST_RCONFInitError			(0x0CE)
#define POST_CacheInitError			(0x0CF)

#define POST_ROM_PREUNCOMPRESS			(0x0D0)
#define POST_ROM_UNCOMPRESS			(0x0D1)
#define POST_ROM_SMM_INIT			(0x0D2)
#define POST_ROM_VID_BIOS			(0x0D3)
#define POST_ROM_LCDINIT			(0x0D4)
#define POST_ROM_SPLASH				(0x0D5)
#define POST_ROM_HDDINIT			(0x0D6)
#define POST_ROM_SYS_INIT			(0x0D7)
#define POST_ROM_DMM_INIT			(0x0D8)
#define POST_ROM_TVINIT				(0x0D9)
#define POST_ROM_POSTUNCOMPRESS			(0x0DE)

#define P80_CHIPSET_INIT			(0x0E0)
#define POST_PreChipsetInit			(0x0E1)
#define POST_LateChipsetInit			(0x0E2)
#define POST_NORTHB_INIT			(0x0E8)

#define POST_INTR_SEG_JUMP			(0x0F0)

#endif /* THE_ALMIGHTY_POST_CODES_H */
# 443 "src/include/console/post_codes.h"
# 26 "src/include/console/console.h" 2

#ifndef __ROMCC__
void post_code(u8 value);
#if CONFIG_CMOS_POST_EXTRA
void post_log_extra(u32 value);
struct device;
void post_log_path(struct device *dev);
void post_log_clear(void);
#else
# 35 "src/include/console/console.h"
#define post_log_extra(x) do {} while (0)
#define post_log_path(x) do {} while (0)
#define post_log_clear() do {} while (0)
#endif
# 39 "src/include/console/console.h"
/* this function is weak and can be overridden by a mainboard function. */
void mainboard_post(u8 value);
void __attribute__ ((noreturn)) die(const char *msg);

#define __CONSOLE_ENABLE__ \
	((ENV_BOOTBLOCK && CONFIG_BOOTBLOCK_CONSOLE) || \
	ENV_ROMSTAGE || ENV_RAMSTAGE || (ENV_SMM && CONFIG_DEBUG_SMI))

#if __CONSOLE_ENABLE__
void console_init(void);
int console_log_level(int msg_level);
int do_printk(int msg_level, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
void do_putchar(unsigned char byte);

#define printk(LEVEL, fmt, args...)	\
	do { do_printk(LEVEL, fmt, ##args); } while(0)

#else
# 57 "src/include/console/console.h"
static inline void console_init(void) {}
static inline int console_log_level(int msg_level) { return 0; }
static inline void printk(int LEVEL, const char *fmt, ...) {}
static inline void do_putchar(unsigned char byte) {}
#endif
# 62 "src/include/console/console.h"

#if CONFIG_CHROMEOS
/* FIXME: Collision of varargs with AMD headers without guard. */
#if 0 /* expanded by -frewrite-includes */
#include <console/vtxprintf.h>
#endif /* expanded by -frewrite-includes */
# 65 "src/include/console/console.h"
# 66 "src/include/console/console.h"
#if __CONSOLE_ENABLE__
void do_vtxprintf(const char *fmt, va_list args);
#else
# 69 "src/include/console/console.h"
static inline void do_vtxprintf(const char *fmt, va_list args) {};
#endif
# 71 "src/include/console/console.h"
#endif
# 72 "src/include/console/console.h"

/* A lot of code still uses print_debug() et al. while use of printk()
 * would be preferred.
 */
#if 0 /* expanded by -frewrite-includes */
#include <console/early_print.h>
#endif /* expanded by -frewrite-includes */
# 76 "src/include/console/console.h"
# 1 "src/include/console/early_print.h" 1
/*
 * This file is part of the coreboot project.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef __CONSOLE_EARLY_PRINT_H_
#define __CONSOLE_EARLY_PRINT_H_

#if 0 /* expanded by -frewrite-includes */
#include <console/console.h>
#endif /* expanded by -frewrite-includes */
# 21 "src/include/console/early_print.h"
# 1 "src/include/console/console.h" 1
/*
 * This file is part of the coreboot project.
 *
 * Copyright (C) 2003 Eric Biederman
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef CONSOLE_CONSOLE_H_
#define CONSOLE_CONSOLE_H_

#if 0 /* expanded by -frewrite-includes */
#include <stdint.h>
#endif /* expanded by -frewrite-includes */
# 23 "src/include/console/console.h"
# 24 "src/include/console/console.h"
#if 0 /* expanded by -frewrite-includes */
#include <rules.h>
#endif /* expanded by -frewrite-includes */
# 24 "src/include/console/console.h"
# 25 "src/include/console/console.h"
#if 0 /* expanded by -frewrite-includes */
#include <console/post_codes.h>
#endif /* expanded by -frewrite-includes */
# 25 "src/include/console/console.h"
# 26 "src/include/console/console.h"

#ifndef __ROMCC__
void post_code(u8 value);
#if CONFIG_CMOS_POST_EXTRA
void post_log_extra(u32 value);
struct device;
void post_log_path(struct device *dev);
void post_log_clear(void);
#else
# 35 "src/include/console/console.h"
#define post_log_extra(x) do {} while (0)
#define post_log_path(x) do {} while (0)
#define post_log_clear() do {} while (0)
#endif
# 39 "src/include/console/console.h"
/* this function is weak and can be overridden by a mainboard function. */
void mainboard_post(u8 value);
void __attribute__ ((noreturn)) die(const char *msg);

#define __CONSOLE_ENABLE__ \
	((ENV_BOOTBLOCK && CONFIG_BOOTBLOCK_CONSOLE) || \
	ENV_ROMSTAGE || ENV_RAMSTAGE || (ENV_SMM && CONFIG_DEBUG_SMI))

#if __CONSOLE_ENABLE__
void console_init(void);
int console_log_level(int msg_level);
int do_printk(int msg_level, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
void do_putchar(unsigned char byte);

#define printk(LEVEL, fmt, args...)	\
	do { do_printk(LEVEL, fmt, ##args); } while(0)

#else
# 57 "src/include/console/console.h"
static inline void console_init(void) {}
static inline int console_log_level(int msg_level) { return 0; }
static inline void printk(int LEVEL, const char *fmt, ...) {}
static inline void do_putchar(unsigned char byte) {}
#endif
# 62 "src/include/console/console.h"

#if CONFIG_CHROMEOS
/* FIXME: Collision of varargs with AMD headers without guard. */
#if 0 /* expanded by -frewrite-includes */
#include <console/vtxprintf.h>
#endif /* expanded by -frewrite-includes */
# 65 "src/include/console/console.h"
# 66 "src/include/console/console.h"
#if __CONSOLE_ENABLE__
void do_vtxprintf(const char *fmt, va_list args);
#else
# 69 "src/include/console/console.h"
static inline void do_vtxprintf(const char *fmt, va_list args) {};
#endif
# 71 "src/include/console/console.h"
#endif
# 72 "src/include/console/console.h"

/* A lot of code still uses print_debug() et al. while use of printk()
 * would be preferred.
 */
#if 0 /* expanded by -frewrite-includes */
#include <console/early_print.h>
#endif /* expanded by -frewrite-includes */
# 76 "src/include/console/console.h"
# 77 "src/include/console/console.h"

#else /* __ROMCC__ */
# 79 "src/include/console/console.h"

#if 0 /* expanded by -frewrite-includes */
#include "arch/x86/lib/romcc_console.c"
#endif /* expanded by -frewrite-includes */
# 80 "src/include/console/console.h"
# 81 "src/include/console/console.h"

#endif /* __ROMCC__ */
# 83 "src/include/console/console.h"

#endif /* CONSOLE_CONSOLE_H_ */
# 85 "src/include/console/console.h"
# 22 "src/include/console/early_print.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <console/streams.h>
#endif /* expanded by -frewrite-includes */
# 22 "src/include/console/early_print.h"
# 1 "src/include/console/streams.h" 1
/*
 * This file is part of the coreboot project.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef _CONSOLE_STREAMS_H_
#define _CONSOLE_STREAMS_H_

void console_hw_init(void);
void console_tx_byte(unsigned char byte);
void console_tx_flush(void);

/* Helpers for ROMCC console. */
void console_tx_nibble(unsigned nibble);
void console_tx_hex8(unsigned char value);
void console_tx_hex16(unsigned short value);
void console_tx_hex32(unsigned int value);
void console_tx_string(const char *str);

#endif /* _CONSOLE_STREAMS_H_ */
# 33 "src/include/console/streams.h"
# 23 "src/include/console/early_print.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <console/loglevel.h>
#endif /* expanded by -frewrite-includes */
# 23 "src/include/console/early_print.h"
# 1 "src/include/console/loglevel.h" 1
#ifndef LOGLEVEL_H
#define LOGLEVEL_H

/* Safe for inclusion in assembly */
#define BIOS_EMERG      0   /* system is unusable                   */
#define BIOS_ALERT      1   /* action must be taken immediately     */
#define BIOS_CRIT       2   /* critical conditions                  */
#define BIOS_ERR        3   /* error conditions                     */
#define BIOS_WARNING    4   /* warning conditions                   */
#define BIOS_NOTICE     5   /* normal but significant condition     */
#define BIOS_INFO       6   /* informational                        */
#define BIOS_DEBUG      7   /* debug-level messages                 */
#define BIOS_SPEW       8   /* way too many details                 */
#define BIOS_NEVER	9   /* these messages are never printed     */

#endif /* LOGLEVEL_H */
# 17 "src/include/console/loglevel.h"
# 24 "src/include/console/early_print.h" 2

#if defined(__ROMCC__)
/* While in romstage, console loglevel is built-time constant.
 * With ROMCC we inline this test with help from preprocessor.
 */
#define console_log_level(msg_level) (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= msg_level)

#define CALL_CONSOLE_TX(loglevel, tx_func, x) \
	do { 						\
		if (console_log_level(loglevel)) { 	\
			tx_func(x);		 	\
			console_tx_flush();		\
		}	\
	} while (0)

#define __console_tx_char(level, x)	CALL_CONSOLE_TX(level, console_tx_byte, x)
#define __console_tx_hex8(level, x)	CALL_CONSOLE_TX(level, console_tx_hex8, x)
#define __console_tx_hex16(level, x)	CALL_CONSOLE_TX(level, console_tx_hex16, x)
#define __console_tx_hex32(level, x)	CALL_CONSOLE_TX(level, console_tx_hex32, x)
#define __console_tx_string(level, x)	CALL_CONSOLE_TX(level, console_tx_string, x)

#define print_emerg(STR)         __console_tx_string(BIOS_EMERG, STR)
#define print_alert(STR)         __console_tx_string(BIOS_ALERT, STR)
#define print_crit(STR)          __console_tx_string(BIOS_CRIT, STR)
#define print_err(STR)           __console_tx_string(BIOS_ERR, STR)
#define print_warning(STR)       __console_tx_string(BIOS_WARNING, STR)
#define print_notice(STR)        __console_tx_string(BIOS_NOTICE, STR)
#define print_info(STR)          __console_tx_string(BIOS_INFO, STR)
#define print_debug(STR)         __console_tx_string(BIOS_DEBUG, STR)
#define print_spew(STR)          __console_tx_string(BIOS_SPEW, STR)

#define print_emerg_char(CH)     __console_tx_char(BIOS_EMERG, CH)
#define print_alert_char(CH)     __console_tx_char(BIOS_ALERT, CH)
#define print_crit_char(CH)      __console_tx_char(BIOS_CRIT, CH)
#define print_err_char(CH)       __console_tx_char(BIOS_ERR, CH)
#define print_warning_char(CH)   __console_tx_char(BIOS_WARNING, CH)
#define print_notice_char(CH)    __console_tx_char(BIOS_NOTICE, CH)
#define print_info_char(CH)      __console_tx_char(BIOS_INFO, CH)
#define print_debug_char(CH)     __console_tx_char(BIOS_DEBUG, CH)
#define print_spew_char(CH)      __console_tx_char(BIOS_SPEW, CH)

#define print_emerg_hex8(HEX)    __console_tx_hex8(BIOS_EMERG, HEX)
#define print_alert_hex8(HEX)    __console_tx_hex8(BIOS_ALERT, HEX)
#define print_crit_hex8(HEX)     __console_tx_hex8(BIOS_CRIT, HEX)
#define print_err_hex8(HEX)      __console_tx_hex8(BIOS_ERR, HEX)
#define print_warning_hex8(HEX)  __console_tx_hex8(BIOS_WARNING, HEX)
#define print_notice_hex8(HEX)   __console_tx_hex8(BIOS_NOTICE, HEX)
#define print_info_hex8(HEX)     __console_tx_hex8(BIOS_INFO, HEX)
#define print_debug_hex8(HEX)    __console_tx_hex8(BIOS_DEBUG, HEX)
#define print_spew_hex8(HEX)     __console_tx_hex8(BIOS_SPEW, HEX)

#define print_emerg_hex16(HEX)   __console_tx_hex16(BIOS_EMERG, HEX)
#define print_alert_hex16(HEX)   __console_tx_hex16(BIOS_ALERT, HEX)
#define print_crit_hex16(HEX)    __console_tx_hex16(BIOS_CRIT, HEX)
#define print_err_hex16(HEX)     __console_tx_hex16(BIOS_ERR, HEX)
#define print_warning_hex16(HEX) __console_tx_hex16(BIOS_WARNING, HEX)
#define print_notice_hex16(HEX)  __console_tx_hex16(BIOS_NOTICE, HEX)
#define print_info_hex16(HEX)    __console_tx_hex16(BIOS_INFO, HEX)
#define print_debug_hex16(HEX)   __console_tx_hex16(BIOS_DEBUG, HEX)
#define print_spew_hex16(HEX)    __console_tx_hex16(BIOS_SPEW, HEX)

#define print_emerg_hex32(HEX)   __console_tx_hex32(BIOS_EMERG, HEX)
#define print_alert_hex32(HEX)   __console_tx_hex32(BIOS_ALERT, HEX)
#define print_crit_hex32(HEX)    __console_tx_hex32(BIOS_CRIT, HEX)
#define print_err_hex32(HEX)     __console_tx_hex32(BIOS_ERR, HEX)
#define print_warning_hex32(HEX) __console_tx_hex32(BIOS_WARNING, HEX)
#define print_notice_hex32(HEX)  __console_tx_hex32(BIOS_NOTICE, HEX)
#define print_info_hex32(HEX)    __console_tx_hex32(BIOS_INFO, HEX)
#define print_debug_hex32(HEX)   __console_tx_hex32(BIOS_DEBUG, HEX)
#define print_spew_hex32(HEX)    __console_tx_hex32(BIOS_SPEW, HEX)

#else
# 96 "src/include/console/early_print.h"

#define print_emerg(STR)         printk(BIOS_EMERG,  "%s", (STR))
#define print_alert(STR)         printk(BIOS_ALERT,  "%s", (STR))
#define print_crit(STR)          printk(BIOS_CRIT,   "%s", (STR))
#define print_err(STR)           printk(BIOS_ERR,    "%s", (STR))
#define print_warning(STR)       printk(BIOS_WARNING,"%s", (STR))
#define print_notice(STR)        printk(BIOS_NOTICE, "%s", (STR))
#define print_info(STR)          printk(BIOS_INFO,   "%s", (STR))
#define print_debug(STR)         printk(BIOS_DEBUG,  "%s", (STR))
#define print_spew(STR)          printk(BIOS_SPEW,   "%s", (STR))

#define print_emerg_char(CH)     printk(BIOS_EMERG,  "%c", (CH))
#define print_alert_char(CH)     printk(BIOS_ALERT,  "%c", (CH))
#define print_crit_char(CH)      printk(BIOS_CRIT,   "%c", (CH))
#define print_err_char(CH)       printk(BIOS_ERR,    "%c", (CH))
#define print_warning_char(CH)   printk(BIOS_WARNING,"%c", (CH))
#define print_notice_char(CH)    printk(BIOS_NOTICE, "%c", (CH))
#define print_info_char(CH)      printk(BIOS_INFO,   "%c", (CH))
#define print_debug_char(CH)     printk(BIOS_DEBUG,  "%c", (CH))
#define print_spew_char(CH)      printk(BIOS_SPEW,   "%c", (CH))

#define print_emerg_hex8(HEX)    printk(BIOS_EMERG,  "%02x",  (HEX))
#define print_alert_hex8(HEX)    printk(BIOS_ALERT,  "%02x",  (HEX))
#define print_crit_hex8(HEX)     printk(BIOS_CRIT,   "%02x",  (HEX))
#define print_err_hex8(HEX)      printk(BIOS_ERR,    "%02x",  (HEX))
#define print_warning_hex8(HEX)  printk(BIOS_WARNING,"%02x",  (HEX))
#define print_notice_hex8(HEX)   printk(BIOS_NOTICE, "%02x",  (HEX))
#define print_info_hex8(HEX)     printk(BIOS_INFO,   "%02x",  (HEX))
#define print_debug_hex8(HEX)    printk(BIOS_DEBUG,  "%02x",  (HEX))
#define print_spew_hex8(HEX)     printk(BIOS_SPEW,   "%02x",  (HEX))

#define print_emerg_hex16(HEX)   printk(BIOS_EMERG,  "%04x", (HEX))
#define print_alert_hex16(HEX)   printk(BIOS_ALERT,  "%04x", (HEX))
#define print_crit_hex16(HEX)    printk(BIOS_CRIT,   "%04x", (HEX))
#define print_err_hex16(HEX)     printk(BIOS_ERR,    "%04x", (HEX))
#define print_warning_hex16(HEX) printk(BIOS_WARNING,"%04x", (HEX))
#define print_notice_hex16(HEX)  printk(BIOS_NOTICE, "%04x", (HEX))
#define print_info_hex16(HEX)    printk(BIOS_INFO,   "%04x", (HEX))
#define print_debug_hex16(HEX)   printk(BIOS_DEBUG,  "%04x", (HEX))
#define print_spew_hex16(HEX)    printk(BIOS_SPEW,   "%04x", (HEX))

#define print_emerg_hex32(HEX)   printk(BIOS_EMERG,  "%08x", (HEX))
#define print_alert_hex32(HEX)   printk(BIOS_ALERT,  "%08x", (HEX))
#define print_crit_hex32(HEX)    printk(BIOS_CRIT,   "%08x", (HEX))
#define print_err_hex32(HEX)     printk(BIOS_ERR,    "%08x", (HEX))
#define print_warning_hex32(HEX) printk(BIOS_WARNING,"%08x", (HEX))
#define print_notice_hex32(HEX)  printk(BIOS_NOTICE, "%08x", (HEX))
#define print_info_hex32(HEX)    printk(BIOS_INFO,   "%08x", (HEX))
#define print_debug_hex32(HEX)   printk(BIOS_DEBUG,  "%08x", (HEX))
#define print_spew_hex32(HEX)    printk(BIOS_SPEW,   "%08x", (HEX))

#endif
# 148 "src/include/console/early_print.h"

#endif /* __CONSOLE_EARLY_PRINT_H_ */
# 150 "src/include/console/early_print.h"
# 77 "src/include/console/console.h" 2

#else /* __ROMCC__ */
# 79 "src/include/console/console.h"

#if 0 /* expanded by -frewrite-includes */
#include "arch/x86/lib/romcc_console.c"
#endif /* expanded by -frewrite-includes */
# 80 "src/include/console/console.h"
# 81 "src/include/console/console.h"

#endif /* __ROMCC__ */
# 83 "src/include/console/console.h"

#endif /* CONSOLE_CONSOLE_H_ */
# 85 "src/include/console/console.h"
# 266 "src/vendorcode/amd/agesa/f14/Porting.h" 2
#if 0 /* expanded by -frewrite-includes */
#include <console/loglevel.h>
#endif /* expanded by -frewrite-includes */
# 266 "src/vendorcode/amd/agesa/f14/Porting.h"
# 267 "src/vendorcode/amd/agesa/f14/Porting.h"

#ifndef NULL
  #define NULL              (void *)0
#endif
# 271 "src/vendorcode/amd/agesa/f14/Porting.h"

#else
# 273 "src/vendorcode/amd/agesa/f14/Porting.h"
  // -----------------------------------------------------------------------
  // Unknown or unsupported compiler
  //
  #error "Unknown compiler in use"
#endif
# 278 "src/vendorcode/amd/agesa/f14/Porting.h"



// -----------------------------------------------------------------------
// Common definitions for all compilers
//

//Support forward reference construct
#define AGESA_FORWARD_DECLARATION(x) typedef struct _##x x


// The following are use in conformance to the UEFI style guide
#define IN
#define OUT

#endif // _PORTING_H_
# 294 "src/vendorcode/amd/agesa/f14/Porting.h"
# 51 "src/vendorcode/amd/agesa/f14/AGESA.h" 2
#if 0 /* expanded by -frewrite-includes */
#include  "AMD.h"
#endif /* expanded by -frewrite-includes */
# 51 "src/vendorcode/amd/agesa/f14/AGESA.h"
# 1 "src/vendorcode/amd/agesa/f14/AMD.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * Agesa structures and definitions
 *
 * Contains AMD AGESA core interface
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Include
 * @e \$Revision: 34897 $   @e \$Date: 2010-07-14 10:07:10 +0800 (Wed, 14 Jul 2010) $
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */


#ifndef _AMD_H_
#define _AMD_H_

#define AGESA_REVISION  "Arch2008"
#define AGESA_ID        "AGESA"

#define Int16FromChar(a,b) ((a) << 0 | (b) << 8)
#define Int32FromChar(a,b,c,d) ((a) << 0 | (b) << 8 | (c) << 16 | (d) << 24)
//
//
// AGESA Types and Definitions
//
//
#define LAST_ENTRY          0xFFFFFFFF
#define IMAGE_SIGNATURE     Int32FromChar ('$', 'A', 'M', 'D')
#define IOCF8 0xCF8
#define IOCFC 0xCFC

/// The return status for all AGESA public services.
///
/// Services return the most severe status of any logged event.  Status other than SUCCESS, UNSUPPORTED, and BOUNDS_CHK
/// will have log entries with more detail.
///
typedef enum {
  AGESA_SUCCESS = 0,             ///< The service completed normally. Info may be logged.
  AGESA_UNSUPPORTED,             ///< The dispatcher or create struct had an unimplemented function requested.
                                 ///<  Not logged.
  AGESA_BOUNDS_CHK,              ///< A dynamic parameter was out of range and the service was not provided.
                                 ///< Example, memory address not installed, heap buffer handle not found.
                                 ///< Not Logged.
  // AGESA_STATUS of greater severity (the ones below this line), always have a log entry available.
  AGESA_ALERT,                   ///< An observed condition, but no loss of function.
                                 ///<  See log.  Example, HT CRC.
  AGESA_WARNING,                 ///< Possible or minor loss of function.  See Log.
  AGESA_ERROR,                   ///< Significant loss of function, boot may be possible.  See Log.
  AGESA_CRITICAL,                ///< Continue boot only to notify user.  See Log.
  AGESA_FATAL,                   ///< Halt booting.  See Log, however Fatal errors pertaining to heap problems
                                 ///< may not be able to reliably produce log events.
  AgesaStatusMax                 ///< Not a status, for limit checking.
} AGESA_STATUS;

/// For checking whether a status is at or above the mandatory log level.
#define AGESA_STATUS_LOG_LEVEL AGESA_ALERT

/**
 * Callout method to the host environment.
 *
 * Callout using a dispatch with appropriate thunk layer, which is determined by the host environment.
 *
 * @param[in]        Function      The specific callout function being invoked.
 * @param[in]        FcnData       Function specific data item.
 * @param[in,out]    ConfigPtr     Reference to Callout params.
 */
typedef AGESA_STATUS (*CALLOUT_ENTRY) (
  IN       UINT32  Function,
  IN       UINTN   FcnData,
  IN OUT   VOID    *ConfigPtr
  );

typedef AGESA_STATUS (*IMAGE_ENTRY) (VOID *ConfigPtr);
typedef AGESA_STATUS (*MODULE_ENTRY) (VOID *ConfigPtr);

///This allocation type is used by the AmdCreateStruct entry point
typedef enum {
  PreMemHeap = 0,                                           ///< Create heap in cache.
  PostMemDram,                                              ///< Create heap in memory.
  ByHost                                                    ///< Create heap by Host.
} ALLOCATION_METHOD;

/// These width descriptors are used by the library function, and others, to specify the data size
typedef enum ACCESS_WIDTH {
  AccessWidth8 = 1,                                         ///< Access width is 8 bits.
  AccessWidth16,                                            ///< Access width is 16 bits.
  AccessWidth32,                                            ///< Access width is 32 bits.
  AccessWidth64,                                            ///< Access width is 64 bits.

  AccessS3SaveWidth8 = 0x81,                                ///< Save 8 bits data.
  AccessS3SaveWidth16,                                      ///< Save 16 bits data.
  AccessS3SaveWidth32,                                      ///< Save 32 bits data.
  AccessS3SaveWidth64,                                      ///< Save 64 bits data.
} ACCESS_WIDTH;

/// AGESA struct name
typedef enum {
  // AGESA BASIC FUNCTIONS
  AMD_INIT_RECOVERY = 0x00020000,                           ///< AmdInitRecovery entry point handle
  AMD_CREATE_STRUCT,                                        ///< AmdCreateStruct handle
  AMD_INIT_EARLY,                                           ///< AmdInitEarly entry point handle
  AMD_INIT_ENV,                                             ///< AmdInitEnv entry point handle
  AMD_INIT_LATE,                                            ///< AmdInitLate entry point handle
  AMD_INIT_MID,                                             ///< AmdInitMid entry point handle
  AMD_INIT_POST,                                            ///< AmdInitPost entry point handle
  AMD_INIT_RESET,                                           ///< AmdInitReset entry point handle
  AMD_INIT_RESUME,                                          ///< AmdInitResume entry point handle
  AMD_RELEASE_STRUCT,                                       ///< AmdReleaseStruct handle
  AMD_S3LATE_RESTORE,                                       ///< AmdS3LateRestore entry point handle
  AMD_S3_SAVE,                                              ///< AmdS3Save entry point handle
  AMD_GET_APIC_ID,                                          ///< AmdGetApicId entry point handle
  AMD_GET_PCI_ADDRESS,                                      ///< AmdGetPciAddress entry point handle
  AMD_IDENTIFY_CORE,                                        ///< AmdIdentifyCore general service handle
  AMD_READ_EVENT_LOG,                                       ///< AmdReadEventLog general service handle
  AMD_GET_EXECACHE_SIZE,                                    ///< AmdGetAvailableExeCacheSize general service handle
  AMD_LATE_RUN_AP_TASK,                                     ///< AmdLateRunApTask entry point handle
  AMD_IDENTIFY_DIMMS                                        ///< AmdIdentifyDimm general service handle
} AGESA_STRUCT_NAME;

  /*  ResetType constant values */
#define WARM_RESET_WHENEVER 1
#define COLD_RESET_WHENEVER 2
#define WARM_RESET_IMMEDIATELY 3
#define COLD_RESET_IMMEDIATELY 4


// AGESA Structures

/// The standard header for all AGESA services.
/// For internal AGESA naming conventions, see @ref amdconfigparamname .
typedef struct {
  IN       UINT32          ImageBasePtr;     ///< The AGESA Image base address.
  IN       UINT32          Func;             ///< The service desired
  IN       UINT32          AltImageBasePtr;  ///< Alternate Image location
  IN       CALLOUT_ENTRY   CalloutPtr;       ///< For Callout from AGESA
  IN       UINT8           HeapStatus;       ///< For heap status from boot time slide.
  IN       VOID           *HeapBasePtr;      ///< Location of the heap
  IN OUT   UINT8           Reserved[7];      ///< This space is reserved for future use.
} AMD_CONFIG_PARAMS;


/// Create Struct Interface.
typedef struct {
  IN       AMD_CONFIG_PARAMS   StdHeader;          ///< Standard configuration header
  IN       AGESA_STRUCT_NAME   AgesaFunctionName;  ///< The service to init
  IN       ALLOCATION_METHOD   AllocationMethod;   ///< How to handle buffer allocation
  IN OUT   UINT32              NewStructSize;      ///< The size of the allocated data, in for ByHost, else out only.
  IN OUT   VOID                *NewStructPtr;      ///< The struct for the service.
                                                   ///< The struct to init for ByHost allocation,
                                                   ///< the initialized struct on return.
} AMD_INTERFACE_PARAMS;

#define FUNC_0    0   // bit-placed for PCI address creation
#define FUNC_1    1
#define FUNC_2    2
#define FUNC_3    3
#define FUNC_4    4
#define FUNC_5    5
#define FUNC_6    6
#define FUNC_7    7

/// AGESA Binary module header structure
typedef struct {
  IN  UINT32  Signature;                          ///< Binary Signature
  IN  CHAR8   CreatorID[8];                       ///< 8 characters ID
  IN  CHAR8   Version[12];                        ///< 12 characters version
  IN  UINT32  ModuleInfoOffset;                   ///< Offset of module
  IN  UINT32  EntryPointAddress;                  ///< Entry address
  IN  UINT32  ImageBase;                          ///< Image base
  IN  UINT32  RelocTableOffset;                   ///< Relocate Table offset
  IN  UINT32  ImageSize;                          ///< Size
  IN  UINT16  Checksum;                           ///< Checksum
  IN  UINT8   ImageType;                          ///< Type
  IN  UINT8   V_Reserved;                         ///< Reserved
} AMD_IMAGE_HEADER;
/// AGESA Binary module header structure
typedef struct _AMD_MODULE_HEADER {
  IN  UINT32          ModuleHeaderSignature;      ///< Module signature
  IN  CHAR8           ModuleIdentifier[8];        ///< 8 characters ID
  IN  CHAR8           ModuleVersion[12];          ///< 12 characters version
  IN  VOID            *ModuleDispatcher;          ///< A pointer point to dispatcher
  IN  struct _AMD_MODULE_HEADER  *NextBlock;      ///< Next module header link
} AMD_MODULE_HEADER;

// AMD_CODE_HEADER Signatures.
#define AGESA_CODE_SIGNATURE  {'!', '!', 'A', 'G', 'E', 'S', 'A', ' '}
#define CIMXNB_CODE_SIGNATURE {'!', '!', 'C', 'I', 'M', 'X', 'N', 'B'}
#define CIMXSB_CODE_SIGNATURE {'!', '!', 'C', 'I', 'M', 'X', 'S', 'B'}

/// AGESA_CODE_SIGNATURE
typedef struct {
  IN  CHAR8   Signature[8];                       ///< code header Signature
  IN  CHAR8   ComponentName[8];                   ///< 8 character name of the code module
  IN  CHAR8   Version[12];                        ///< 12 character version string
  IN  CHAR8   TerminatorNull;                     ///< null terminated string
  IN  CHAR8   VerReserved[7];                     ///< reserved space
} AMD_CODE_HEADER;

/// Extended PCI address format
typedef struct {
  IN OUT  UINT32      Register:12;                ///< Register offset
  IN OUT  UINT32      Function:3;                 ///< Function number
  IN OUT  UINT32      Device:5;                   ///< Device number
  IN OUT  UINT32      Bus:8;                      ///< Bus number
  IN OUT  UINT32      Segment:4;                  ///< Segment
} EXT_PCI_ADDR;

/// Union type for PCI address
typedef union _PCI_ADDR {
  IN  UINT32          AddressValue;               ///< Formal address
  IN  EXT_PCI_ADDR    Address;                    ///< Extended address
} PCI_ADDR;

//   SBDFO - Segment Bus Device Function Offset
//   31:28   Segment (4-bits)
//   27:20   Bus     (8-bits)
//   19:15   Device  (5-bits)
//   14:12   Function(3-bits)
//   11:00   Offset  (12-bits)

#define MAKE_SBDFO(Seg, Bus, Dev, Fun, Off) ((((UINT32) (Seg)) << 28) | (((UINT32) (Bus)) << 20) | \
                   (((UINT32)(Dev)) << 15) | (((UINT32)(Fun)) << 12) | ((UINT32)(Off)))
#define ILLEGAL_SBDFO 0xFFFFFFFF

/// CPUID data received registers format
typedef struct {
  OUT UINT32          EAX_Reg;                    ///< CPUID instruction result in EAX
  OUT UINT32          EBX_Reg;                    ///< CPUID instruction result in EBX
  OUT UINT32          ECX_Reg;                    ///< CPUID instruction result in ECX
  OUT UINT32          EDX_Reg;                    ///< CPUID instruction result in EDX
} CPUID_DATA;

/// HT frequency for external callbacks
typedef enum {
  HT_FREQUENCY_200M          = 0,                 ///< HT speed 200 for external callbacks
  HT_FREQUENCY_400M          = 2,                 ///< HT speed 400 for external callbacks
  HT_FREQUENCY_600M          = 4,                 ///< HT speed 600 for external callbacks
  HT_FREQUENCY_800M          = 5,                 ///< HT speed 800 for external callbacks
  HT_FREQUENCY_1000M         = 6,                 ///< HT speed 1000 for external callbacks
  HT_FREQUENCY_1200M         = 7,                 ///< HT speed 1200 for external callbacks
  HT_FREQUENCY_1400M         = 8,                 ///< HT speed 1400 for external callbacks
  HT_FREQUENCY_1600M         = 9,                 ///< HT speed 1600 for external callbacks
  HT_FREQUENCY_1800M         = 10,                ///< HT speed 1800 for external callbacks
  HT_FREQUENCY_2000M         = 11,                ///< HT speed 2000 for external callbacks
  HT_FREQUENCY_2200M         = 12,                ///< HT speed 2200 for external callbacks
  HT_FREQUENCY_2400M         = 13,                ///< HT speed 2400 for external callbacks
  HT_FREQUENCY_2600M         = 14,                ///< HT speed 2600 for external callbacks
  HT_FREQUENCY_2800M         = 17,                ///< HT speed 2800 for external callbacks
  HT_FREQUENCY_3000M         = 18,                ///< HT speed 3000 for external callbacks
  HT_FREQUENCY_3200M         = 19,                ///< HT speed 3200 for external callbacks
  HT_FREQUENCY_MAX                                ///< Limit check.
} HT_FREQUENCIES;
// The minimum HT3 frequency
#define HT3_FREQUENCY_MIN HT_FREQUENCY_1200M

#ifndef BIT0
  #define BIT0        0x0000000000000001ull
#endif
# 292 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT1
  #define BIT1        0x0000000000000002ull
#endif
# 295 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT2
  #define BIT2        0x0000000000000004ull
#endif
# 298 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT3
  #define BIT3        0x0000000000000008ull
#endif
# 301 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT4
  #define BIT4        0x0000000000000010ull
#endif
# 304 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT5
  #define BIT5        0x0000000000000020ull
#endif
# 307 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT6
  #define BIT6        0x0000000000000040ull
#endif
# 310 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT7
  #define BIT7        0x0000000000000080ull
#endif
# 313 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT8
  #define BIT8        0x0000000000000100ull
#endif
# 316 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT9
  #define BIT9        0x0000000000000200ull
#endif
# 319 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT10
  #define BIT10       0x0000000000000400ull
#endif
# 322 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT11
  #define BIT11       0x0000000000000800ull
#endif
# 325 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT12
  #define BIT12       0x0000000000001000ull
#endif
# 328 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT13
  #define BIT13       0x0000000000002000ull
#endif
# 331 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT14
  #define BIT14       0x0000000000004000ull
#endif
# 334 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT15
  #define BIT15       0x0000000000008000ull
#endif
# 337 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT16
  #define BIT16       0x0000000000010000ull
#endif
# 340 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT17
  #define BIT17       0x0000000000020000ull
#endif
# 343 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT18
  #define BIT18       0x0000000000040000ull
#endif
# 346 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT19
  #define BIT19       0x0000000000080000ull
#endif
# 349 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT20
  #define BIT20       0x0000000000100000ull
#endif
# 352 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT21
  #define BIT21       0x0000000000200000ull
#endif
# 355 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT22
  #define BIT22       0x0000000000400000ull
#endif
# 358 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT23
  #define BIT23       0x0000000000800000ull
#endif
# 361 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT24
  #define BIT24       0x0000000001000000ull
#endif
# 364 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT25
  #define BIT25       0x0000000002000000ull
#endif
# 367 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT26
  #define BIT26       0x0000000004000000ull
#endif
# 370 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT27
  #define BIT27       0x0000000008000000ull
#endif
# 373 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT28
  #define BIT28       0x0000000010000000ull
#endif
# 376 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT29
  #define BIT29       0x0000000020000000ull
#endif
# 379 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT30
  #define BIT30       0x0000000040000000ull
#endif
# 382 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT31
  #define BIT31       0x0000000080000000ull
#endif
# 385 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT32
  #define BIT32       0x0000000100000000ull
#endif
# 388 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT33
  #define BIT33       0x0000000200000000ull
#endif
# 391 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT34
  #define BIT34       0x0000000400000000ull
#endif
# 394 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT35
  #define BIT35       0x0000000800000000ull
#endif
# 397 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT36
  #define BIT36       0x0000001000000000ull
#endif
# 400 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT37
  #define BIT37       0x0000002000000000ull
#endif
# 403 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT38
  #define BIT38       0x0000004000000000ull
#endif
# 406 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT39
  #define BIT39       0x0000008000000000ull
#endif
# 409 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT40
  #define BIT40       0x0000010000000000ull
#endif
# 412 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT41
  #define BIT41       0x0000020000000000ull
#endif
# 415 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT42
  #define BIT42       0x0000040000000000ull
#endif
# 418 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT43
  #define BIT43       0x0000080000000000ull
#endif
# 421 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT44
  #define BIT44       0x0000100000000000ull
#endif
# 424 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT45
  #define BIT45       0x0000200000000000ull
#endif
# 427 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT46
  #define BIT46       0x0000400000000000ull
#endif
# 430 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT47
  #define BIT47       0x0000800000000000ull
#endif
# 433 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT48
  #define BIT48       0x0001000000000000ull
#endif
# 436 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT49
  #define BIT49       0x0002000000000000ull
#endif
# 439 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT50
  #define BIT50       0x0004000000000000ull
#endif
# 442 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT51
  #define BIT51       0x0008000000000000ull
#endif
# 445 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT52
  #define BIT52       0x0010000000000000ull
#endif
# 448 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT53
  #define BIT53       0x0020000000000000ull
#endif
# 451 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT54
  #define BIT54       0x0040000000000000ull
#endif
# 454 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT55
  #define BIT55       0x0080000000000000ull
#endif
# 457 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT56
  #define BIT56       0x0100000000000000ull
#endif
# 460 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT57
  #define BIT57       0x0200000000000000ull
#endif
# 463 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT58
  #define BIT58       0x0400000000000000ull
#endif
# 466 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT59
  #define BIT59       0x0800000000000000ull
#endif
# 469 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT60
  #define BIT60       0x1000000000000000ull
#endif
# 472 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT61
  #define BIT61       0x2000000000000000ull
#endif
# 475 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT62
  #define BIT62       0x4000000000000000ull
#endif
# 478 "src/vendorcode/amd/agesa/f14/AMD.h"
#ifndef BIT63
  #define BIT63       0x8000000000000000ull
#endif
# 481 "src/vendorcode/amd/agesa/f14/AMD.h"

#endif // _AMD_H_
# 483 "src/vendorcode/amd/agesa/f14/AMD.h"
# 52 "src/vendorcode/amd/agesa/f14/AGESA.h" 2

//
//
// AGESA Types and Definitions
//
//

// AGESA BASIC CALLOUTS
#define AGESA_MEM_RELEASE              0x00028000

// AGESA ADVANCED CALLOUTS, Processor
#define AGESA_CHECK_UMA                0x00028100
#define AGESA_DO_RESET                 0x00028101
#define AGESA_ALLOCATE_BUFFER          0x00028102
#define AGESA_DEALLOCATE_BUFFER        0x00028103
#define AGESA_LOCATE_BUFFER            0x00028104
#define AGESA_RUNFUNC_ONAP             0x00028105

// AGESA ADVANCED CALLOUTS, HyperTransport

// AGESA ADVANCED CALLOUTS, Memory
#define AGESA_READ_SPD                 0x00028140
#define AGESA_HOOKBEFORE_DRAM_INIT     0x00028141
#define AGESA_HOOKBEFORE_DQS_TRAINING  0x00028142
#define AGESA_READ_SPD_RECOVERY        0x00028143
#define AGESA_HOOKBEFORE_EXIT_SELF_REF 0x00028144
#define AGESA_HOOKBEFORE_DRAM_INIT_RECOVERY     0x00028145

// AGESA IDS CALLOUTS
#define AGESA_GET_IDS_INIT_DATA       0x00028200

// AGESA GNB CALLOUTS
#define AGESA_GNB_PCIE_SLOT_RESET      0x00028301

//------------------------------------------------------------------------
//
// HyperTransport Interface



//-----------------------------------------------------------------------------
//                         HT DEFINITIONS AND MACROS
//
//-----------------------------------------------------------------------------


// Width equates for call backs
#define HT_WIDTH_8_BITS              8                          ///< Specifies 8 bit, or up to 8 bit widths.
#define HT_WIDTH_16_BITS             16                         ///< Specifies 16 bit, or up to 16 bit widths.
#define HT_WIDTH_4_BITS              4
#define HT_WIDTH_2_BITS              2
#define HT_WIDTH_NO_LIMIT            HT_WIDTH_16_BITS

// Frequency Limit equates for call backs which take a frequency supported mask.
#define HT_FREQUENCY_LIMIT_200M      1                           ///< Specifies a limit of no more than 200 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_400M      7                           ///< Specifies a limit of no more than 400 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_600M      0x1F                        ///< Specifies a limit of no more than 600 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_800M      0x3F                        ///< Specifies a limit of no more than 800 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_1000M     0x7F                        ///< Specifies a limit of no more than 1000 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_HT1_ONLY  0x7F                        ///< Specifies a limit of no more than 1000 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_1200M     0xFF                        ///< Specifies a limit of no more than 1200 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_1400M     0x1FF                       ///< Specifies a limit of no more than 1400 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_1600M     0x3FF                       ///< Specifies a limit of no more than 1600 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_1800M     0x7FF                       ///< Specifies a limit of no more than 1800 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_2000M     0xFFF                       ///< Specifies a limit of no more than 2000 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_2200M     0x1FFF                      ///< Specifies a limit of no more than 2200 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_2400M     0x3FFF                      ///< Specifies a limit of no more than 2400 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_2600M     0x7FFF                      ///< Specifies a limit of no more than 2600 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_2800M     0x27FFF                     ///< Specifies a limit of no more than 2800 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_3000M     0x67FFF                     ///< Specifies a limit of no more than 3000 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_3200M     0xE7FFF                     ///< Specifies a limit of no more than 3200 MHz HT frequency.
#define HT_FREQUENCY_LIMIT_3600M     0x1E7FFF
#define HT_FREQUENCY_LIMIT_MAX       HT_FREQUENCY_LIMIT_3600M
#define HT_FREQUENCY_NO_LIMIT        0xFFFFFFFF                  ///< Specifies a no limit of HT frequency.

// Unit ID Clumping special values
#define HT_CLUMPING_DISABLE          0x00000000
#define HT_CLUMPING_NO_LIMIT         0xFFFFFFFF

#define HT_LIST_TERMINAL             0xFF             ///< End of list.
#define HT_LIST_MATCH_ANY            0xFE             ///< Match Any value, used for Sockets, Links, IO Chain Depth.
#define HT_LIST_MATCH_INTERNAL_LINK  0xFD             ///< Match all of the internal links.

// Event Notify definitions

// Event definitions.

// Coherent subfunction events
#define HT_EVENT_COH_EVENTS             0x10001000
#define HT_EVENT_COH_NO_TOPOLOGY        0x10011000    ///< See ::HT_EVENT_DATA_COH_NO_TOPOLOGY.
#define HT_EVENT_COH_OBSOLETE000        0x10021000    //   No longer used.
#define HT_EVENT_COH_PROCESSOR_TYPE_MIX 0x10031000    ///< See ::HT_EVENT_DATA_COH_PROCESSOR_TYPE_MIX.
#define HT_EVENT_COH_NODE_DISCOVERED    0x10041000    ///< See ::HT_EVENT_COH_NODE_DISCOVERED.
#define HT_EVENT_COH_MPCAP_MISMATCH     0x10051000    ///< See ::HT_EVENT_COH_MPCAP_MISMATCH.

// Non-coherent subfunction events
#define HT_EVENT_NCOH_EVENTS         0x10002000
#define HT_EVENT_NCOH_BUID_EXCEED    0x10012000       ///< See ::HT_EVENT_DATA_NCOH_BUID_EXCEED
#define HT_EVENT_NCOH_OBSOLETE000    0x10022000       //   No longer used.
#define HT_EVENT_NCOH_BUS_MAX_EXCEED 0x10032000       ///< See ::HT_EVENT_DATA_NCOH_BUS_MAX_EXCEED.
#define HT_EVENT_NCOH_CFG_MAP_EXCEED 0x10042000       ///< See ::HT_EVENT_DATA_NCOH_CFG_MAP_EXCEED.
#define HT_EVENT_NCOH_DEVICE_FAILED  0x10052000       ///< See ::HT_EVENT_DATA_NCOH_DEVICE_FAILED
#define HT_EVENT_NCOH_AUTO_DEPTH     0x10062000       ///< See ::HT_EVENT_NCOH_AUTO_DEPTH

// Optimization subfunction events
#define HT_EVENT_OPT_EVENTS               0x10003000
#define HT_EVENT_OPT_REQUIRED_CAP_RETRY   0x10013000  ///< See ::HT_EVENT_DATA_OPT_REQUIRED_CAP.
#define HT_EVENT_OPT_REQUIRED_CAP_GEN3    0x10023000  ///< See ::HT_EVENT_DATA_OPT_REQUIRED_CAP.
#define HT_EVENT_OPT_UNUSED_LINKS         0x10033000  ///< See ::HT_EVENT_DATA_OPT_UNUSED_LINKS.
#define HT_EVENT_OPT_LINK_PAIR_EXCEED     0x10043000  ///< See ::HT_EVENT_DATA_OPT_LINK_PAIR_EXCEED.

// HW Fault events
#define HT_EVENT_HW_EVENTS           0x10004000
#define HT_EVENT_HW_SYNCFLOOD        0x10014000       ///< See ::HT_EVENT_DATA_HW_SYNCFLOOD.
#define HT_EVENT_HW_HTCRC            0x10024000       ///< See ::HT_EVENT_DATA_HW_HT_CRC.

// The Recovery HT component uses 0x10005000 for events.
// For consistency, we avoid that range here.

#define HT_MAX_NC_BUIDS 32
//----------------------------------------------------------------------------
//                         HT TYPEDEFS, STRUCTURES, ENUMS
//
//----------------------------------------------------------------------------

/// Specify the state redundant links are to be left in after match.
///
/// After matching a link for IGNORE_LINK or SKIP_REGANG, the link may be left alone,
/// or powered off.

typedef enum {
  MATCHED,                               ///< The link matches the requested customization.
                                         ///< When used with IGNORE_LINK,
                                         ///< this will generally require other software to initialize the link.
                                         ///< When used with SKIP_REGANG,
                                         ///< the two unganged links will be available for distribution.

  POWERED_OFF,                           ///< Power the link off.  Support may vary based on processor model.
                                         ///< Power Off is only supported for coherent links.
                                         ///< Link power off may occur at a warm reset rather than immediately.
                                         ///< When used with SKIP_REGANG, the paired sublink is powered off, not the matching link.

  UNMATCHED,                             ///< The link should be processed according to normal defaults.
                                         ///< Effectively, the link does not match the requested customization.
                                         ///< This can be used to exclude links from a following match any.

  MaxFinalLinkState                      ///< Not a final link state, use for limit checking.
} FINAL_LINK_STATE;

/// Swap a device from its current id to a new one.

typedef struct {
  IN       UINT8 FromId;                 ///< The device responding to FromId,
  IN       UINT8 ToId;                   ///< will be moved to ToId.
} BUID_SWAP_ITEM;


/// Each Non-coherent chain may have a list of device swaps.  After performing the swaps,
/// the final in order list of device ids is provided. (There can be more swaps than devices.)
/// The unused entries in both are filled with 0xFF.

typedef struct {
  IN       BUID_SWAP_ITEM Swaps[HT_MAX_NC_BUIDS]; ///< The BUID Swaps to perform
  IN       UINT8 FinalIds[HT_MAX_NC_BUIDS];       ///< The ordered final BUIDs, resulting from the swaps
} BUID_SWAP_LIST;


/// Control Manual Initialization of Non-Coherent Chains
///
/// This interface is checked every time a non-coherent chain is
/// processed.  BUID assignment may be controlled explicitly on a
/// non-coherent chain. Provide a swap list.  Swaps controls the
/// BUID assignment and FinalIds provides the device to device
/// Linking.  Device orientation can be detected automatically, or
/// explicitly.  See interface documentation for more details.
///
/// If a manual swap list is not supplied,
/// automatic non-coherent init assigns BUIDs starting at 1 and incrementing sequentially
/// based on each device's unit count.

typedef struct {
  // Match fields
  IN       UINT8 Socket;                       ///< The Socket on which this chain is located
  IN       UINT8 Link;                         ///< The Link on the host for this chain
  // Override fields
  IN       BUID_SWAP_LIST SwapList;            ///< The swap list
} MANUAL_BUID_SWAP_LIST;


/// Override options for DEVICE_CAP_OVERRIDE.
///
/// Specify which override actions should be performed.  For Checks, 1 means to check the item
/// and 0 means to skip the check.  For the override options, 1 means to apply the override and
/// 0 means to ignore the override.

typedef struct {
  IN       UINT32  IsCheckDevVenId:1;     ///< Check Match on Device/Vendor id
  IN       UINT32  IsCheckRevision:1;     ///< Check Match on device Revision
  IN       UINT32  IsOverrideWidthIn:1;   ///< Override Width In
  IN       UINT32  IsOverrideWidthOut:1;  ///< Override Width Out
  IN       UINT32  IsOverrideFreq:1;      ///< Override Frequency
  IN       UINT32  IsOverrideClumping:1;  ///< Override Clumping
  IN       UINT32  IsDoCallout:1;         ///< Make the optional callout
} DEVICE_CAP_OVERRIDE_OPTIONS;

/// Override capabilities of a device.
///
/// This interface is checked once for every Link on every IO device.
/// Provide the width and frequency capability if needed for this device.
/// This is used along with device capabilities, the limit interfaces, and northbridge
/// limits to compute the default settings.  The components of the device's PCI config
/// address are provided, so its settings can be consulted if need be.
/// The optional callout is a catch all.

typedef struct {
  // Match fields
  IN       UINT8 HostSocket;           ///< The Socket on which this chain is located.
  IN       UINT8 HostLink;             ///< The Link on the host for this chain.
  IN       UINT8 Depth;                ///< The Depth in the I/O chain from the Host.
  IN       UINT32 DevVenId;            ///< The Device's PCI Vendor + Device ID (offset 0x00).
  IN       UINT8 Revision;             ///< The Device's PCI Revision field (offset 0x08).
  IN       UINT8 Link;                 ///< The Device's Link number (0 or 1).
  IN       DEVICE_CAP_OVERRIDE_OPTIONS Options; ///< The options for this device override.
  // Override fields
  IN       UINT8 LinkWidthIn;          ///< modify to change the Link Width In.
  IN       UINT8 LinkWidthOut;         ///< modify to change the Link Width Out.
  IN       UINT32 FreqCap;             ///< modify to change the Link's frequency capability.
  IN       UINT32 Clumping;            ///< modify to change Unit ID clumping support.
  IN       CALLOUT_ENTRY Callout;      ///< optional call for really complex cases, or NULL.
} DEVICE_CAP_OVERRIDE;

/// Callout param struct for override capabilities of a device.
///
/// If the optional callout is implemented this param struct is passed to it.

typedef struct {
  IN       AMD_CONFIG_PARAMS StdHeader; ///< Standard configuration header
  // Match fields
  IN       UINT8 HostSocket;           ///< The Socket on which this chain is located.
  IN       UINT8 HostLink;             ///< The Link on the host for this chain.
  IN       UINT8 Depth;                ///< The Depth in the I/O chain from the Host.
  IN       UINT32 DevVenId;            ///< The Device's PCI Vendor + Device ID (offset 0x00).
  IN       UINT8 Revision;             ///< The Device's PCI Revision field (offset 0x08).
  IN       UINT8 Link;                 ///< The Device's Link number (0 or 1).
  IN       PCI_ADDR PciAddress;        ///< The Device's PCI Address.
  // Override fields
     OUT   UINT8 *LinkWidthIn;          ///< modify to change the Link Width In.
     OUT   UINT8 *LinkWidthOut;         ///< modify to change the Link Width Out.
     OUT   UINT32 *FreqCap;             ///< modify to change the Link's frequency capability.
     OUT   UINT32 *Clumping;            ///< modify to change Unit ID clumping support.
} DEVICE_CAP_CALLOUT_PARAMS;

///  Limits for CPU to CPU Links.
///
///  For each coherent connection this interface is checked once.
///  Provide the frequency and width if needed for this Link (usually based on board
///  restriction).  This is used with CPU device capabilities and northbridge limits
///  to compute the default settings.

typedef struct {
  // Match fields
  IN       UINT8 SocketA;                ///< One Socket on which this Link is located
  IN       UINT8 LinkA;                  ///< The Link on this Node
  IN       UINT8 SocketB;                ///< The other Socket on which this Link is located
  IN       UINT8 LinkB;                  ///< The Link on that Node
  // Limit fields
  IN       UINT8 ABLinkWidthLimit;       ///< modify to change the Link Width A->B
  IN       UINT8 BALinkWidthLimit;       ///< modify to change the Link Width B-<A
  IN       UINT32 PcbFreqCap;            ///< modify to change the Link's frequency capability
} CPU_TO_CPU_PCB_LIMITS;

///  Get limits for non-coherent Links.
///
/// For each non-coherent connection this interface is checked once.
/// Provide the frequency and width if needed for this Link (usually based on board
/// restriction).  This is used with device capabilities, device overrides, and northbridge limits
/// to compute the default settings.
///
typedef struct {
  // Match fields
  IN       UINT8 HostSocket;               ///< The Socket on which this Link is located
  IN       UINT8 HostLink;                 ///< The Link about to be initialized
  IN       UINT8 Depth;                    ///< The Depth in the I/O chain from the Host
  // Limit fields
  IN       UINT8 DownstreamLinkWidthLimit; ///< modify to change the Link Width going away from processor
  IN       UINT8 UpstreamLinkWidthLimit;   ///< modify to change the Link Width moving toward processor
  IN       UINT32 PcbFreqCap;              ///< modify to change the Link's frequency capability
} IO_PCB_LIMITS;

///  Manually control bus number assignment.
///
/// This interface is checked every time a non-coherent chain is processed.
/// If a system can not use the auto Bus numbering feature for non-coherent chain bus
/// assignments, this interface can provide explicit control.  For each chain, provide
/// the bus number range to use.

typedef struct {
  // Match fields
  IN       UINT8 Socket;                 ///< The Socket on which this chain is located
  IN       UINT8 Link;                   ///< The Link on the host for this chain
  // Override fields
  IN       UINT8 SecBus;                 ///< Secondary Bus number for this non-coherent chain
  IN       UINT8 SubBus;                 ///< Subordinate Bus number
} OVERRIDE_BUS_NUMBERS;


///  Ignore a Link.
///
///  This interface is checked every time a coherent Link is found and then every
///  time a non-coherent Link from a CPU is found.
///  Any coherent or non-coherent Link from a CPU can be ignored and not used
///  for discovery or initialization.  Useful for connection based systems.
///  (Note: not checked for IO device to IO Device Links.)
///  (Note: not usable for internal links (MCM processors).)

typedef struct {
  // Match fields
  IN       UINT8 Socket;                 ///< The Socket on which this Link is located
  IN       UINT8 Link;                   ///< The Link about to be initialized
  // Customization fields
  IN       FINAL_LINK_STATE LinkState;   ///< The link may be left unitialized, or powered off.
} IGNORE_LINK;


///  Skip reganging of subLinks.
///
///  This interface is checked whenever two subLinks are both connected to the same CPUs.
///  Normally, unganged sublinks between the same two CPUs are reganged.
///  Provide a matching structure to leave the Links unganged.

typedef struct {
  // Match fields
  IN       UINT8 SocketA;                ///< One Socket on which this Link is located
  IN       UINT8 LinkA;                  ///< The Link on this Node
  IN       UINT8 SocketB;                ///< The other Socket on which this Link is located
  IN       UINT8 LinkB;                  ///< The Link on that Node
  // Customization fields
  IN       FINAL_LINK_STATE LinkState;   ///< The paired sublink may be active, or powered off.
} SKIP_REGANG;

///  The System Socket layout, which sockets are physically connected.
///
///  The hardware method for Socket naming is preferred.  Use this software method only
///  if required.

typedef struct {
  IN       UINT8 CurrentSocket;    ///< The socket from which this connection originates.
  IN       UINT8 CurrentLink;      ///< The Link from the source socket connects to another socket.
  IN       UINT8 TargetSocket;     ///< The target socket which is connected on that link.
} SYSTEM_PHYSICAL_SOCKET_MAP;

//----------------------------------------------------------------------------
///
/// This is the input structure for AmdHtInitialize.
///
typedef struct {
  // Basic level customization
  IN       UINT8 AutoBusStart;           ///< For automatic bus number assignment, starting bus number - usually zero.
                                         ///< @BldCfgItem{BLDCFG_STARTING_BUSNUM}
  IN       UINT8 AutoBusMax;             ///< For automatic bus number assignment, do not assign above max.
                                         ///< @BldCfgItem{BLDCFG_MAXIMUM_BUSNUM}
  IN       UINT8 AutoBusIncrement;       ///< For automatic bus number assignment, each chain gets this many busses.
                                         ///< @BldCfgItem{BLDCFG_ALLOCATED_BUSNUMS}

  // Advanced Level Customization
  IN       MANUAL_BUID_SWAP_LIST *ManualBuidSwapList;     ///< Provide Manual Swap List, if any.
                                                          ///< @BldCfgItem{BLDCFG_BUID_SWAP_LIST}
  IN       DEVICE_CAP_OVERRIDE *DeviceCapOverrideList;    ///< Provide Device Overrides, if any.
                                                          ///< @BldCfgItem{BLDCFG_HTDEVICE_CAPABILITIES_OVERRIDE_LIST}
  IN       CPU_TO_CPU_PCB_LIMITS *CpuToCpuPcbLimitsList;   ///< Provide CPU PCB Limits, if any.
                                                          ///< @BldCfgItem{BLDCFG_HTFABRIC_LIMITS_LIST}.
                                                          ///< @n @e Examples: See @ref FrequencyLimitExamples "Frequency Limit Examples".
  IN       IO_PCB_LIMITS *IoPcbLimitsList;                ///< Provide IO PCB Limits, if any.
                                                          ///< @BldCfgItem{BLDCFG_HTCHAIN_LIMITS_LIST}.
                                                          ///< @n @e Examples: See @ref FrequencyLimitExamples "Frequency Limit Examples".
  IN       OVERRIDE_BUS_NUMBERS *OverrideBusNumbersList;  ///< Provide manual Bus Number assignment, if any.
                                                          ///< Use either auto bus numbering or override bus
                                                          ///< numbers, not both.
                                                          ///< @BldCfgItem{BLDCFG_BUS_NUMBERS_LIST}

  IN       IGNORE_LINK *IgnoreLinkList;                   ///< Provide links to ignore, if any.
                                                          ///< @BldCfgItem{BLDCFG_IGNORE_LINK_LIST}
  IN       SKIP_REGANG *SkipRegangList;                   ///< Provide links to remain unganged, if any.
                                                          ///< @BldCfgItem{BLDCFG_LINK_SKIP_REGANG_LIST}
                                                          ///< @n @e Examples: See @ref PerfPerWattHt "Performance-per-watt Optimization".

  // Expert Level Customization
  IN       UINT8 **Topolist;                         ///< Use this topology list in addition to the built in, if not NULL.
                                                     ///< @BldCfgItem{BLDCFG_ADDITIONAL_TOPOLOGIES_LIST}
  IN       SYSTEM_PHYSICAL_SOCKET_MAP *SystemPhysicalSocketMap;
                                                     ///< The hardware socket naming method is preferred,
                                                     ///<  If it can't be used, this provides a software method.
                                                     ///< @BldCfgItem{BLDCFG_SYSTEM_PHYSICAL_SOCKET_MAP}
} AMD_HT_INTERFACE;

//-----------------------------------------------------------------------------
//
// HT Recovery Interface
//


/*-----------------------------------------------------------------------------
 *              HT Recovery DEFINITIONS AND MACROS
 *
 *-----------------------------------------------------------------------------
 */

// BBHT subfunction events
#define HT_EVENT_BB_EVENTS         0x10005000
#define HT_EVENT_BB_BUID_EXCEED    0x10015000
#define HT_EVENT_BB_DEVICE_FAILED  0x10055000
#define HT_EVENT_BB_AUTO_DEPTH     0x10065000

/*----------------------------------------------------------------------------
 *                      HT Recovery   TYPEDEFS, STRUCTURES, ENUMS
 *
 *----------------------------------------------------------------------------
 */


/// The Interface structure to Recovery HT.

typedef struct {
  IN       MANUAL_BUID_SWAP_LIST *ManualBuidSwapList;  ///< Option to manually control SB link init
                                                       ///< @BldCfgItem{BLDCFG_BUID_SWAP_LIST}
     OUT   UINT32 Depth;           ///< If auto init was used this is set to the depth of the chain,
                                   ///< else, for manual init unmodified.
} AMD_HT_RESET_INTERFACE;

/*----------------------------------------------------------------------------
 *   CPU Feature related info
 *----------------------------------------------------------------------------
 */

/// Build Configuration values for BLDCFG_PLATFORM_C1E_MODE
typedef enum {
  C1eModeDisabled                   = 0,   ///< Disabled
  C1eModeHardware                   = 1,   ///< Hardware method
  C1eModeMsgBased                   = 2,   ///< Message-based method
  C1eModeSoftwareDeprecated         = 3,   ///< Deprecated software SMI method.
                                           ///< Refer to "Addendum\Examples\C1eSMMHandler.asm" for
                                           ///< example host BIOS SMM Handler implementation
  C1eModeHardwareSoftwareDeprecated = 4,   ///< Hardware or deprecated software SMI method
  MaxC1eMode                        = 5    ///< Not a valid value, used for verifying input
} PLATFORM_C1E_MODES;

/// Build Configuration values for BLDCFG_PLATFORM_CSTATE_MODE
typedef enum {
  CStateModeDisabled = 0,           ///< Disabled
  CStateModeC6       = 1,           ///< C6 State
  MaxCStateMode      = 2            ///< Not a valid value, used for verifying input
} PLATFORM_CSTATE_MODES;

/// Build Configuration values for BLDCFG_PLATFORM_CPB_MODE
typedef enum {
  CpbModeAuto     = 0,           ///< Auto
  CpbModeDisabled = 1,           ///< Disabled
  MaxCpbMode      = 2            ///< Not a valid value, used for verifying input
} PLATFORM_CPB_MODES;

/*----------------------------------------------------------------------------
 *   GNB PCIe configuration info
 *----------------------------------------------------------------------------
 */

// Event definitions


#define GNB_EVENT_INVALID_CONFIGURATION               0x20010000   // User configuration invalid
#define GNB_EVENT_INVALID_PCIE_TOPOLOGY_CONFIGURATION 0x20010001   // Requested lane allocation for PCIe port can not be supported
#define GNB_EVENT_INVALID_PCIE_PORT_CONFIGURATION     0x20010002   // Requested incorrect PCIe port device address
#define GNB_EVENT_INVALID_DDI_LINK_CONFIGURATION      0x20010003   // Incorrect parameter in DDI link configuration
#define GNB_EVENT_INVALID_LINK_WIDTH_CONFIGURATION    0x20010004   // Invalid with for PCIe port or DDI link
#define GNB_EVENT_INVALID_LANES_CONFIGURATION         0x20010005   // Lane double subscribe lanes
#define GNB_EVENT_INVALID_DDI_TOPOLOGY_CONFIGURATION  0x20010006   // Requested lane allocation for DDI link(s) can not be supported
#define GNB_EVENT_LINK_TRAINING_FAIL                  0x20020000   // PCIe Link training fail
#define GNB_EVENT_BROKEN_LANE_RECOVERY                0x20030000   // Broken lane workaround applied to recover link training
#define GNB_EVENT_GEN2_SUPPORT_RECOVERY               0x20040000   // Scale back to GEN1 to recover link training


#define DESCRIPTOR_TERMINATE_LIST           0x80000000ull

/// PCIe port misc extended controls
typedef struct  {
  IN      UINT8                     LinkComplianceMode :1;  ///< Force port into compliance mode (device will not be trained, port output compliance pattern)
  IN      UINT8                     LinkSafeMode       :2;  /**< Safe mode PCIe capability. (Parameter may limit PCIe speed requested through PCIe_PORT_DATA::LinkSpeedCapability)
                                                             *  @li @b 0 - port can advertize muximum supported capability
                                                             *  @li @b 1 - port limit advertized capability and speed to PCIe Gen1
                                                             */
} PCIe_PORT_MISC_CONTROL;


/// PCIe port configuration data
typedef struct  {
  IN       UINT8                   PortPresent;              ///< Enable PCIe port for initialization.
  IN       UINT8                   ChannelType;              /**< Channel type.
                                                               *  @li @b 0 - "lowLoss",
                                                               *  @li @b 1 - "highLoss",
                                                               *  @li @b 2 - "mob0db",
                                                               *  @li @b 3 - "mob3db",
                                                               *  @li @b 4 - "extnd6db"
                                                               *  @li @b 5 - "extnd8db"
                                                               */
  IN       UINT8                   DeviceNumber;             /**< PCI Device number for port.
                                                               *   @li @b 0 - Native port device number
                                                               *   @li @b N - Port device number (See available configurations @ref F12LaneConfigurations "Family 0x12",  @ref F14LaneConfigurations "Family 0x14")
                                                               */
  IN       UINT8                   FunctionNumber;           ///< Reserved for future use
  IN       UINT8                   LinkSpeedCapability;      /**< PCIe link speed/
                                                               *  @li @b 0 - Maximum supported by silicon
                                                               *  @li @b 1 - Gen1
                                                               *  @li @b 2 - Gen2
                                                               *  @li @b 3 - Gen3
                                                               */
  IN       UINT8                   LinkAspm;                 /**< ASPM control. (see AgesaPcieLinkAspm for additional option to control ASPM)
                                                               *  @li @b 0 - Disabled
                                                               *  @li @b 1 - L0s only
                                                               *  @li @b 2 - L1 only
                                                               *  @li @b 3 - L0s and L1
                                                               */
  IN       UINT8                   LinkHotplug;              /**< Hotplug control.
                                                               *  @li @b 0 - Disabled
                                                               *  @li @b 1 - Basic
                                                               *  @li @b 2 - Server
                                                               *  @li @b 3 - Enhanced
                                                               */
  IN       UINT8                   ResetId;                  /**< Arbitrary number greater than 0 assigned by platform firmware for GPIO
                                                               *   identification which control reset for given port.
                                                               *   Each port with unique GPIO should have unique ResetId assigned.
                                                               *   All ports use same GPIO to control reset should have same ResetId assigned.
                                                               *   see AgesaPcieSlotResetContol.
                                                               */
  IN       PCIe_PORT_MISC_CONTROL  MiscControls;             ///< Misc extended controls
} PCIe_PORT_DATA;

/// DDI channel lane mapping
typedef struct {                                          ///< Structure that discribe lane mapping
  IN      UINT8              Lane0   :2;                  /**< Lane 0 mapping
                                                           *  @li @b 0 - Map to lane 0
                                                           *  @li @b 1 - Map to lane 1
                                                           *  @li @b 2 - Map to lane 2
                                                           *  @li @b 2 - Map to lane 3
                                                           */
  IN      UINT8              Lane1   :2;                  ///< Lane 1 mapping (see "Lane 0 mapping")
  IN      UINT8              Lane2   :2;                  ///< Lane 2 mapping (see "Lane 0 mapping")
  IN      UINT8              Lane3   :2;                  ///< Lane 3 mapping (see "Lane 0 mapping")
} CHANNEL_MAPPING;                                        ///< Lane mapping

/// Common Channel Mapping
typedef union {
  IN      UINT8                ChannelMappingValue;       ///< Raw lane mapping
  IN      CHANNEL_MAPPING      ChannelMapping;            ///< Channel mapping
} CONN_CHANNEL_MAPPING;

/// DDI Configuration data
typedef struct  {
  IN       UINT8                ConnectorType;            /**< Display Connector Type
                                                            *  @li @b 0 - DP
                                                            *  @li @b 1 - eDP
                                                            *  @li @b 2 - Single Link DVI-D
                                                            *  @li @b 3 - Dual  Link DVI-D (see @ref F12DualLinkDviDescription "Family 0x12 Dual Link DVI connector description")
                                                            *  @li @b 4 - HDMI
                                                            *  @li @b 5 - Travis DP-to-VGA
                                                            *  @li @b 6 - Travis DP-to-LVDS
                                                            *  @li @b 7 - Hudson-2 NutMeg DP-to-VGA
                                                            *  @li @b 8 - Single Link DVI-I
                                                            *  @li @b 9 - Native CRT (Family 0x14)
                                                            *  @li @b 10 - Native LVDS (Family 0x14)
                                                            *  @li @b 11 - Auto detect LCD panel connector type. VBIOS is able to auto detect the LVDS connector type: native LVDS, eDP or Travis-LVDS
                                                            *              The auto detection method only support panel with EDID.
                                                            */
  IN       UINT8                AuxIndex;                 /**< Indicates which AUX or DDC Line is used
                                                            *  @li @b 0 - AUX1
                                                            *  @li @b 1 - AUX2
                                                            *  @li @b 2 - AUX3
                                                            *  @li @b 3 - AUX4
                                                            *  @li @b 4 - AUX5
                                                            *  @li @b 5 - AUX6
                                                            */
  IN       UINT8                HdpIndex;                 /**< Indicates which HDP pin is used
                                                            *  @li @b 0 - HDP1
                                                            *  @li @b 1 - HDP2
                                                            *  @li @b 2 - HDP3
                                                            *  @li @b 3 - HDP4
                                                            *  @li @b 4 - HDP5
                                                            *  @li @b 5 - HDP6
                                                            */
  IN       CONN_CHANNEL_MAPPING Mapping[2];               /**< Set specific mapping of lanes to connector pins
                                                            *  @li Mapping[0] define mapping for group of 4 lanes starting at PCIe_ENGINE_DATA.StartLane
                                                            *  @li Mapping[1] define mapping for group of 4 lanes ending at PCIe_ENGINE_DATA.EndLane (only applicable for Dual DDI link)
                                                            *  if Mapping[x] set to 0 than default mapping assumed
                                                            */
} PCIe_DDI_DATA;

/// Engine Configuration
typedef struct {
  IN       UINT8                EngineType;               /**< Engine type
                                                           *  @li @b 0 -  Ignore engine configuration
                                                           *  @li @b 1 -  PCIe port
                                                           *  @li @b 2 -  DDI
                                                           */
  IN       UINT16               StartLane;                /**< Start Lane ID (in reversed configuration StartLane > EndLane)
                                                           * See lane description for @ref F12PcieLaneDescription "Family 0x12"
                                                           * @ref F14PcieLaneDescription "Family 0x14".
                                                           * See lane configurations for @ref F12LaneConfigurations "Family 0x12"
                                                           * @ref F14LaneConfigurations "Family 0x14".
                                                           */
  IN       UINT16               EndLane;                  /**< End lane ID (in reversed configuration StartLane > EndLane)
                                                           * See lane description for @ref F12PcieLaneDescription "Family 0x12",
                                                           * @ref F14PcieLaneDescription "Family 0x14".
                                                           * See lane configurations for @ref F12LaneConfigurations "Family 0x12"
                                                           * @ref F14LaneConfigurations "Family 0x14".
                                                           */

} PCIe_ENGINE_DATA;

/// PCIe port descriptor
typedef struct {
  IN       UINT32               Flags;                    /**< Descriptor flags
                                                           * @li @b Bit31 - last descriptor in complex
                                                           */
  IN       PCIe_ENGINE_DATA     EngineData;               ///< Engine data
  IN       PCIe_PORT_DATA       Port;                     ///< PCIe port specific configuration info
} PCIe_PORT_DESCRIPTOR;

/// DDI descriptor
typedef struct {
  IN       UINT32               Flags;                    /**< Descriptor flags
                                                           * @li @b Bit31 - last descriptor in complex
                                                           */
  IN       PCIe_ENGINE_DATA     EngineData;               ///< Engine data
  IN       PCIe_DDI_DATA        Ddi;                      ///< DDI port specific configuration info
} PCIe_DDI_DESCRIPTOR;

/// PCIe Complex descriptor
typedef struct {
  IN       UINT32               Flags;                    /**< Descriptor flags
                                                           * @li @b Bit31 - last descriptor in topology
                                                           */
  IN       UINT32               SocketId;                 ///< Socket Id
  IN       PCIe_PORT_DESCRIPTOR *PciePortList;            ///< Pointer to array of PCIe port descriptors or NULL (Last element of array must be terminated with DESCRIPTOR_TERMINATE_LIST).
  IN       PCIe_DDI_DESCRIPTOR  *DdiLinkList;             ///< Pointer to array DDI link descriptors (Last element of array must be terminated with DESCRIPTOR_TERMINATE_LIST).
  IN       VOID                 *Reserved;                ///< Reserved for future use
} PCIe_COMPLEX_DESCRIPTOR;

/// Action to control PCIe slot reset
typedef enum {
  AssertSlotReset,                                        ///< Assert slot reset
  DeassertSlotReset                                       ///< Deassert slot reset
} PCIE_RESET_CONTROL;

///Slot Reset Info
typedef struct {
  IN      AMD_CONFIG_PARAMS     StdHeader;                ///< Standard configuration header
  IN      UINT8                 ResetId;                  ///< Slot reset ID as specified in PCIe_PORT_DESCRIPTOR
  IN      UINT8                 ResetControl;             ///< Reset control as in PCIE_RESET_CONTROL
} PCIe_SLOT_RESET_INFO;

/// Engine descriptor type
typedef enum {
  PcieUnusedEngine = 0,                                   ///< Unused descriptor
  PciePortEngine = 1,                                     ///< PCIe port
  PcieDdiEngine = 2,                                      ///< DDI
  MaxPcieEngine                                           ///< Max engine type for boundary check.
} PCIE_ENGINE_TYPE;

/// PCIe link capability/speed
typedef enum  {
  PcieGenMaxSupported,                                    ///< Maximum supported
  PcieGen1 = 1,                                           ///< Gen1
  PcieGen2,                                               ///< Gen2
  MaxPcieGen                                              ///< Max Gen for boundary check
} PCIE_LINK_SPEED_CAP;

/// PCIe PSPP Power policy
typedef enum  {
  PsppDisabled,                                           ///< PSPP disabled
  PsppPerformance = 1,                                    ///< Performance
  PsppBalanceHigh,                                        ///< Balance-High
  PsppBalanceLow,                                         ///< Balance-Low
  PsppPowerSaving,                                        ///< Power Saving
  MaxPspp                                                 ///< Max Pspp for boundary check
} PCIE_PSPP_POLICY;

/// DDI display connector type
typedef enum {
  ConnectorTypeDP,                                        ///< DP
  ConnectorTypeEDP,                                       ///< eDP
  ConnectorTypeSingleLinkDVI,                             ///< Single Link DVI-D
  ConnectorTypeDualLinkDVI,                               ///< Dual  Link DVI-D
  ConnectorTypeHDMI,                                      ///< HDMI
  ConnectorTypeTravisDpToVga,                             ///< Travis DP-to-VGA
  ConnectorTypeTravisDpToLvds,                            ///< Travis DP-to-LVDS
  ConnectorTypeNutmegDpToVga,                             ///< Hudson-2 NutMeg DP-to-VGA
  ConnectorTypeSingleLinkDviI,                            ///< Single Link DVI-I
  ConnectorTypeCrt,                                       ///< CRT (VGA)
  ConnectorTypeLvds,                                      ///< LVDS
  ConnectorTypeAutoDetect,                                ///< VBIOS auto detect connector type (native LVDS, eDP or Travis-LVDS)
  MaxConnectorType                                        ///< Not valid value, used to verify input
} PCIE_CONNECTOR_TYPE;

/// PCIe link channel type
typedef enum {
  ChannelTypeLowLoss,                                     ///< Low Loss
  ChannelTypeHighLoss,                                    ///< High Loss
  ChannelTypeMob0db,                                      ///< Mobile 0dB
  ChannelTypeMob3db,                                      ///< Mobile 3dB
  ChannelTypeExt6db,                                      ///< Extended 6dB
  ChannelTypeExt8db,                                      ///< Extended 8dB
  MaxChannelType                                          ///< Not valid value, used to verify input
} PCIE_CHANNEL_TYPE;

/// PCIe link ASPM
typedef enum {
  AspmDisabled,                                           ///< Disabled
  AspmL0s,                                                ///< PCIe L0s link state
  AspmL1,                                                 ///< PCIe L1 link state
  AspmL0sL1,                                              ///< PCIe L0s & L1 link state
  MaxAspm                                                 ///< Not valid value, used to verify input
} PCIE_ASPM_TYPE;

/// PCIe link hotplug support
typedef enum {
  HotplugDisabled,                                        ///< Hotplug disable
  HotplugBasic,                                           ///< Basic Hotplug
  HotplugServer,                                          ///< Server Hotplug
  HotplugEnhanced,                                        ///< Enhanced
  HotplugInboard,                                         ///< Inboard
  MaxHotplug                                              ///< Not valid value, used to verify input
} PCIE_HOTPLUG_TYPE;

/// PCIe link initialization
typedef enum {
  PortDisabled,                                           ///< Disable
  PortEnabled                                             ///< Enable
} PCIE_PORT_ENABLE;

/// DDI Aux channel
typedef enum {
  Aux1,                                                   ///< Aux1
  Aux2,                                                   ///< Aux2
  Aux3,                                                   ///< Aux3
  Aux4,                                                   ///< Aux4
  Aux5,                                                   ///< Aux5
  Aux6,                                                   ///< Aux6
  MaxAux                                                  ///< Not valid value, used to verify input
} PCIE_AUX_TYPE;

/// DDI Hdp Index
typedef enum {
  Hdp1,                                                   ///< Hdp1
  Hdp2,                                                   ///< Hdp2
  Hdp3,                                                   ///< Hdp3
  Hdp4,                                                   ///< Hdp4
  Hdp5,                                                   ///< Hdp5
  Hdp6,                                                   ///< Hdp6
  MaxHdp                                                  ///< Not valid value, used to verify input
} PCIE_HDP_TYPE;

// Macro for statically initialization of various structures
#define  PCIE_ENGINE_DATA_INITIALIZER(mType, mStartLane, mEndLane) {mType, mStartLane, mEndLane}
#define  PCIE_PORT_DATA_INITIALIZER(mPortPresent, mChannelType, mDevAddress, mHotplug, mMaxLinkSpeed, mMaxLinkCap, mAspm, mResetId) \
{mPortPresent, mChannelType, mDevAddress, 0, mMaxLinkSpeed, mAspm, mHotplug, mResetId, {0, mMaxLinkCap} }
#define  PCIE_DDI_DATA_INITIALIZER(mConnectorType, mAuxIndex, mHpdIndex ) \
{mConnectorType, mAuxIndex, mHpdIndex, {{0}, {0}}}
#define  PCIE_DDI_DATA_INITIALIZER_V1(mConnectorType, mAuxIndex, mHpdIndex, mMapping0, mMapping1) \
{mConnectorType, mAuxIndex, mHpdIndex, {mMapping0, mMapping1}}


/*----------------------------------------------------------------------------
 *   GNB configuration info
 *----------------------------------------------------------------------------
 */

/// LVDS Misc Control Field
typedef struct {
  IN  UINT8     FpdiMode:1;          ///< This item configures LVDS 888bit panel mode
                                     ///< @li FALSE = LVDS 888 panel in LDI mode
                                     ///< @li TRUE =  LVDS 888 panel in FPDI mode
                                     ///< @BldCfgItem{BLDCFG_LVDS_MISC_888_FPDI_MODE}
  IN  UINT8     DlChSwap:1;          ///< This item configures LVDS panel lower and upper link mapping
                                     ///< @li FALSE = Lower link and upper link not swap
                                     ///< @li TRUE = Lower link and upper link are swapped
                                     ///< @BldCfgItem{BLDCFG_LVDS_MISC_DL_CH_SWAP}
  IN  UINT8     VsyncActiveLow:1;    ///< This item configures polarity of frame pulse encoded in lvds data stream
                                     ///< @li FALSE = Active high Frame Pulse/Vsync
                                     ///< @li TRUE = Active low Frame Pulse/Vsync
                                     ///< @BldCfgItem{BLDCFG_LVDS_MISC_VSYNC_ACTIVE_LOW}
  IN  UINT8     HsyncActiveLow:1;    ///< This item configures polarity of line pulse encoded in lvds data
                                     ///< @li FALSE = Active high Line Pulse
                                     ///< @li TRUE = Active low Line Pulse / Hsync
                                     ///< @BldCfgItem{BLDCFG_LVDS_MISC_HSYNC_ACTIVE_LOW}
  IN  UINT8     BLONActiveLow:1;     ///< This item configures polarity of signal sent to digital BLON output pin
                                     ///< @li FALSE = Not inverted(active high)
                                     ///< @li TRUE = Inverted (active low)
                                     ///< @BldCfgItem{BLDCFG_LVDS_MISC_BLON_ACTIVE_LOW}
  IN  UINT8     Reserved:3;          ///< Reserved
} LVDS_MISC_CONTROL_FIELD;

/// LVDS Misc Control
typedef union _LVDS_MISC_CONTROL {
  IN LVDS_MISC_CONTROL_FIELD Field;  ///< LVDS_MISC_CONTROL_FIELD
  IN UINT8   Value;                  ///< LVDS Misc Control Value
} LVDS_MISC_CONTROL;

/// Configuration settings for GNB.
typedef struct {
  IN  UINT8     Gnb3dStereoPinIndex;      ///< 3D Stereo Pin ID.
                                          ///< @li 0 = Stereo 3D is disabled (default).
                                          ///< @li 1 = Use processor pin HPD1.
                                          ///< @li 2 = Use processor pin HPD2
                                          ///< @li 3 = Use processor pin HPD3
                                          ///< @li 4 = Use processor pin HPD4
                                          ///< @li 5 = Use processor pin HPD5
                                          ///< @li 6 = Use processor pin HPD6
                                          ///< @BldCfgItem{BLDCFG_STEREO_3D_PINOUT}
  IN  UINT16     LvdsSpreadSpectrum;      ///< Spread spectrum value in 0.01 %
                                          ///< BldCfgItem{BLDCFG_GFX_LVDS_SPREAD_SPECTRUM}
  IN  UINT16     LvdsSpreadSpectrumRate;  ///< Spread spectrum frequency used by SS hardware logic in unit of 10Hz, 0 - default frequency 40kHz
                                          ///< BldCfgItem{BLDCFG_GFX_LVDS_SPREAD_SPECTRUM_RATE}
  IN  LVDS_MISC_CONTROL      LvdsMiscControl;///< This item configures LVDS swap/Hsync/Vsync/BLON
  IN  UINT16     PcieRefClkSpreadSpectrum;   ///< Spread spectrum value in 0.01 %
                                             ///< @BldCfgItem{BLDCFG_PCIE_REFCLK_SPREAD_SPECTRUM}
} GNB_ENV_CONFIGURATION;

/// GNB configuration info
typedef struct {
  IN       PCIe_COMPLEX_DESCRIPTOR  *PcieComplexList;  /**< Pointer to array of structures describe PCIe topology on each processor package or NULL.
                                                        * Last element of array must ne terminated with DESCRIPTOR_TERMINATE_LIST
                                                        * Example of topology definition for single socket system:
                                                        * @code
                                                        *  PCIe_PORT_DESCRIPTOR PortList [] = {
                                                        *    // Initialize Port descriptor (PCIe port, Lanes 8:15, PCI Device Number 2, ...)
                                                        *    {
                                                        *      0,   //Descriptor flags
                                                        *      PCIE_ENGINE_DATA_INITIALIZER (PciePortEngine, 8, 15),
                                                        *      PCIE_PORT_DATA_INITIALIZER (PortEnabled, ChannelTypeExt6db, 2, HotplugDisabled, PcieGenMaxSupported, PcieGenMaxSupported, AspmDisabled, 0)
                                                        *    },
                                                        *    // Initialize Port descriptor (PCIe port, Lanes 16:19, PCI Device Number 3, ...)
                                                        *    {
                                                        *      0,   //Descriptor flags
                                                        *      PCIE_ENGINE_DATA_INITIALIZER (PciePortEngine, 16, 19),
                                                        *      PCIE_PORT_DATA_INITIALIZER (PortEnabled, ChannelTypeExt6db, 3, HotplugDisabled, PcieGenMaxSupported, PcieGenMaxSupported, AspmDisabled, 0)
                                                        *    },
                                                        *    // Initialize Port descriptor (PCIe port, Lanes 4, PCI Device Number 4, ...)
                                                        *    {
                                                        *      DESCRIPTOR_TERMINATE_LIST, //Descriptor flags  !!!IMPORTANT!!! Terminate last element of array
                                                        *      PCIE_ENGINE_DATA_INITIALIZER (PciePortEngine, 4, 4),
                                                        *      PCIE_PORT_DATA_INITIALIZER (PortEnabled, ChannelTypeExt6db, 4, HotplugDisabled, PcieGenMaxSupported, PcieGenMaxSupported, AspmDisabled, 0)
                                                        *    }
                                                        *  };
                                                        *  PCIe_PORT_DESCRIPTOR DdiList [] = {
                                                        *    // Initialize Ddi descriptor (DDI interface Lanes 24:27, Display Port Connector, ...)
                                                        *    {
                                                        *      0,   //Descriptor flags
                                                        *      PCIE_ENGINE_DATA_INITIALIZER (PcieDdiEngine, 24, 27),
                                                        *      PCIE_DDI_DATA_INITIALIZER (ConnectorTypeDP, Aux1, Hdp1)
                                                        *    },
                                                        *    // Initialize Ddi descriptor (DDI interface Lanes 28:31, HDMI, ...)
                                                        *    {
                                                        *      DESCRIPTOR_TERMINATE_LIST, //Descriptor flags  !!!IMPORTANT!!! Terminate last element of array
                                                        *      PCIE_ENGINE_DATA_INITIALIZER (PcieDdiEngine, 28, 31),
                                                        *      PCIE_DDI_DATA_INITIALIZER (ConnectorTypeHDMI, Aux2, Hdp2)
                                                        *    }
                                                        *  };
                                                        * PCIe_COMPLEX_DESCRIPTOR PlatformTopology = {
                                                        *   DESCRIPTOR_TERMINATE_LIST, //Descriptor flags  !!!IMPORTANT!!! Terminate complexes list
                                                        *   0,  //Socket ID
                                                        *   &PortList[0],
                                                        *   &DdiList[0],
                                                        * }
                                                        * @endcode
                                                        */
  IN       UINT8                    PsppPolicy;         /**< PSPP (PCIe Speed Power Policy)
                                                         *  @li @b 0 - Disabled
                                                         *  @li @b 1 - Performance
                                                         *  @li @b 2 - Balance-High
                                                         *  @li @b 3 - Balance-Low
                                                         *  @li @b 4 - Power Saving
                                                         */

} GNB_CONFIGURATION;
//
//  MEMORY-SPECIFIC DATA STRUCTURES
//
//
//
//
// AGESA MAXIMIUM VALUES
//
//   These Max values are used to define array sizes and associated loop
//   counts in the code.  They reflect the maximum values that AGESA
//   currently supports and does not necessarily reflect the hardware
//   capabilities of configuration.
//

#define MAX_SOCKETS_SUPPORTED   8   ///< Max number of sockets in system
#define MAX_CHANNELS_PER_SOCKET 4   ///< Max Channels per sockets
#define MAX_DIMMS_PER_CHANNEL   4   ///< Max DIMMs on a memory channel (independent of platform)
#define NUMBER_OF_DELAY_TABLES  9   ///< Number of tables defined in CH_DEF_STRUCT.
                                    ///< Eg: UINT16  *RcvEnDlys;
                                    ///<     UINT8   *WrDqsDlys;
                                    ///<     UINT8   *RdDqsDlys;
                                    ///<     UINT8   *WrDatDlys;
                                    ///<     UINT8   *RdDqsMinDlys;
                                    ///<     UINT8   *RdDqsMaxDlys;
                                    ///<     UINT8   *WrDatMinDlys;
                                    ///<     UINT8   *WrDatMaxDlys;
#define NUMBER_OF_FAILURE_MASK_TABLES 1 ///< Number of failure mask tables

#define MAX_PLATFORM_TYPES     16   ///< Platform types per system

#define MCT_TRNG_KEEPOUT_START  0x00004000    ///< base [39:8]
#define MCT_TRNG_KEEPOUT_END    0x00007FFF    ///< base [39:8]

#define UMA_ATTRIBUTE_INTERLEAVE 0x80000000   ///< Uma Region is interleaved
#define UMA_ATTRIBUTE_ON_DCT0    0x40000000   ///< UMA resides on memory that belongs to DCT0
#define UMA_ATTRIBUTE_ON_DCT1    0x20000000   ///< UMA resides on memory that belongs to DCT1

typedef UINT8 PSO_TABLE;            ///< Platform Configuration Table

//        AGESA DEFINITIONS
//
//        Many of these are derived from the platform and hardware specific definitions

/// EccSymbolSize override value
#define ECCSYMBOLSIZE_USE_BKDG      0   ///< Use BKDG Recommended Value
#define ECCSYMBOLSIZE_FORCE_X4      4   ///< Force to x4
#define ECCSYMBOLSIZE_FORCE_X8      8   ///< Force to x8
/// CPU Package Type
#define PT_L1       0                 ///< L1 Package type
#define PT_M2       1                 ///< AM Package type
#define PT_S1       2                 ///< S1 Package type

/// Structures use to pass system Logical CPU-ID
typedef struct {
  IN OUT   UINT64 Family;             ///< Indicates logical ID Family
  IN OUT   UINT64 Revision;           ///< Indicates logical ID Family
} CPU_LOGICAL_ID;

/// Build Configuration values for BLDCFG_AMD_PLATFORM_TYPE
typedef enum {
  AMD_PLATFORM_SERVER = 0x8000,     ///< Server
  AMD_PLATFORM_DESKTOP = 0x10000,   ///< Desktop
  AMD_PLATFORM_MOBILE = 0x20000,    ///< Mobile
} AMD_PLATFORM_TYPE;

/// Dram technology type
typedef enum {
  DDR2_TECHNOLOGY,      ///< DDR2 technology
  DDR3_TECHNOLOGY       ///< DDR3 technology
} TECHNOLOGY_TYPE;

/// Build Configuration values for BLDCFG_MEMORY_BUS_FREQUENCY_LIMIT & BLDCFG_MEMORY_CLOCK_SELECT
typedef enum {
  DDR400_FREQUENCY = 200,     ///< DDR 400
  DDR533_FREQUENCY = 266,     ///< DDR 533
  DDR667_FREQUENCY = 333,     ///< DDR 667
  DDR800_FREQUENCY = 400,     ///< DDR 800
  DDR1066_FREQUENCY = 533,    ///< DDR 1066
  DDR1333_FREQUENCY = 667,    ///< DDR 1333
  DDR1600_FREQUENCY = 800,    ///< DDR 1600
  DDR1866_FREQUENCY = 933,    ///< DDR 1866
  UNSUPPORTED_DDR_FREQUENCY   ///< Highest limit of DDR frequency
} MEMORY_BUS_SPEED;

/// Build Configuration values for BLDCFG_MEMORY_QUADRANK_TYPE
typedef enum {
  QUADRANK_REGISTERED,        ///< Quadrank registered DIMM
  QUADRANK_UNBUFFERED         ///< Quadrank unbuffered DIMM
} QUANDRANK_TYPE;

/// Build Configuration values for BLDCFG_TIMING_MODE_SELECT
typedef enum {
  TIMING_MODE_AUTO,           ///< Use best rate possible
  TIMING_MODE_LIMITED,        ///< Set user top limit
  TIMING_MODE_SPECIFIC        ///< Set user specified speed
} USER_MEMORY_TIMING_MODE;

/// Build Configuration values for BLDCFG_POWER_DOWN_MODE
typedef enum {
  POWER_DOWN_BY_CHANNEL,      ///< Channel power down mode
  POWER_DOWN_BY_CHIP_SELECT,  ///< Chip select power down mode
  POWER_DOWN_MODE_AUTO        ///< AGESA to select power down mode
} POWER_DOWN_MODE;

/// Low voltage support
typedef enum {
  VOLT1_5,                   ///< 1.5 Volt
  VOLT1_35,                  ///< 1.35 Volt
  VOLT1_25,                  ///< 1.25 Volt
  VOLT_UNSUPPORTED = 0xFF    ///< No common voltage found
} DIMM_VOLTAGE;

/// UMA Mode
typedef enum {
  UMA_NONE = 0,              ///< UMA None
  UMA_SPECIFIED = 1,         ///< UMA Specified
  UMA_AUTO = 2               ///< UMA Auto
} UMA_MODE;

/// Build Configuration values for BLDCFG_UMA_ALIGNMENT
typedef enum {
  NO_UMA_ALIGNED = 0x00FFFFFF,           ///< NO UMA aligned
  UMA_128MB_ALIGNED = 0x00FFF800,        ///< UMA 128MB aligned
  UMA_256MB_ALIGNED = 0x00FFF000,        ///< UMA 256MB aligned
  UMA_512MB_ALIGNED = 0x00FFE000,        ///< UMA 512MB aligned
} UMA_ALIGNMENT;

///
///   Global MCT Configuration Status Word (GStatus)
///
typedef enum {
  GsbMTRRshort,              ///< Ran out of MTRRs while mapping memory
  GsbAllECCDimms,            ///< All banks of all Nodes are ECC capable
  GsbDramECCDis,             ///< Dram ECC requested but not enabled.
  GsbSoftHole,               ///< A Node Base gap was created
  GsbHWHole,                 ///< A HW dram remap was created
  GsbNodeIntlv,              ///< Node Memory interleaving was enabled
  GsbSpIntRemapHole,         ///< Special condition for Node Interleave and HW remapping
  GsbEnDIMMSpareNW,          ///< Indicates that DIMM Spare can be used without a warm reset

  GsbEOL                     ///< End of list
} GLOBAL_STATUS_FIELD;

///
///   Local Error Status (DIE_STRUCT.ErrStatus[31:0])
///
typedef enum {
  EsbNoDimms,                  ///< No DIMMs
  EsbSpdChkSum,                ///< SPD Checksum fail
  EsbDimmMismatchM,            ///< dimm module type(buffer) mismatch
  EsbDimmMismatchT,            ///< dimm CL/T mismatch
  EsbDimmMismatchO,            ///< dimm organization mismatch (128-bit)
  EsbNoTrcTrfc,                ///< SPD missing Trc or Trfc info
  EsbNoCycTime,                ///< SPD missing byte 23 or 25
  EsbBkIntDis,                 ///< Bank interleave requested but not enabled
  EsbDramECCDis,               ///< Dram ECC requested but not enabled
  EsbSpareDis,                 ///< Online spare requested but not enabled
  EsbMinimumMode,              ///< Running in Minimum Mode
  EsbNoRcvrEn,                 ///< No DQS Receiver Enable pass window found
  EsbSmallRcvr,                ///< DQS Rcvr En pass window too small (far right of dynamic range)
  EsbNoDqsPos,                 ///< No DQS-DQ passing positions
  EsbSmallDqs,                 ///< DQS-DQ passing window too small
  EsbDCBKScrubDis,             ///< DCache scrub requested but not enabled

  EsbEMPNotSupported,          ///< Processor is not capable for EMP.
  EsbEMPConflict,               ///< EMP requested but cannot be enabled since
                               ///< channel interleaving, bank interleaving, or bank swizzle is enabled.
  EsbEMPDis,                   ///< EMP requested but cannot be enabled since
                               ///< memory size of each DCT is not a power of two.

  EsbEOL                       ///< End of list
} ERROR_STATUS_FIELD;

///
///  Local Configuration Status (DIE_STRUCT.Status[31:0])
///
typedef enum {
  SbRegistered,                ///< All DIMMs are Registered
  SbEccDimms,                  ///< All banks ECC capable
  SbParDimms,                  ///< All banks Addr/CMD Parity capable
  SbDiagClks,                  ///< Jedec ALL slots clock enable diag mode
  Sb128bitmode,                ///< DCT in 128-bit mode operation
  Sb64MuxedMode,               ///< DCT in 64-bit mux'ed mode.
  Sb2TMode,                    ///< 2T CMD timing mode is enabled.
  SbSWNodeHole,                ///< Remapping of Node Base on this Node to create a gap.
  SbHWHole,                    ///< Memory Hole created on this Node using HW remapping.
  SbOver400Mhz,                ///< DCT freq greater than or equal to 400MHz flag
  SbDQSPosPass2,               ///< Used for TrainDQSPos DIMM0/1, when freq greater than or equal to 400MHz
  SbDQSRcvLimit,               ///< Used for DQSRcvEnTrain to know we have reached the upper bound.
  SbExtConfig,                 ///< Indicate the default setting for extended PCI configuration support
  SbLrdimms,                   ///< All DIMMs are LRDIMMs

  SbEOL                        ///< End of list
} LOCAL_STATUS_FIELD;


///< CPU MSR Register definitions ------------------------------------------
#define SYS_CFG     0xC0010010
#ifndef TOP_MEM
#define TOP_MEM     0xC001001A
#endif
# 1135 "src/vendorcode/amd/agesa/f14/AGESA.h"
#ifndef TOP_MEM2
#define TOP_MEM2    0xC001001D
#endif
# 1138 "src/vendorcode/amd/agesa/f14/AGESA.h"
#define HWCR        0xC0010015
#define NB_CFG      0xC001001F

#define FS_BASE     0xC0000100
#define IORR0_BASE  0xC0010016
#define IORR0_MASK  0xC0010017
#define BU_CFG      0xC0011023
#define BU_CFG2     0xC001102A
#define COFVID_STAT 0xC0010071
#define TSC         0x10

//-----------------------------------------------------------------------------
///
/// SPD Data for each DIMM.
///
typedef struct _SPD_DEF_STRUCT {
  IN BOOLEAN DimmPresent;       ///< Indicates that the DIMM is present and Data is valid
  IN UINT8 Data[256];           ///< Buffer for 256 Bytes of SPD data from DIMM
} SPD_DEF_STRUCT;

///
/// Channel Definition Structure.
/// This data structure defines entries that are specific to the channel initialization
///
typedef struct _CH_DEF_STRUCT {
  OUT UINT8   ChannelID;         ///< Physical channel ID of a socket(0 = CH A, 1 = CH B, 2 = CH C, 3 = CH D)
  OUT TECHNOLOGY_TYPE TechType;  ///< Technology type of this channel
  OUT UINT8   ChDimmPresent;     ///< For each bit n 0..7, 1 = DIMM n is present.
                                 ///<  DIMM#  Select Signal
                                 ///<  0      MA0_CS_L[0, 1]
                                 ///<  1      MB0_CS_L[0, 1]
                                 ///<  2      MA1_CS_L[0, 1]
                                 ///<  3      MB1_CS_L[0, 1]
                                 ///<  4      MA2_CS_L[0, 1]
                                 ///<  5      MB2_CS_L[0, 1]
                                 ///<  6      MA3_CS_L[0, 1]
                                 ///<  7      MB3_CS_L[0, 1]

  OUT struct _DCT_STRUCT *DCTPtr; ///< Pointer to the DCT data of this channel.
  OUT struct _DIE_STRUCT *MCTPtr; ///< Pointer to the node data of this channel.
  OUT SPD_DEF_STRUCT *SpdPtr;    ///< Pointer to the SPD data for this channel. (Setup by NB Constructor)
  OUT SPD_DEF_STRUCT *DimmSpdPtr[MAX_DIMMS_PER_CHANNEL]; ///< Array of pointers to
                                 ///<   SPD Data for each Dimm. (Setup by Tech Block Constructor)
  OUT UINT8   ChDimmValid;       ///< For each bit n 0..3, 1 = DIMM n is valid and is/will be configured where 4..7 are reserved.
                                 ///<
  OUT UINT8   RegDimmPresent;    ///< For each bit n 0..3, 1 = DIMM n is a registered DIMM where 4..7 are reserved.
  OUT UINT8   LrDimmPresent;     ///< For each bit n 0..3, 1 = DIMM n is Load Reduced DIMM where 4..7 are reserved.
  OUT UINT8   SODimmPresent;     ///< For each bit n 0..3, 1 = DIMM n is a SO-DIMM, where 4..7 are reserved.
  OUT UINT8   Loads;             ///< Number of devices loading bus
  OUT UINT8   Dimms;             ///< Number of DIMMs loading Channel
  OUT UINT8   Ranks;             ///< Number of ranks loading Channel DATA
  OUT BOOLEAN SlowMode;          ///< 1T or 2T CMD mode (slow access mode)
                                 ///< FALSE = 1T
                                 ///< TRUE = 2T
  ///< The following pointers will be pointed to dynamically allocated buffers.
  ///< Each buffer is two dimensional (RowCount x ColumnCount) and is lay-outed as in below.
  ///< Example: If DIMM and Byte based training, then
  ///< XX is a value in Hex
  ///<                        BYTE 0, BYTE 1, BYTE 2, BYTE 3, BYTE 4, BYTE 5, BYTE 6, BYTE 7, ECC BYTE
  ///<  Row1 -  Logical DIMM0    XX      XX      XX      XX      XX      XX      XX      XX      XX
  ///<  Row2 -  Logical DIMM1    XX      XX      XX      XX      XX      XX      XX      XX      XX
  OUT UINT16  *RcvEnDlys;       ///< DQS Receiver Enable Delays
  OUT UINT8   *WrDqsDlys;       ///< Write DQS delays (only valid for DDR3)
  OUT UINT8   *RdDqsDlys;       ///< Read Dqs delays
  OUT UINT8   *WrDatDlys;       ///< Write Data delays
  OUT UINT8   *RdDqsMinDlys;    ///< Minimum Window for Read DQS
  OUT UINT8   *RdDqsMaxDlys;    ///< Maximum Window for Read DQS
  OUT UINT8   *WrDatMinDlys;    ///< Minimum Window for Write data
  OUT UINT8   *WrDatMaxDlys;    ///< Maximum Window for Write data
  OUT UINT8   RowCount;         ///< Number of rows of the allocated buffer.
  OUT UINT8   ColumnCount;      ///< Number of columns of the allocated buffer.
  OUT UINT8   *FailingBitMask;    ///< Table of masks to Track Failing bits
  OUT UINT32  DctOdcCtl;          ///< Output Driver Strength (see BKDG FN2:Offset 9Ch, index 00h)
  OUT UINT32  DctAddrTmg;         ///< Address Bus Timing (see BKDG FN2:Offset 9Ch, index 04h)
  OUT UINT32  PhyRODTCSLow;       ///< Phy Read ODT Pattern Chip Select low (see BKDG FN2:Offset 9Ch, index 180h)
  OUT UINT32  PhyRODTCSHigh;      ///< Phy Read ODT Pattern Chip Select high (see BKDG FN2:Offset 9Ch, index 181h)
  OUT UINT32  PhyWODTCSLow;       ///< Phy Write ODT Pattern Chip Select low (see BKDG FN2:Offset 9Ch, index 182h)
  OUT UINT32  PhyWODTCSHigh;      ///< Phy Write ODT Pattern Chip Select high (see BKDG FN2:Offset 9Ch, index 183)
  OUT UINT8   PhyWLODT[4];        ///< Write Levelization ODT Pattern for Dimm 0-3 (see BKDG FN2:Offset 9Ch, index 0x8[11:8])
  OUT UINT16  DctEccDqsLike;      ///< DCT DQS ECC UINT8 like...
  OUT UINT8   DctEccDqsScale;     ///< DCT DQS ECC UINT8 scale
  OUT UINT16  PtrPatternBufA;     ///< Ptr on stack to aligned DQS testing pattern
  OUT UINT16  PtrPatternBufB;     ///< Ptr on stack to aligned DQS testing pattern
  OUT UINT8   ByteLane;           ///< Current UINT8 Lane (0..7)
  OUT UINT8   Direction;          ///< Current DQS-DQ training write direction (0=read, 1=write)
  OUT UINT8   Pattern;            ///< Current pattern
  OUT UINT8   DqsDelay;           ///< Current DQS delay value
  OUT UINT16  HostBiosSrvc1;      ///< UINT16 sized general purpose field for use by host BIOS.  Scratch space.
  OUT UINT32  HostBiosSrvc2;      ///< UINT32 sized general purpose field for use by host BIOS.  Scratch space.
  OUT UINT16  DctMaxRdLat;        ///< Max Read Latency (ns) for the DCT
  OUT UINT8   DIMMValidCh;        ///< DIMM# in CH
  OUT UINT8   MaxCh;              ///< Max number of CH in system
  OUT UINT8   Dct;                ///< Dct pointer
  OUT UINT8   WrDatGrossH;        ///< Write Data Gross delay high value
  OUT UINT8   DqsRcvEnGrossL;     ///< DQS Receive Enable Gross Delay low

  OUT UINT8   TrwtWB;             ///<  Non-SPD timing value for TrwtWB
  OUT UINT8   CurrRcvrDctADelay;  ///< for keep current RcvrEnDly
  OUT UINT16  T1000;              ///< get the T1000 figure (cycle time (ns) * 1K)
  OUT UINT8   DqsRcvEnPass;       ///< for TrainRcvrEn UINT8 lane pass flag
  OUT UINT8   DqsRcvEnSaved;      ///< for TrainRcvrEn UINT8 lane saved flag
  OUT UINT8   SeedPass1Remainder; ///< for Phy assisted DQS receiver enable training

  OUT UINT8   ClToNbFlag;         ///< is used to restore ClLinesToNbDis bit after memory
  OUT UINT32  NodeSysBase;        ///< for channel interleave usage
  OUT UINT8   RefRawCard[MAX_DIMMS_PER_CHANNEL];   ///< Array of rawcards detected
  OUT UINT8   CtrlWrd02[MAX_DIMMS_PER_CHANNEL];    ///< Control Word 2 values per DIMM
  OUT UINT8   CtrlWrd03[MAX_DIMMS_PER_CHANNEL];    ///< Control Word 3 values per DIMM
  OUT UINT8   CtrlWrd04[MAX_DIMMS_PER_CHANNEL];    ///< Control Word 4 values per DIMM
  OUT UINT8   CtrlWrd05[MAX_DIMMS_PER_CHANNEL];    ///< Control Word 5 values per DIMM
  OUT UINT8   CtrlWrd08[MAX_DIMMS_PER_CHANNEL];    ///< Control Word 8 values per DIMM

  OUT UINT16  CsPresentDCT;       ///< For each bit n 0..7, 1 = Chip-select n is present
  OUT UINT8   DimmMirrorPresent;  ///< For each bit n 0..3, 1 = DIMM n is OnDimmMirror capable where 4..7 are reserved.
  OUT UINT8   DimmSpdCse;         ///< For each bit n 0..3, 1 = DIMM n SPD checksum error where 4..7 are reserved.
  OUT UINT8   DimmExclude;        ///< For each bit n 0..3, 1 = DIMM n gets excluded where 4..7 are reserved.
  OUT UINT8   DimmYr06;           ///< Bitmap indicating which Dimms have a manufacturer's year code <= 2006
  OUT UINT8   DimmWk2406;         ///< Bitmap indicating which Dimms have a manufacturer's week code <= 24 of 2006 (June)
  OUT UINT8   DimmPlPresent;      ///< Bitmap indicating that Planar (1) or Stacked (0) Dimms are present.
  OUT UINT8   DimmQrPresent;      ///< QuadRank DIMM present?
  OUT UINT8   DimmDrPresent;      ///< Bitmap indicating that Dual Rank Dimms are present
  OUT UINT8   DimmSRPresent;      ///< Bitmap indicating that Single Rank Dimms are present
  OUT UINT8   Dimmx4Present;      ///< For each bit n 0..3, 1 = DIMM n contains x4 data devices. where 4..7 are reserved.
  OUT UINT8   Dimmx8Present;      ///< For each bit n 0..3, 1 = DIMM n contains x8 data devices. where 4..7 are reserved.
  OUT UINT8   Dimmx16Present;     ///< For each bit n 0..3, 1 = DIMM n contains x16 data devices. where 4..7 are reserved.
  OUT UINT8   LrdimmPhysicalRanks[MAX_DIMMS_PER_CHANNEL];///< Number of Physical Ranks for LRDIMMs
  OUT UINT8   LrDimmLogicalRanks[MAX_DIMMS_PER_CHANNEL];///< Number of LRDIMM Logical ranks in this configuration
  OUT UINT8   LrDimmRankMult[MAX_DIMMS_PER_CHANNEL];///< Rank Multipication factor per dimm.

  OUT UINT8   *MemClkDisMap;      ///<  This pointer will be set to point to an array that describes
                                  ///<  the routing of M[B,A]_CLK pins to the DIMMs' ranks. AGESA will
                                  ///<  base on this array to disable unused MemClk to save power.
                                  ///<
                                  ///<  The array must have 8 entries. Each entry, which associates with
                                  ///<  one MemClkDis bit, is a bitmap of 8 CS that that MemClk is routed to.
                                  ///<    Example:
                                  ///<    BKDG definition of Fn2x88[MemClkDis] bitmap for AM3 package
                                  ///<    is like below:
                                  ///<         Bit AM3/S1g3 pin name
                                  ///<         0   M[B,A]_CLK_H/L[0]
                                  ///<         1   M[B,A]_CLK_H/L[1]
                                  ///<         2   M[B,A]_CLK_H/L[2]
                                  ///<         3   M[B,A]_CLK_H/L[3]
                                  ///<         4   M[B,A]_CLK_H/L[4]
                                  ///<         5   M[B,A]_CLK_H/L[5]
                                  ///<         6   M[B,A]_CLK_H/L[6]
                                  ///<         7   M[B,A]_CLK_H/L[7]
                                  ///<    And platform has the following routing:
                                  ///<         CS0   M[B,A]_CLK_H/L[4]
                                  ///<         CS1   M[B,A]_CLK_H/L[2]
                                  ///<         CS2   M[B,A]_CLK_H/L[3]
                                  ///<         CS3   M[B,A]_CLK_H/L[5]
                                  ///<    Then MemClkDisMap should be pointed to the following array:
                                  ///<               CLK_2 CLK_3 CLK_4 CLK_5
                                  ///<    0x00, 0x00, 0x02, 0x04, 0x01, 0x08, 0x00, 0x00
                                  ///<  Each entry of the array is the bitmask of 8 chip selects.

  OUT UINT8   *CKETriMap;         ///<  This pointer will be set to point to an array that describes
                                  ///<  the routing of CKE pins to the DIMMs' ranks.
                                  ///<  The array must have 2 entries. Each entry, which associates with
                                  ///<  one CKE pin, is a bitmap of 8 CS that that CKE is routed to.
                                  ///<  AGESA will base on this array to disable unused CKE pins to save power.

  OUT UINT8   *ODTTriMap;         ///<  This pointer will be set to point to an array that describes
                                  ///<  the routing of ODT pins to the DIMMs' ranks.
                                  ///<  The array must have 4 entries. Each entry, which associates with
                                  ///<  one ODT pin, is a bitmap of 8 CS that that ODT is routed to.
                                  ///<  AGESA will base on this array to disable unused ODT pins to save power.

  OUT UINT8   *ChipSelTriMap;     ///<  This pointer will be set to point to an array that describes
                                  ///<  the routing of chip select pins to the DIMMs' ranks.
                                  ///<  The array must have 8 entries. Each entry is a bitmap of 8 CS.
                                  ///<  AGESA will base on this array to disable unused Chip select pins to save power.

  OUT BOOLEAN   ExtendTmp;        ///<  If extended temperature is supported on all dimms on a channel.

  OUT UINT8   Reserved[100];      ///< Reserved
} CH_DEF_STRUCT;

///
/// DCT Channel Timing Parameters.
/// This data structure sets timings that are specific to the channel.
///
typedef struct _CH_TIMING_STRUCT {
  OUT UINT16  DctDimmValid;       ///< For each bit n 0..3, 1=DIMM n is valid and is/will be configured where 4..7 are reserved.
  OUT UINT16  DimmMirrorPresent;  ///< For each bit n 0..3, 1=DIMM n is OnDimmMirror capable where 4..7 are reserved.
  OUT UINT16  DimmSpdCse;         ///< For each bit n 0..3, 1=DIMM n SPD checksum error where 4..7 are reserved.
  OUT UINT16  DimmExclude;        ///< For each bit n 0..3, 1 = DIMM n gets excluded where 4..7 are reserved.
  OUT UINT16  CsPresent;          ///< For each bit n 0..7, 1=Chip-select n is present
  OUT UINT16  CsEnabled;          ///< For each bit n 0..7, 1=Chip-select n is enabled
  OUT UINT16  CsTestFail;         ///< For each bit n 0..7, 1=Chip-select n is present but disabled
  OUT UINT16  CsTrainFail;        ///< Bitmap showing which chipselects failed training
  OUT UINT16  DIMM1KPage;         ///< For each bit n 0..3, 1=DIMM n contains 1K page devices. where 4..7 are reserved
  OUT UINT16  DimmQrPresent;      ///< QuadRank DIMM present?
  OUT UINT16  DimmDrPresent;      ///< Bitmap indicating that Dual Rank Dimms are present , where 4..7 are reserved
  OUT UINT8   DimmSRPresent;      ///< Bitmap indicating that Single Rank Dimms are present, where 4..7 are reserved
  OUT UINT16  Dimmx4Present;      ///< For each bit n 0..3, 1=DIMM n contains x4 data devices. where 4..7 are reserved
  OUT UINT16  Dimmx8Present;      ///< For each bit n 0..3, 1=DIMM n contains x8 data devices. where 4..7 are reserved
  OUT UINT16  Dimmx16Present;     ///< For each bit n 0..3, 1=DIMM n contains x16 data devices. where 4..7 are reserved

  OUT UINT16  DIMMTrcd;           ///< Minimax Trcd*40 (ns) of DIMMs
  OUT UINT16  DIMMTrp;            ///< Minimax Trp*40 (ns) of DIMMs
  OUT UINT16  DIMMTrtp;           ///< Minimax Trtp*40 (ns) of DIMMs
  OUT UINT16  DIMMTras;           ///< Minimax Tras*40 (ns) of DIMMs
  OUT UINT16  DIMMTrc;            ///< Minimax Trc*40 (ns) of DIMMs
  OUT UINT16  DIMMTwr;            ///< Minimax Twr*40 (ns) of DIMMs
  OUT UINT16  DIMMTrrd;           ///< Minimax Trrd*40 (ns) of DIMMs
  OUT UINT16  DIMMTwtr;           ///< Minimax Twtr*40 (ns) of DIMMs
  OUT UINT16  DIMMTfaw;           ///< Minimax Tfaw*40 (ns) of DIMMs
  OUT UINT16  TargetSpeed;        ///< Target DRAM bus speed in MHz
  OUT UINT16  Speed;              ///< DRAM bus speed in MHz
                                  ///<  400 (MHz)
                                  ///<  533 (MHz)
                                  ///<  667 (MHz)
                                  ///<  800 (MHz)
                                  ///<  and so on...
  OUT UINT8   CasL;               ///< CAS latency DCT setting (busclocks)
  OUT UINT8   Trcd;               ///< DCT Trcd (busclocks)
  OUT UINT8   Trp;                ///< DCT Trp (busclocks)
  OUT UINT8   Trtp;               ///< DCT Trtp (busclocks)
  OUT UINT8   Tras;               ///< DCT Tras (busclocks)
  OUT UINT8   Trc;                ///< DCT Trc (busclocks)
  OUT UINT8   Twr;                ///< DCT Twr (busclocks)
  OUT UINT8   Trrd;               ///< DCT Trrd (busclocks)
  OUT UINT8   Twtr;               ///< DCT Twtr (busclocks)
  OUT UINT8   Tfaw;               ///< DCT Tfaw (busclocks)
  OUT UINT8   Trfc0;              ///< DCT Logical DIMM0 Trfc
                                  ///<  0 = 75ns (for 256Mb devs)
                                  ///<  1 = 105ns (for 512Mb devs)
                                  ///<  2 = 127.5ns (for 1Gb devs)
                                  ///<  3 = 195ns (for 2Gb devs)
                                  ///<  4 = 327.5ns (for 4Gb devs)
  OUT UINT8   Trfc1;              ///< DCT Logical DIMM1 Trfc (see Trfc0 for format)
  OUT UINT8   Trfc2;              ///< DCT Logical DIMM2 Trfc (see Trfc0 for format)
  OUT UINT8   Trfc3;              ///< DCT Logical DIMM3 Trfc (see Trfc0 for format)
  OUT UINT32  DctMemSize;         ///< Base[47:16], total DRAM size controlled by this DCT.
                                  ///<
  OUT BOOLEAN SlowMode;           ///< 1T or 2T CMD mode (slow access mode)
                                  ///< FALSE = 1T
                                  ///< TRUE = 2T
  OUT UINT8   TrwtTO;             ///< DCT TrwtTO (busclocks)
  OUT UINT8   Twrrd;              ///< DCT Twrrd (busclocks)
  OUT UINT8   Twrwr;              ///< DCT Twrwr (busclocks)
  OUT UINT8   Trdrd;              ///< DCT Trdrd (busclocks)
  OUT UINT8   TrwtWB;             ///< DCT TrwtWB (busclocks)
  OUT UINT8   TrdrdSD;            ///< DCT TrdrdSD (busclocks)
  OUT UINT8   TwrwrSD;            ///< DCT TwrwrSD (busclocks)
  OUT UINT8   TwrrdSD;            ///< DCT TwrrdSD (busclocks)
  OUT UINT16  MaxRdLat;           ///< Max Read Latency
  OUT UINT8   WrDatGrossH;        ///< Temporary variables must be removed
  OUT UINT8   DqsRcvEnGrossL;     ///< Temporary variables must be removed
} CH_TIMING_STRUCT;

///
/// Data for each DCT.
/// This data structure defines data used to configure each DRAM controller.
///
typedef struct _DCT_STRUCT {
  OUT UINT8   Dct;                ///< Current Dct
  OUT CH_TIMING_STRUCT Timings;   ///< Channel Timing structure
  OUT CH_DEF_STRUCT    *ChData;   ///< Pointed to a dynamically allocated array of Channel structures
  OUT UINT8   ChannelCount;       ///< Number of channel per this DCT
} DCT_STRUCT;


///
/// Data Structure defining each Die.
/// This data structure contains information that is used to configure each Die.
///
typedef struct _DIE_STRUCT {

  /// Advanced:

  OUT UINT8   NodeId;              ///< Node ID of current controller
  OUT UINT8   SocketId;            ///< Socket ID of this Die
  OUT UINT8   DieId;               ///< ID of this die relative to the socket
  OUT PCI_ADDR      PciAddr;       ///< Pci bus and device number of this controller.
  OUT AGESA_STATUS  ErrCode;       ///< Current error condition of Node
                                   ///<  0x0 = AGESA_SUCCESS
                                   ///<  0x1 = AGESA_UNSUPPORTED
                                   ///<  0x2 = AGESA_BOUNDS_CHK
                                   ///<  0x3 = AGESA_ALERT
                                   ///<  0x4 = AGESA_WARNING
                                   ///<  0x5 = AGESA_ERROR
                                   ///<  0x6 = AGESA_CRITICAL
                                   ///<  0x7 = AGESA_FATAL
                                   ///<
  OUT BOOLEAN ErrStatus[EsbEOL];   ///< Error Status bit Field
                                   ///<
  OUT BOOLEAN Status[SbEOL];       ///< Status bit Field
                                   ///<
  OUT UINT32  NodeMemSize;         ///< Base[47:16], total DRAM size controlled by both DCT0 and DCT1 of this Node.
                                   ///<
  OUT UINT32  NodeSysBase;         ///< Base[47:16] (system address) DRAM base address of this Node.
                                   ///<
  OUT UINT32  NodeHoleBase;        ///< If not zero, Base[47:16] (system address) of dram hole for HW remapping.  Dram hole exists on this Node
                                   ///<
  OUT UINT32  NodeSysLimit;        ///< Base[47:16] (system address) DRAM limit address of this Node.
                                   ///<
  OUT UINT32  DimmPresent;         ///< For each bit n 0..7, 1 = DIMM n is present.
                                   ///<   DIMM#  Select Signal
                                   ///<   0      MA0_CS_L[0, 1]
                                   ///<   1      MB0_CS_L[0, 1]
                                   ///<   2      MA1_CS_L[0, 1]
                                   ///<   3      MB1_CS_L[0, 1]
                                   ///<   4      MA2_CS_L[0, 1]
                                   ///<   5      MB2_CS_L[0, 1]
                                   ///<   6      MA3_CS_L[0, 1]
                                   ///<   7      MB3_CS_L[0, 1]
                                   ///<
  OUT UINT32  DimmValid;           ///< For each bit n 0..7, 1 = DIMM n is valid and is / will be configured
  OUT UINT32  RegDimmPresent;      ///< For each bit n 0..7, 1 = DIMM n is registered DIMM
  OUT UINT32  LrDimmPresent;       ///< For each bit n 0..7, 1 = DIMM n is Load Reduced DIMM
  OUT UINT32  DimmEccPresent;      ///< For each bit n 0..7, 1 = DIMM n is ECC capable.
  OUT UINT32  DimmParPresent;      ///< For each bit n 0..7, 1 = DIMM n is ADR/CMD Parity capable.
                                   ///<
  OUT UINT16  DimmTrainFail;       ///< Bitmap showing which dimms failed training
  OUT UINT16  ChannelTrainFail;    ///< Bitmap showing the channel information about failed Chip Selects
                                   ///<  0 in any bit field indicates Channel 0
                                   ///<  1 in any bit field indicates Channel 1
  OUT UINT8   Dct;                 ///<  Need to be removed
                                   ///<  DCT pointer
  OUT BOOLEAN GangedMode;          ///< Ganged mode
                                   ///<  0 = disabled
                                   ///<  1 = enabled
  OUT CPU_LOGICAL_ID LogicalCpuid; ///< The logical CPUID of the node
                                   ///<
  OUT UINT16  HostBiosSrvc1;       ///< UINT16 sized general purpose field for use by host BIOS.  Scratch space.
                                   ///<
  OUT UINT32  HostBiosSrvc2;       ///< UINT32 sized general purpose field for use by host BIOS.  Scratch space.
                                   ///<
  OUT UINT8   MLoad;               ///< Need to be removed
                                   ///< Number of devices loading MAA bus
                                   ///<
  OUT UINT8   MaxAsyncLat;         ///< Legacy wrapper
                                   ///<
  OUT UINT8   ChbD3Rcvrdly;        ///< Legacy wrapper
                                   ///<
  OUT UINT16  ChaMaxRdLat;         ///< Max Read Latency (ns) for DCT 0
                                   ///<
  OUT UINT8   ChbD3BcRcvrdly;      ///< CHB DIMM 3 Check UINT8 Receiver Enable Delay

  OUT DCT_STRUCT *DctData;         ///< Pointed to a dynamically allocated array of DCT_STRUCTs
  OUT UINT8   DctCount;            ///< Number of DCTs per this Die
  OUT UINT8   Reserved[16];        ///< Reserved
} DIE_STRUCT;

/**********************************************************************
 * S3 Support structure
 **********************************************************************/
/// AmdInitResume, AmdS3LateRestore, and AmdS3Save param structure
typedef struct {
     OUT   UINT32 Signature;           ///< "ASTR" for AMD Suspend-To-RAM
     OUT   UINT16 Version;             ///< S3 Params version number
  IN OUT   UINT32 Flags;               ///< Indicates operation
  IN OUT   VOID   *NvStorage;          ///< Pointer to memory critical save state data
  IN OUT   UINT32 NvStorageSize;       ///< Size in bytes of the NvStorage region
  IN OUT   VOID   *VolatileStorage;    ///< Pointer to remaining AMD save state data
  IN OUT   UINT32 VolatileStorageSize; ///< Size in bytes of the VolatileStorage region
} AMD_S3_PARAMS;

///===============================================================================
/// MEM_PARAMETER_STRUCT
/// This data structure is used to pass wrapper parameters to the memory configuration code
///
typedef struct _MEM_PARAMETER_STRUCT {

  // Basic (Return parameters)
  // (This section contains the outbound parameters from the memory init code)

  OUT BOOLEAN GStatus[GsbEOL];    ///< Global Status bitfield.
                                  ///<
  OUT UINT32 HoleBase;            ///< If not zero Base[47:16] (system address) of sub 4GB dram hole for HW remapping.
                                  ///<
  OUT UINT32 Sub4GCacheTop;       ///< If not zero, the 32-bit top of cacheable memory.
                                  ///<
  OUT UINT32 SysLimit;            ///< Limit[47:16] (system address).
                                  ///<

  OUT DIMM_VOLTAGE DDR3Voltage;   ///< Find support voltage and send back to platform BIOS.
                                  ///< 0 = 1.5v
                                  ///< 1 = 1.35v
                                  ///< 2 = 1.2v
                                  ///< 0xFF = Mixed 1.5V and 1.2V in the system. 1.5V dimms get excluded
                                  ///<        from the system.
                                  ///<

  OUT struct _MEM_DATA_STRUCT *MemData;   ///< Access to global memory init data.

  //  Advanced (Optional parameters)
  //  Optional (all defaults values will be initialized by the
  //  'AmdMemInitDataStructDef' based on AMD defaults. It is up
  //  to the IBV/OEM to change the defaults after initialization
  //  but prior to the main entry to the memory code):

  // Memory Map/Mgt.

  IN UINT16  BottomIo;             ///< Bottom of 32-bit IO space (8-bits).
                                   ///<   NV_BOTTOM_IO[7:0]=Addr[31:24]
                                   ///<
  IN BOOLEAN MemHoleRemapping;     ///< Memory Hole Remapping (1-bit).
                                   ///<  FALSE = disable
                                   ///<  TRUE  = enable


  // Dram Timing

  IN USER_MEMORY_TIMING_MODE   UserTimingMode;  ///< User Memclock Mode.
                                                ///< @BldCfgItem{BLDCFG_TIMING_MODE_SELECT}

  IN MEMORY_BUS_SPEED          MemClockValue;   ///< Memory Clock Value.
                                                ///< @BldCfgItem{BLDCFG_MEMORY_CLOCK_SELECT}


  // Dram Configuration

  IN BOOLEAN EnableBankIntlv;      ///< Dram Bank (chip-select) Interleaving (1-bit).
                                   ///<  - FALSE =disable (default)
                                   ///<  - TRUE = enable
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_MEMORY_ENABLE_BANK_INTERLEAVING}

  IN BOOLEAN EnableNodeIntlv;      ///< Node Memory Interleaving (1-bit).
                                   ///<   - FALSE = disable (default)
                                   ///<   - TRUE = enable
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_MEMORY_ENABLE_NODE_INTERLEAVING}

  IN BOOLEAN EnableChannelIntlv;   ///< Channel Interleaving (1-bit).
                                   ///<   - FALSE = disable (default)
                                   ///<   - TRUE = enable
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_MEMORY_CHANNEL_INTERLEAVING}
  // ECC

  IN BOOLEAN EnableEccFeature;     ///< enable ECC error to go into MCE.
                                   ///<   - FALSE = disable (default)
                                   ///<   - TRUE = enable
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_ENABLE_ECC_FEATURE}
  // Dram Power

  IN BOOLEAN EnablePowerDown;      ///< CKE based power down mode (1-bit).
                                   ///<   - FALSE =disable (default)
                                   ///<   - TRUE =enable
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_MEMORY_POWER_DOWN}

  // Online Spare

  IN BOOLEAN EnableOnLineSpareCtl; ///< Chip Select Spare Control bit 0.
                                   ///<  - FALSE = disable Spare (default)
                                   ///<  - TRUE = enable Spare
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_ONLINE_SPARE}

  IN UINT8 *TableBasedAlterations; ///< Desired modifications to register settings.

  IN PSO_TABLE *PlatformMemoryConfiguration;
                                   ///< A table that contains platform specific settings.
                                   ///< For example, MemClk routing, the number of DIMM slots per channel, ....
                                   ///< AGESA initializes this pointer with DefaultPlatformMemoryConfiguration that
                                   ///< contains default conservative settings. Platform BIOS can either tweak
                                   ///< DefaultPlatformMemoryConfiguration or reassign this pointer to its own table.
                                   ///<
  IN BOOLEAN EnableParity;         ///< Parity control.
                                   ///<  - TRUE = enable
                                   ///<  - FALSE = disable (default)
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_MEMORY_PARITY_ENABLE}

  IN BOOLEAN EnableBankSwizzle;    ///< BankSwizzle control.
                                   ///<  - FALSE = disable
                                   ///<  - TRUE = enable  (default)
                                   ///<
                                   ///< @BldCfgItem{BLDCFG_BANK_SWIZZLE}

                                   ///<

  IN BOOLEAN EnableMemClr;         ///< Memory Clear functionality control.
                                   ///<  - FALSE = disable
                                   ///<  - TRUE = enable  (default)
                                   ///<

  // Uma Configuration

  IN UMA_MODE UmaMode;             ///<  Uma Mode
                                   ///<  0 = None
                                   ///<  1 = Specified
                                   ///<  2 = Auto
  IN OUT UINT32 UmaSize;           ///<  The size of shared graphics dram (16-bits)
                                   ///<  NV_UMA_Size[31:0]=Addr[47:16]
                                   ///<
  OUT UINT32 UmaBase;              ///<  The allocated Uma base address (32-bits)
                                   ///<  NV_UMA_Base[31:0]=Addr[47:16]
                                   ///<

  /// Memory Restore Feature

  IN BOOLEAN MemRestoreCtl;        ///< Memory context restore control
                                   ///<   FALSE = perform memory init as normal (AMD default)
                                   ///<   TRUE = restore memory context and skip training. This requires
                                   ///<          MemContext is valid before AmdInitPost
                                   ///<
  IN BOOLEAN SaveMemContextCtl;    ///< Control switch to save memory context at the end of MemAuto
                                   ///<   TRUE = AGESA will setup MemContext block before exit AmdInitPost
                                   ///<   FALSE = AGESA will not setup MemContext block. Platform is
                                   ///<           expected to call S3Save later in POST if it wants to
                                   ///<           use memory context restore feature.
                                   ///<
  IN OUT AMD_S3_PARAMS MemContext; ///< Memory context block describes the data that platform needs to
                                   ///< save and restore for memory context restore feature to work.
                                   ///< It uses the subset of S3Save block to save/restore. Hence platform
                                   ///< may save only S3 block and uses it for both S3 resume and
                                   ///< memory context restore.
                                   ///<  - If MemRestoreCtl is TRUE, platform needs to pass in MemContext
                                   ///<    before AmdInitPost.
                                   ///<  - If SaveMemContextCtl is TRUE, platform needs to save MemContext
                                   ///<    right after AmdInitPost.
                                   ///<
} MEM_PARAMETER_STRUCT;


///
/// Function definition.
/// This data structure passes function pointers to the memory configuration code.
/// The wrapper can use this structure with customized versions.
///
typedef struct _MEM_FUNCTION_STRUCT {

  // PUBLIC required Internal functions

  IN OUT BOOLEAN (*amdMemGetPsCfgU) ( VOID *pMemData);  ///< Proc for Unbuffered DIMMs, platform specific
  IN OUT BOOLEAN (*amdMemGetPsCfgR) (VOID *pMemData);   ///< Proc for Registered DIMMs, platform specific

  // PUBLIC optional functions

  IN OUT VOID (*amdMemEccInit) (VOID *pMemData);                  ///< NB proc for ECC feature
  IN OUT VOID (*amdMemChipSelectInterleaveInit) (VOID *pMemData); ///< NB proc for CS interleave feature
  IN OUT VOID (*amdMemDctInterleavingInit) (VOID *pMemData);      ///< NB proc for Channel interleave feature
  IN OUT VOID (*amdMemMctInterleavingInit) (VOID *pMemData);      ///< NB proc for Node interleave feature
  IN OUT VOID (*amdMemParallelTraining) (VOID *pMemData);         ///< NB proc for parallel training feature
  IN OUT VOID (*amdMemEarlySampleSupport) (VOID *pMemData);       ///< NB code for early sample support feature
  IN OUT VOID (*amdMemMultiPartInitSupport) (VOID *pMemData);     ///< NB code for 'multi-part'
  IN OUT VOID (*amdMemOnlineSpareSupport) (VOID *pMemData);       ///< NB code for On-Line Spare feature
  IN OUT VOID (*amdMemUDimmInit) (VOID *pMemData);                ///< NB code for UDIMMs
  IN OUT VOID (*amdMemRDimmInit) (VOID *pMemData);                ///< NB code for RDIMMs
  IN OUT VOID (*amdMemLrDimmInit) (VOID *pMemData);                ///< NB code for LRDIMMs

  IN OUT UINT32   Reserved[100]; ///< Reserved for later function definition
} MEM_FUNCTION_STRUCT;

///
/// Socket Structure
///
///
typedef struct _MEM_SOCKET_STRUCT {
  OUT VOID *ChannelPtr[MAX_CHANNELS_PER_SOCKET];  ///< Pointers to each channels training data

  OUT VOID *TimingsPtr[MAX_CHANNELS_PER_SOCKET];  ///< Pointers to each channels timing data
} MEM_SOCKET_STRUCT;

///
/// Contains all data relevant to Memory Initialization.
///
typedef struct _MEM_DATA_STRUCT {
  IN AMD_CONFIG_PARAMS StdHeader;             ///< Standard configuration header

  IN MEM_PARAMETER_STRUCT *ParameterListPtr;  ///< List of input Parameters

  OUT MEM_FUNCTION_STRUCT FunctionList;       ///< List of function Pointers

  IN OUT AGESA_STATUS (*GetPlatformCfg[MAX_PLATFORM_TYPES]) (struct _MEM_DATA_STRUCT *MemData, UINT8 SocketID, CH_DEF_STRUCT *CurrentChannel); ///< look-up platform info

  IN OUT BOOLEAN (*ErrorHandling)(struct _DIE_STRUCT *MCTPtr, UINT8 DCT, UINT16 ChipSelMask, AMD_CONFIG_PARAMS *StdHeader); ///< Error Handling


  OUT MEM_SOCKET_STRUCT SocketList[MAX_SOCKETS_SUPPORTED];  ///< Socket list for memory code.
                                   ///< SocketList is a shortcut for IBVs to retrieve training
                                   ///< and timing data for each channel indexed by socket/channel,
                                   ///< eliminating their need to parse die/dct/channel etc.
                                   ///< It contains pointers to the populated data structures for
                                   ///< each channel and skips the channel structures that are
                                   ///< unpopulated. In the case of channels sharing the same DCT,
                                   ///< the pTimings pointers will point to the same DCT Timing data.

  OUT DIE_STRUCT *DiesPerSystem;  ///< Pointed to an array of DIE_STRUCTs
  OUT UINT8      DieCount;        ///< Number of MCTs in the system.

  IN SPD_DEF_STRUCT *SpdDataStructure;              ///< Pointer to SPD Data structure

  IN OUT  struct _PLATFORM_CONFIGURATION   *PlatFormConfig;    ///< Platform profile/build option config structure

  IN OUT BOOLEAN IsFlowControlSupported;    ///< Indicates if flow control is supported

  OUT UINT32 TscRate;             ///< The rate at which the TSC increments in megahertz.

} MEM_DATA_STRUCT;

///
/// Uma Structure
///
///
typedef struct _UMA_INFO {
  OUT UINT64 UmaBase;          ///< UmaBase[63:0] = Addr[63:0]
  OUT UINT32 UmaSize;          ///< UmaSize[31:0] = Addr[31:0]
  OUT UINT32 UmaAttributes;    ///< Indicate the attribute of Uma
  OUT UINT8 UmaMode;           ///< Indicate the mode of Uma
  OUT UINT16 MemClock;         ///< Indicate memory running speed in MHz
  OUT UINT8 Reserved[3];       ///< Reserved for future usage
} UMA_INFO;

//  AGESA MEMORY ERRORS

// AGESA_ALERT Memory Errors
#define MEM_ALERT_USER_TMG_MODE_OVERRULED   0x04010000 ///< TIMING_MODE_SPECIFIC is requested but
                                                       ///< cannot be applied to current configurations.
#define MEM_ALERT_ORG_MISMATCH_DIMM 0x04010100          ///< DIMM organization miss-match
#define MEM_ALERT_BK_INT_DIS 0x04010200                 ///< Bank interleaving disable for internal issue

// AGESA_ERROR Memory Errors
#define MEM_ERROR_NO_DQS_POS_RD_WINDOW 0x04010300     ///< No DQS Position window for RD DQS
#define MEM_ERROR_SMALL_DQS_POS_RD_WINDOW 0x04020300  ///< Small DQS Position window for RD DQS
#define MEM_ERROR_NO_DQS_POS_WR_WINDOW 0x04030300     ///< No DQS Position window for WR DQS
#define MEM_ERROR_SMALL_DQS_POS_WR_WINDOW 0x04040300  ///< Small DQS Position window for WR DQS
#define MEM_ERROR_ECC_DIS 0x04010400                  ///< ECC has been disabled as a result of an internal issue
#define MEM_ERROR_DIMM_SPARING_NOT_ENABLED 0x04010500 ///< DIMM sparing has not been enabled for an internal issues
#define MEM_ERROR_RCVR_EN_VALUE_TOO_LARGE 0x04050300 ///< Receive Enable value is too large
#define MEM_ERROR_RCVR_EN_NO_PASSING_WINDOW 0x04060300 ///< There is no DQS receiver enable window
#define MEM_ERROR_DRAM_ENABLED_TIME_OUT 0x04010600 ///< Time out when polling DramEnabled bit
#define MEM_ERROR_DCT_ACCESS_DONE_TIME_OUT 0x04010700 ///< Time out when polling DctAccessDone bit
#define MEM_ERROR_SEND_CTRL_WORD_TIME_OUT 0x04010800 ///< Time out when polling SendCtrlWord bit
#define MEM_ERROR_PREF_DRAM_TRAIN_MODE_TIME_OUT 0x04010900 ///< Time out when polling PrefDramTrainMode bit
#define MEM_ERROR_ENTER_SELF_REF_TIME_OUT 0x04010A00 ///< Time out when polling EnterSelfRef bit
#define MEM_ERROR_FREQ_CHG_IN_PROG_TIME_OUT 0x04010B00 ///< Time out when polling FreqChgInProg bit
#define MEM_ERROR_EXIT_SELF_REF_TIME_OUT 0x04020A00 ///< Time out when polling ExitSelfRef bit
#define MEM_ERROR_SEND_MRS_CMD_TIME_OUT 0x04010C00 ///< Time out when polling SendMrsCmd bit
#define MEM_ERROR_SEND_ZQ_CMD_TIME_OUT 0x04010D00 ///< Time out when polling SendZQCmd bit
#define MEM_ERROR_DCT_EXTRA_ACCESS_DONE_TIME_OUT 0x04010E00 ///< Time out when polling DctExtraAccessDone bit
#define MEM_ERROR_MEM_CLR_BUSY_TIME_OUT 0x04010F00 ///< Time out when polling MemClrBusy bit
#define MEM_ERROR_MEM_CLEARED_TIME_OUT 0x04020F00 ///< Time out when polling MemCleared bit
#define MEM_ERROR_FLUSH_WR_TIME_OUT 0x04011000 ///< Time out when polling FlushWr bit
#define MEM_ERROR_MAX_LAT_NO_WINDOW 0x04070300 ///< Fail to find pass during Max Rd Latency training
#define MEM_ERROR_PARALLEL_TRAINING_LAUNCH_FAIL 0x04080300 ///< Fail to launch training code on an AP
#define MEM_ERROR_PARALLEL_TRAINING_TIME_OUT 0x04090300 ///< Fail to finish parallel training
#define MEM_ERROR_NO_ADDRESS_MAPPING 0x04011100 ///< No address mapping found for a dimm
#define MEM_ERROR_RCVR_EN_NO_PASSING_WINDOW_EQUAL_LIMIT  0x040A0300 ///< There is no DQS receiver enable window and the value is equal to the largest value
#define MEM_ERROR_RCVR_EN_VALUE_TOO_LARGE_LIMIT_LESS_ONE 0x040B0300 ///< Receive Enable value is too large and is 1 less than limit
#define MEM_ERROR_CHECKSUM_NV_SPDCHK_RESTRT_ERROR  0x04011200    ///< SPD Checksum error for NV_SPDCHK_RESTRT
#define MEM_ERROR_NO_CHIPSELECT 0x04011300              ///< No chipselects found
#define MEM_ERROR_UNSUPPORTED_333MHZ_UDIMM 0x04011500   ///< Unbuffered dimm is not supported at 333MHz
#define MEM_ERROR_WL_PRE_OUT_OF_RANGE 0x040C0300   ///< Returned PRE value during write levelizzation was out of range

// AGESA_WARNING Memory Errors
#define MEM_WARNING_UNSUPPORTED_QRDIMM      0x04011600 ///< QR DIMMs detected but not supported
#define MEM_WARNING_UNSUPPORTED_UDIMM       0x04021600 ///< U DIMMs detected but not supported
#define MEM_WARNING_UNSUPPORTED_SODIMM      0x04031600 ///< SO-DIMMs detected but not supported
#define MEM_WARNING_UNSUPPORTED_X4DIMM      0x04041600 ///< x4 DIMMs detected but not supported
#define MEM_WARNING_UNSUPPORTED_RDIMM       0x04051600 ///< R DIMMs detected but not supported
#define MEM_WARNING_UNSUPPORTED_LRDIMM      0x04061600 ///< LR DIMMs detected but not supported
#define MEM_WARNING_EMP_NOT_SUPPORTED       0x04011700 ///< Processor is not capable for EMP
#define MEM_WARNING_EMP_CONFLICT            0x04021700  ///< EMP cannot be enabled if channel interleaving,
#define MEM_WARNING_EMP_NOT_ENABLED         0x04031700  ///< Memory size is not power of two.
#define MEM_WARNING_PERFORMANCE_ENABLED_BATTERY_LIFE_PREFERRED 0x04011800  ///< Performance has been enabled, but battery life is preferred.
                                                        ///< bank interleaving, or bank swizzle is enabled.
#define MEM_WARNING_NO_SPDTRC_FOUND         0x04011900  ///< No Trc timing value found in SPD of a dimm.
#define MEM_WARNING_NODE_INTERLEAVING_NOT_ENABLED 0x04012000    ///< Node Interleaveing Requested, but could not be enabled
#define MEM_WARNING_CHANNEL_INTERLEAVING_NOT_ENABLED 0x04012100 ///< Channel Interleaveing Requested, but could not be enabled
#define MEM_WARNING_BANK_INTERLEAVING_NOT_ENABLED 0x04012200 ///< Bank Interleaveing Requested, but could not be enabled
#define MEM_WARNING_VOLTAGE_1_35_NOT_SUPPORTED 0x04012300 ///< Voltage 1.35 determined, but could not be supported

// AGESA_FATAL Memory Errors
#define MEM_ERROR_MINIMUM_MODE 0x04011A00               ///< Running in minimum mode
#define MEM_ERROR_MODULE_TYPE_MISMATCH_DIMM 0x04011B00  ///< DIMM modules are miss-matched
#define MEM_ERROR_NO_DIMM_FOUND_ON_SYSTEM 0x04011C00    ///< No DIMMs have been found
#define MEM_ERROR_MISMATCH_DIMM_CLOCKS  0x04011D00      ///< DIMM clocks miss-matched
#define MEM_ERROR_NO_CYC_TIME 0x04011E00                ///< No cycle time found
#define MEM_ERROR_HEAP_ALLOCATE_DYN_STORING_OF_TRAINED_TIMINGS   0x04011F00 ///< Heap allocation error with dynamic storing of trained timings
#define MEM_ERROR_HEAP_ALLOCATE_FOR_DCT_STRUCT_AND_CH_DEF_STRUCTs   0x04021F00 ///< Heap allocation error for DCT_STRUCT and CH_DEF_STRUCT
#define MEM_ERROR_HEAP_ALLOCATE_FOR_REMOTE_TRAINING_ENV   0x04031F00 ///< Heap allocation error with REMOTE_TRAINING_ENV
#define MEM_ERROR_HEAP_ALLOCATE_FOR_SPD     0x04041F00    ///< Heap allocation error for SPD data
#define MEM_ERROR_HEAP_ALLOCATE_FOR_RECEIVED_DATA     0x04051F00    ///< Heap allocation error for RECEIVED_DATA during parallel training
#define MEM_ERROR_HEAP_ALLOCATE_FOR_S3_SPECIAL_CASE_REGISTERS     0x04061F00    ///< Heap allocation error for S3 "SPECIAL_CASE_REGISTER"
#define MEM_ERROR_HEAP_ALLOCATE_FOR_TRAINING_DATA     0x04071F00   ///< Heap allocation error for Training Data
#define MEM_ERROR_HEAP_ALLOCATE_FOR_IDENTIFY_DIMM_MEM_NB_BLOCK     0x04081F00    ///< Heap allocation error for  DIMM Identify "MEM_NB_BLOCK
#define MEM_ERROR_NO_CONSTRUCTOR_FOR_IDENTIFY_DIMM     0x04022300   ///< No Constructor for DIMM Identify

// AGESA_CRITICAL Memory Errors
#define MEM_ERROR_HEAP_ALLOCATE_FOR_DMI_TABLE_DDR3     0x04091F00    ///< Heap allocation error for DMI table for DDR3
#define MEM_ERROR_HEAP_ALLOCATE_FOR_DMI_TABLE_DDR2     0x040A1F00    ///< Heap allocation error for DMI table for DDR2
#define MEM_ERROR_UNSUPPORTED_DIMM_CONFIG              0x04011400    ///< Dimm population is not supported



/*----------------------------------------------------------------------------
 *
 *                END OF MEMORY-SPECIFIC DATA STRUCTURES
 *
 *----------------------------------------------------------------------------
 */




/*----------------------------------------------------------------------------
 *
 *                    CPU RELATED DEFINITIONS
 *
 *----------------------------------------------------------------------------
 */

// CPU Event definitions.

// Defines used to filter CPU events based on functional blocks
#define CPU_EVENT_PM_EVENT_MASK                         0xFF00FF00
#define CPU_EVENT_PM_EVENT_CLASS                        0x08000400

//================================================================
// CPU General events
//    Heap allocation                     (AppFunction =      01h)
#define CPU_ERROR_HEAP_BUFFER_IS_NOT_PRESENT            0x08000100
#define CPU_ERROR_HEAP_IS_ALREADY_INITIALIZED           0x08010100
#define CPU_ERROR_HEAP_IS_FULL                          0x08020100
#define CPU_ERROR_HEAP_BUFFER_HANDLE_IS_ALREADY_USED    0x08030100
#define CPU_ERROR_HEAP_BUFFER_HANDLE_IS_NOT_PRESENT     0x08040100
//    BrandId                             (AppFunction =      02h)
#define CPU_ERROR_BRANDID_HEAP_NOT_AVAILABLE            0x08000200
//    Micro code patch                    (AppFunction =      03h)
#define CPU_ERROR_MICRO_CODE_PATCH_IS_NOT_LOADED        0x08000300
//    Power management                    (AppFunction =      04h)
#define CPU_EVENT_PM_PSTATE_OVERCURRENT                 0x08000400
#define CPU_EVENT_PM_ALL_PSTATE_OVERCURRENT             0x08010400
#define CPU_ERROR_PSTATE_HEAP_NOT_AVAILABLE             0x08020400
#define CPU_ERROR_PM_NB_PSTATE_MISMATCH                 0x08030400
//    BIST                                (AppFunction =      05h)
#define CPU_EVENT_BIST_ERROR                            0x08000500

//=================================================================
// CPU Feature events
//    Execution cache                     (AppFunction =      21h)
//        AGESA_CACHE_SIZE_REDUCED                            2101
//        AGESA_CACHE_REGIONS_ACROSS_1MB                      2102
//        AGESA_CACHE_REGIONS_ACROSS_4GB                      2103
//        AGESA_REGION_NOT_ALIGNED_ON_BOUNDARY                2104
//        AGESA_CACHE_START_ADDRESS_LESS_D0000                2105
//        AGESA_THREE_CACHE_REGIONS_ABOVE_1MB                 2106
//        AGESA_DEALLOCATE_CACHE_REGIONS                      2107
#define CPU_EVENT_EXECUTION_CACHE_ALLOCATION_ERROR      0x08002100
//    Core Leveling                       (AppFunction =      22h)
#define CPU_WARNING_ADJUSTED_LEVELING_MODE              0x08002200
//    HT Assist                           (AppFunction =      23h)
#define CPU_WARNING_NONOPTIMAL_HT_ASSIST_CFG            0x08002300

// CPU Build Configuration structures and definitions

/// Build Configuration structure for BLDCFG_AP_MTRR_SETTINGS
typedef struct {
  IN  UINT32 MsrAddr;     ///< Fixed-Sized MTRR address
  IN  UINT64 MsrData;     ///< MTRR Settings
} AP_MTRR_SETTINGS;

#define AMD_AP_MTRR_FIX64k_00000    0x00000250
#define AMD_AP_MTRR_FIX16k_80000    0x00000258
#define AMD_AP_MTRR_FIX16k_A0000    0x00000259
#define AMD_AP_MTRR_FIX4k_C0000     0x00000268
#define AMD_AP_MTRR_FIX4k_C8000     0x00000269
#define AMD_AP_MTRR_FIX4k_D0000     0x0000026A
#define AMD_AP_MTRR_FIX4k_D8000     0x0000026B
#define AMD_AP_MTRR_FIX4k_E0000     0x0000026C
#define AMD_AP_MTRR_FIX4k_E8000     0x0000026D
#define AMD_AP_MTRR_FIX4k_F0000     0x0000026E
#define AMD_AP_MTRR_FIX4k_F8000     0x0000026F
#define CPU_LIST_TERMINAL           0xFFFFFFFF

/************************************************************************
 *
 *  AGESA interface Call-Out function parameter structures
 *
 ***********************************************************************/

/// Parameters structure for interface call-out AgesaAllocateBuffer
typedef struct {
  IN OUT    AMD_CONFIG_PARAMS   StdHeader;      ///< Standard configuration header
  IN OUT    UINT32              BufferLength;   ///< Size of buffer to allocate
  IN        UINT32              BufferHandle;   ///< Identifier or name for the buffer
  OUT       VOID                *BufferPointer; ///< location of the created buffer
} AGESA_BUFFER_PARAMS;

/// Parameters structure for interface call-out AgesaRunCodeOnAp
typedef struct {
  IN OUT    AMD_CONFIG_PARAMS   StdHeader;            ///< Standard configuration header
  IN        UINT32              FunctionNumber;       ///< Index of the procedure to execute
  IN        VOID                *RelatedDataBlock;    ///< Location of data structure the procedure will use
  IN        UINT32              RelatedBlockLength;   ///< Size of the related data block
} AP_EXE_PARAMS;

/// Parameters structure for the interface call-out AgesaReadSpd & AgesaReadSpdRecovery
typedef struct {
  IN OUT    AMD_CONFIG_PARAMS   StdHeader;      ///< Standard configuration header
  IN        UINT8               SocketId;       ///< Address of SPD - socket ID
  IN        UINT8               MemChannelId;   ///< Address of SPD - memory channel ID
  IN        UINT8               DimmId;         ///< Address of SPD - DIMM ID
  IN OUT    UINT8               *Buffer;        ///< Location where to place the SPD content
  IN OUT    MEM_DATA_STRUCT     *MemData;       ///< Location of the MemData structure, for reference
} AGESA_READ_SPD_PARAMS;

/// Buffer Handles
typedef enum {
  AMD_DMI_INFO_BUFFER_HANDLE = 0x000D000,       ///< Assign 0x000D000 buffer handle to DMI function
  AMD_PSTATE_DATA_BUFFER_HANDLE,                ///< Assign 0x000D001 buffer handle to Pstate data
  AMD_PSTATE_ACPI_BUFFER_HANDLE,                ///< Assign 0x000D002 buffer handle to Pstate table
  AMD_BRAND_ID_BUFFER_HANDLE,                   ///< Assign 0x000D003 buffer handle to Brand ID
  AMD_ACPI_SLIT_BUFFER_HANDLE,                  ///< Assign 0x000D004 buffer handle to SLIT function
  AMD_SRAT_INFO_BUFFER_HANDLE,                  ///< Assign 0x000D005 buffer handle to SRAT function
  AMD_WHEA_BUFFER_HANDLE,                       ///< Assign 0x000D006 buffer handle to WHEA function
  AMD_S3_INFO_BUFFER_HANDLE,                    ///< Assign 0x000D007 buffer handle to S3 function
  AMD_S3_NB_INFO_BUFFER_HANDLE,                 ///< Assign 0x000D008 buffer handle to S3 NB device info
  AMD_ACPI_ALIB_BUFFER_HANDLE                   ///< Assign 0x000D009 buffer handle to ALIB SSDT table
} AMD_BUFFER_HANDLE;
/************************************************************************
 *
 *  AGESA interface Call-Out function prototypes
 *
 ***********************************************************************/

VOID
AgesaDoReset (
  IN        UINTN               ResetType,
  IN OUT    AMD_CONFIG_PARAMS   *StdHeader
  );

AGESA_STATUS
AgesaAllocateBuffer (
  IN      UINTN                 FcnData,
  IN OUT  AGESA_BUFFER_PARAMS   *AllocParams
  );

AGESA_STATUS
AgesaDeallocateBuffer (
  IN      UINTN                 FcnData,
  IN OUT  AGESA_BUFFER_PARAMS   *DeallocParams
  );

AGESA_STATUS
AgesaLocateBuffer (
  IN      UINTN                 FcnData,
  IN OUT  AGESA_BUFFER_PARAMS   *LocateParams
  );

AGESA_STATUS
AgesaReadSpd (
  IN        UINTN                 FcnData,
  IN OUT    AGESA_READ_SPD_PARAMS *ReadSpd
  );

AGESA_STATUS
AgesaReadSpdRecovery (
  IN        UINTN                 FcnData,
  IN OUT    AGESA_READ_SPD_PARAMS *ReadSpd
  );

AGESA_STATUS
AgesaHookBeforeDramInitRecovery (
  IN       UINTN           FcnData,
  IN OUT   MEM_DATA_STRUCT *MemData
  );

AGESA_STATUS
AgesaRunFcnOnAp (
  IN        UINTN               ApicIdOfCore,
  IN        AP_EXE_PARAMS       *LaunchApParams
  );

AGESA_STATUS
AgesaHookBeforeDramInit (
  IN        UINTN               FcnData,
  IN OUT    MEM_DATA_STRUCT     *MemData
  );

AGESA_STATUS
AgesaHookBeforeDQSTraining (
  IN        UINTN               FcnData,
  IN OUT    MEM_DATA_STRUCT     *MemData
  );

AGESA_STATUS
AgesaHookBeforeExitSelfRefresh (
  IN        UINTN               FcnData,
  IN OUT    MEM_DATA_STRUCT     *MemData
  );

AGESA_STATUS
AgesaPcieSlotResetControl (
  IN      UINTN                 FcnData,
  IN      PCIe_SLOT_RESET_INFO  *ResetInfo
 );

/************************************************************************
 *
 *  AGESA interface structure definition and function prototypes
 *
 ***********************************************************************/

/**********************************************************************
 * Platform Configuration:  The parameters in boot branch function
 **********************************************************************/

///  The possible platform control flow settings.
typedef enum  {
  Nfcm,                                          ///< Normal Flow Control Mode.
  UmaDr,                                         ///< UMA using Display Refresh flow control.
  UmaIfcm,                                       ///< UMA using Isochronous Flow Control.
  Ifcm,                                          ///< Isochronous Flow Control Mode (other than for UMA).
  Iommu,                                         ///< An IOMMU is in use in the system.
  MaxControlFlow                                 ///< Not a control flow mode, use for limit checking.
} PLATFORM_CONTROL_FLOW;

///  Platform Deemphasis Levels.
///
/// The deemphasis level is set for the receiver, based on link characterization.  The DCV level is
/// set based on the level of the far transmitter.
typedef enum {
  DeemphasisLevelNone,                           ///< No Deemphasis.
  DeemphasisLevelMinus3,                         ///< Minus 3 db deemphasis.
  DeemphasisLevelMinus6,                         ///< Minus 6 db deemphasis.
  DeemphasisLevelMinus8,                         ///< Minus 8 db deemphasis.
  DeemphasisLevelMinus11,                        ///< Minus 11 db deemphasis.
  DeemphasisLevelMinus11pre8,                    ///< Minus 11, Minus 8 precursor db deemphasis.
  DcvLevelNone = 16,                             ///< No DCV Deemphasis.
  DcvLevelMinus2,                                ///< Minus 2 db DCV deemphasis.
  DcvLevelMinus3,                                ///< Minus 3 db DCV deemphasis.
  DcvLevelMinus5,                                ///< Minus 5 db DCV deemphasis.
  DcvLevelMinus6,                                ///< Minus 6 db DCV deemphasis.
  DcvLevelMinus7,                                ///< Minus 7 db DCV deemphasis.
  DcvLevelMinus8,                                ///< Minus 8 db DCV deemphasis.
  DcvLevelMinus9,                                ///< Minus 9 db DCV deemphasis.
  DcvLevelMinus11,                               ///< Minus 11 db DCV deemphasis.
  MaxPlatformDeemphasisLevel                     ///< Not a deemphasis level, use for limit checking.
} PLATFORM_DEEMPHASIS_LEVEL;

///  Provide Deemphasis Levels for HT Links.
///
///  For each CPU to CPU or CPU to IO device HT link, the list of Deemphasis Levels will
///  be checked for a match.  The item matches for a Socket, Link if the link frequency is
///  is in the inclusive range HighFreq:LoFreq.
///  AGESA does not set deemphasis in IO devices, only in processors.

typedef struct {
  // Match fields
  IN       UINT8 Socket;                                        ///< One Socket on which this Link is located
  IN       UINT8 Link;                                          ///< The Link on this Processor.
  IN       UINT8 LoFreq;                                        ///< If the link is set to this frequency or greater, apply these levels, and
  IN       UINT8 HighFreq;                                      ///< If the link is set to this frequency or less, apply these levels.
  // Value fields
  IN       PLATFORM_DEEMPHASIS_LEVEL     ReceiverDeemphasis;    ///< The deemphasis level for this link
  IN       PLATFORM_DEEMPHASIS_LEVEL     DcvDeemphasis;         ///< The DCV, or far transmitter deemphasis level.
} CPU_HT_DEEMPHASIS_LEVEL;

///  The possible platform power policy settings.
typedef enum  {
  Performance,                                   ///< Optimize for performance.
  BatteryLife,                                   ///< Optimize for battery life.
  MaxPowerPolicy                                 ///< Not a power policy mode, use for limit checking.
} PLATFORM_POWER_POLICY;

///  Platform performance settings for optimized settings.
///  Several configuration settings for the processor depend upon other parts and
///  general designer choices for the system. The determination of these data points
///  is not standard for all platforms, so the host environment needs to provide these
///  to specify how the system is to be configured.
typedef struct {
  IN PLATFORM_CONTROL_FLOW PlatformControlFlowMode;    ///< The platform's control flow mode for optimum platform performance.
                                                       ///< @BldCfgItem{BLDCFG_PLATFORM_CONTROL_FLOW_MODE}
  IN BOOLEAN               UseHtAssist;                ///< HyperTransport link traffic optimization.
                                                       ///< @BldCfgItem{BLDCFG_USE_HT_ASSIST}
  IN BOOLEAN               UseAtmMode;                 ///< HyperTransport link traffic optimization.
                                                       ///< @BldCfgItem{BLDCFG_USE_ATM_MODE}
  IN BOOLEAN               Use32ByteRefresh;           ///< Display Refresh traffic generates 32 byte requests.
                                                       ///< @BldCfgItem{BLDCFG_USE_32_BYTE_REFRESH}
  IN BOOLEAN               UseVariableMctIsocPriority; ///< The Memory controller will be set to Variable Isoc Priority.
                                                       ///< @BldCfgItem{BLDCFG_USE_VARIABLE_MCT_ISOC_PRIORITY}
  IN PLATFORM_POWER_POLICY PlatformPowerPolicy;        ///< The platform's desired power policy
                                                       ///< @BldCfgItem{BLDCFG_PLATFORM_POWER_POLICY_MODE}
} PERFORMANCE_PROFILE;

///  Platform settings that describe the voltage regulator modules of the system.
///  Many power management settings are dependent upon the characteristics of the
///  on-board voltage regulator module (VRM).  The host environment needs to provide
///  these to specify how the system is to be configured.
typedef struct {
  IN UINT32  CurrentLimit;                         ///< Vrm Current Limit.
                                                   ///< @BldCfgItem{BLDCFG_VRM_CURRENT_LIMIT}
                                                   ///< @BldCfgItem{BLDCFG_VRM_NB_CURRENT_LIMIT}
  IN UINT32  LowPowerThreshold;                    ///< Vrm Low Power Threshold.
                                                   ///< @BldCfgItem{BLDCFG_VRM_LOW_POWER_THRESHOLD}
                                                   ///< @BldCfgItem{BLDCFG_VRM_NB_LOW_POWER_THRESHOLD}
  IN UINT32  SlewRate;                             ///< Vrm Slew Rate.
                                                   ///< @BldCfgItem{BLDCFG_VRM_SLEW_RATE}
                                                   ///< @BldCfgItem{BLDCFG_VRM_NB_SLEW_RATE}
  IN UINT32  AdditionalDelay;                      ///< Vrm Additional Delay.
                                                   ///< @BldCfgItem{BLDCFG_VRM_ADDITIONAL_DELAY}
                                                   ///< @BldCfgItem{BLDCFG_VRM_NB_ADDITIONAL_DELAY}
  IN BOOLEAN HiSpeedEnable;                        ///< Select high speed VRM.
                                                   ///< @BldCfgItem{BLDCFG_VRM_HIGH_SPEED_ENABLE}
                                                   ///< @BldCfgItem{BLDCFG_VRM_NB_HIGH_SPEED_ENABLE}
  IN UINT32  InrushCurrentLimit;                   ///< Vrm Inrush Current Limit.
                                                   ///< @BldCfgItem{BLDCFG_VRM_INRUSH_CURRENT_LIMIT}
                                                   ///< @BldCfgItem{BLDCFG_VRM_NB_INRUSH_CURRENT_LIMIT}
} PLATFORM_VRM_CONFIGURATION;

///  The VRM types to characterize.
typedef enum  {
  CoreVrm,                                       ///< VDD plane.
  NbVrm,                                         ///< VDDNB plane.
  MaxVrmType                                     ///< Not a valid VRM type, use for limit checking.
} PLATFORM_VRM_TYPE;


/// Build Option/Configuration Boolean Structure.
typedef struct {
  IN  AMD_CODE_HEADER VersionString;              ///< AMD embedded code version string

  //Build Option Area
  IN BOOLEAN OptionUDimms;                        ///< @ref BLDOPT_REMOVE_UDIMMS_SUPPORT "BLDOPT_REMOVE_UDIMMS_SUPPORT"
  IN BOOLEAN OptionRDimms;                        ///< @ref BLDOPT_REMOVE_RDIMMS_SUPPORT "BLDOPT_REMOVE_RDIMMS_SUPPORT"
  IN BOOLEAN OptionLrDimms;                      ///< @ref BLDOPT_REMOVE_LRDIMMS_SUPPORT "BLDOPT_REMOVE_LRDIMMS_SUPPORT"
  IN BOOLEAN OptionEcc;                           ///< @ref BLDOPT_REMOVE_ECC_SUPPORT "BLDOPT_REMOVE_ECC_SUPPORT"
  IN BOOLEAN OptionBankInterleave;                ///< @ref BLDOPT_REMOVE_BANK_INTERLEAVE "BLDOPT_REMOVE_BANK_INTERLEAVE"
  IN BOOLEAN OptionDctInterleave;                 ///< @ref BLDOPT_REMOVE_DCT_INTERLEAVE "BLDOPT_REMOVE_DCT_INTERLEAVE"
  IN BOOLEAN OptionNodeInterleave;                ///< @ref BLDOPT_REMOVE_NODE_INTERLEAVE "BLDOPT_REMOVE_NODE_INTERLEAVE"
  IN BOOLEAN OptionParallelTraining;              ///< @ref BLDOPT_REMOVE_PARALLEL_TRAINING "BLDOPT_REMOVE_PARALLEL_TRAINING"
  IN BOOLEAN OptionOnlineSpare;                   ///< @ref BLDOPT_REMOVE_ONLINE_SPARE_SUPPORT "BLDOPT_REMOVE_ONLINE_SPARE_SUPPORT"
  IN BOOLEAN OptionMemRestore;                    ///< @ref BLDOPT_REMOVE_MEM_RESTORE_SUPPORT "BLDOPT_REMOVE_MEM_RESTORE_SUPPORT"
  IN BOOLEAN OptionMultisocket;                   ///< @ref BLDOPT_REMOVE_MULTISOCKET_SUPPORT "BLDOPT_REMOVE_MULTISOCKET_SUPPORT"
  IN BOOLEAN OptionAcpiPstates;                   ///< @ref BLDOPT_REMOVE_ACPI_PSTATES "BLDOPT_REMOVE_ACPI_PSTATES"
  IN BOOLEAN OptionSrat;                          ///< @ref BLDOPT_REMOVE_SRAT "BLDOPT_REMOVE_SRAT"
  IN BOOLEAN OptionSlit;                          ///< @ref BLDOPT_REMOVE_SLIT "BLDOPT_REMOVE_SLIT"
  IN BOOLEAN OptionWhea;                          ///< @ref BLDOPT_REMOVE_WHEA "BLDOPT_REMOVE_WHEA"
  IN BOOLEAN OptionDmi;                           ///< @ref BLDOPT_REMOVE_DMI "BLDOPT_REMOVE_DMI"
  IN BOOLEAN OptionEarlySamples;                  ///< @ref BLDOPT_REMOVE_EARLY_SAMPLES "BLDOPT_REMOVE_EARLY_SAMPLES"
  IN BOOLEAN OptionAddrToCsTranslator;            ///< ADDR_TO_CS_TRANSLATOR

  //Build Configuration Area
  IN UINT64 CfgPciMmioAddress;                    ///< Pci Mmio Base Address to use for PCI Config accesses.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_PCI_MMIO_BASE}
  IN UINT32 CfgPciMmioSize;                       ///< Pci Mmio region Size.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_PCI_MMIO_SIZE}
  IN PLATFORM_VRM_CONFIGURATION CfgPlatVrmCfg[MaxVrmType]; ///< Several configuration settings for the voltage regulator modules.
  IN UINT32 CfgPlatNumIoApics;                    ///< The number of IO APICS for the platform.
  IN UINT32 CfgMemInitPstate;                     ///< Memory Init Pstate.
  IN PLATFORM_C1E_MODES CfgPlatformC1eMode;       ///< Select the C1e Mode that will used.
  IN UINT32 CfgPlatformC1eOpData;                 ///< An IO port or additional C1e setup data, depends on C1e mode.
  IN UINT32 CfgPlatformC1eOpData1;                ///< An IO port or additional C1e setup data, depends on C1e mode.
  IN UINT32 CfgPlatformC1eOpData2;                ///< An IO port or additional C1e setup data, depends on C1e mode.
  IN PLATFORM_CSTATE_MODES CfgPlatformCStateMode; ///< Select the C-State Mode that will used.
  IN UINT32 CfgPlatformCStateOpData;              ///< An IO port or additional C-State setup data, depends on C-State mode.
  IN UINT16 CfgPlatformCStateIoBaseAddress;       ///< Specifies I/O ports that can be used to allow CPU to enter CStates
  IN PLATFORM_CPB_MODES CfgPlatformCpbMode;       ///< Enable or disable core performance boost
  IN UINT32 CfgCoreLevelingMode;                  ///< Apply any downcoring or core count leveling as specified.
  IN PERFORMANCE_PROFILE CfgPerformanceProfile;   ///< The platform's control flow mode and platform performance settings.
  IN CPU_HT_DEEMPHASIS_LEVEL *CfgPlatformDeemphasisList; ///< Deemphasis levels for the platform's HT links.

  IN UINT32 CfgAmdPlatformType;                   ///< Designate the platform as a Server, Desktop, or Mobile.
  IN UINT32 CfgAmdPstateCapValue;                 ///< Amd pstate ceiling enabling deck

  IN MEMORY_BUS_SPEED CfgMemoryBusFrequencyLimit; ///< Memory Bus Frequency Limit.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_MEMORY_BUS_FREQUENCY_LIMIT}
  IN BOOLEAN CfgMemoryModeUnganged;               ///< Memory Mode Unganged.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_MEMORY_MODE_UNGANGED}
  IN BOOLEAN CfgMemoryQuadRankCapable;            ///< Memory Quad Rank Capable.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_MEMORY_QUAD_RANK_CAPABLE}
  IN QUANDRANK_TYPE CfgMemoryQuadrankType;        ///< Memory Quadrank Type.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_MEMORY_QUADRANK_TYPE}
  IN BOOLEAN CfgMemoryRDimmCapable;               ///< Memory RDIMM Capable.
  IN BOOLEAN CfgMemoryLRDimmCapable;              ///< Memory LRDIMM Capable.
  IN BOOLEAN CfgMemoryUDimmCapable;               ///< Memory UDIMM Capable.
  IN BOOLEAN CfgMemorySODimmCapable;              ///< Memory SODimm Capable.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_MEMORY_SODIMM_CAPABLE}
  IN BOOLEAN CfgMemoryEnableBankInterleaving;     ///< Memory Enable Bank Interleaving.
  IN BOOLEAN CfgMemoryEnableNodeInterleaving;     ///< Memory Enable Node Interleaving.
  IN BOOLEAN CfgMemoryChannelInterleaving;        ///< Memory Channel Interleaving.
  IN BOOLEAN CfgMemoryPowerDown;                  ///< Memory Power Down.
  IN POWER_DOWN_MODE CfgPowerDownMode;            ///< Power Down Mode.
  IN BOOLEAN CfgOnlineSpare;                      ///< Online Spare.
  IN BOOLEAN CfgMemoryParityEnable;               ///< Memory Parity Enable.
  IN BOOLEAN CfgBankSwizzle;                      ///< Bank Swizzle.
  IN USER_MEMORY_TIMING_MODE CfgTimingModeSelect; ///< Timing Mode Select.
  IN MEMORY_BUS_SPEED CfgMemoryClockSelect;       ///< Memory Clock Select.
  IN BOOLEAN CfgDqsTrainingControl;               ///< Dqs Training Control.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_DQS_TRAINING_CONTROL}
  IN BOOLEAN CfgIgnoreSpdChecksum;                ///< Ignore Spd Checksum.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_IGNORE_SPD_CHECKSUM}
  IN BOOLEAN CfgUseBurstMode;                     ///< Use Burst Mode.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_USE_BURST_MODE}
  IN BOOLEAN CfgMemoryAllClocksOn;                ///< Memory All Clocks On.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_MEMORY_ALL_CLOCKS_ON}
  IN BOOLEAN CfgEnableEccFeature;                 ///< Enable ECC Feature.
  IN BOOLEAN CfgEccRedirection;                   ///< ECC Redirection.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_ECC_REDIRECTION}
  IN UINT16  CfgScrubDramRate;                    ///< Scrub Dram Rate.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_SCRUB_DRAM_RATE}
  IN UINT16  CfgScrubL2Rate;                      ///< Scrub L2Rate.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_SCRUB_L2_RATE}
  IN UINT16  CfgScrubL3Rate;                      ///< Scrub L3Rate.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_SCRUB_L3_RATE}
  IN UINT16  CfgScrubIcRate;                      ///< Scrub Ic Rate.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_SCRUB_IC_RATE}
  IN UINT16  CfgScrubDcRate;                      ///< Scrub Dc Rate.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_SCRUB_DC_RATE}
  IN BOOLEAN CfgEccSyncFlood;                     ///< ECC Sync Flood.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_ECC_SYNC_FLOOD}
  IN UINT16  CfgEccSymbolSize;                    ///< ECC Symbol Size.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_ECC_SYMBOL_SIZE}
  IN UINT64  CfgHeapDramAddress;                  ///< Heap contents will be temporarily stored in this address during the transition.
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_HEAP_DRAM_ADDRESS}
  IN BOOLEAN CfgNodeMem1GBAlign;                  ///< Node Mem 1GB boundary Alignment
  IN BOOLEAN CfgS3LateRestore;                    ///< S3 Late Restore
  IN BOOLEAN CfgAcpiPstateIndependent;            ///< PSD method dependent/Independent
  IN AP_MTRR_SETTINGS *CfgApMtrrSettingsList;     ///< The AP's MTRR settings before final halt
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_AP_MTRR_SETTINGS_LIST}
  IN UMA_MODE CfgUmaMode;                         ///< Uma Mode
  IN UINT32 CfgUmaSize;                           ///< Uma Size [31:0]=Addr[47:16]
  IN BOOLEAN CfgUmaAbove4G;                       ///< Uma Above 4G Support
  IN UMA_ALIGNMENT CfgUmaAlignment;               ///< Uma alignment
  IN BOOLEAN CfgProcessorScopeInSb;               ///< ACPI Processor Object in \\_SB scope
  IN CHAR8   CfgProcessorScopeName0;              ///< OEM specific 1st character of processor scope name.
  IN CHAR8   CfgProcessorScopeName1;              ///< OEM specific 2nd character of processor scope name.
  IN UINT8   CfgGnbHdAudio;                       ///< GNB HD Audio
  IN UINT8   CfgAbmSupport;                       ///< Abm Support
  IN UINT8   CfgDynamicRefreshRate;               ///< DRR Dynamic Refresh Rate
  IN UINT16  CfgLcdBackLightControl;              ///< LCD Backlight Control
  IN UINT8   CfgGnb3dStereoPinIndex;                ///< 3D Stereo Pin ID.
  IN UINT32  CfgTempPcieMmioBaseAddress;          ///< Temp pcie MMIO base Address
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_TEMP_PCIE_MMIO_BASE_ADDRESS}
  IN UINT32  CfgGnbIGPUSSID;                      ///< Gnb internal GPU SSID
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_IGPU_SUBSYSTEM_ID}
  IN UINT32  CfgGnbHDAudioSSID;                   ///< Gnb HD Audio SSID
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_IGPU_HD_AUDIO_SUBSYSTEM_ID}
  IN UINT32  CfgGnbPcieSSID;                      ///< Gnb PCIe SSID
                                                  ///< Build-time customizable only - @BldCfgItem{BLFCFG_APU_PCIE_PORTS_SUBSYSTEM_ID}
  IN UINT16  CfgLvdsSpreadSpectrum;               ///< Lvds Spread Spectrum
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_GFX_LVDS_SPREAD_SPECTRUM}
  IN UINT16  CfgLvdsSpreadSpectrumRate;           ///< Lvds Spread Spectrum Rate
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_GFX_LVDS_SPREAD_SPECTRUM_RATE}
  IN LVDS_MISC_CONTROL CfgLvdsMiscControl;        ///< The LVDS Misc control
  IN UINT16     CfgPcieRefClkSpreadSpectrum;      ///< PCIe Reference Clock Spread Spectrum
                                                  ///< Build-time customizable only - @BldCfgItem{BLDCFG_PCIE_REFCLK_SPREAD_SPECTRUM}
  IN BOOLEAN Reserved;                            ///< reserved...
} BUILD_OPT_CFG;

///  A structure containing platform specific operational characteristics. This
///  structure is initially populated by the initializer with a copy of the same
///  structure that was created at build time using the build configuration controls.
typedef struct _PLATFORM_CONFIGURATION {
  IN PERFORMANCE_PROFILE PlatformProfile;             ///< Several configuration settings for the processor.
  IN CPU_HT_DEEMPHASIS_LEVEL *PlatformDeemphasisList; ///< Deemphasis levels for the platform's HT links.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_DEEMPHASIS_LIST}.
                                                      ///< @n @e Examples: See @ref DeemphasisExamples "Deemphasis List Examples".
  IN UINT8               CoreLevelingMode;            ///< Indicates how to balance the number of cores per processor.
                                                      ///< @BldCfgItem{BLDCFG_CORE_LEVELING_MODE}
  IN PLATFORM_C1E_MODES  C1eMode;                     ///< Specifies the method of C1e enablement - Disabled, HW, or message based.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_C1E_MODE}
  IN UINT32              C1ePlatformData;             ///< If C1eMode is HW, specifies the P_LVL3 I/O port of the platform.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_C1E_OPDATA}
  IN UINT32              C1ePlatformData1;            ///< If C1eMode is SW, specifies the address of chipset's SMI command port.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_C1E_OPDATA1}
  IN UINT32              C1ePlatformData2;            ///< If C1eMode is SW, specifies the unique number used by the SMI handler to identify SMI source.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_C1E_OPDATA2}
  IN PLATFORM_CSTATE_MODES  CStateMode;               ///< Specifies the method of C-State enablement - Disabled, or C6.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_CSTATE_MODE}
  IN UINT32              CStatePlatformData;          ///< This element specifies some pertinent data needed for the operation of the Cstate feature
                                                      ///< If CStateMode is CStateModeC6, this item is reserved
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_CSTATE_OPDATA}
  IN UINT16              CStateIoBaseAddress;         ///< This item specifies a free block of 8 consecutive bytes of I/O ports that
                                                      ///< can be used to allow the CPU to enter Cstates.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_CSTATE_IO_BASE_ADDRESS}
  IN PLATFORM_CPB_MODES  CpbMode;                     ///< Specifies the method of core performance boost enablement - Disabled, or Auto.
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_CPB_MODE}
  IN BOOLEAN             UserOptionDmi;               ///< When set to TRUE, the DMI data table is generated.
  IN BOOLEAN             UserOptionPState;            ///< When set to TRUE, the PState data tables are generated.
  IN BOOLEAN             UserOptionSrat;              ///< When set to TRUE, the SRAT data table is generated.
  IN BOOLEAN             UserOptionSlit;              ///< When set to TRUE, the SLIT data table is generated.
  IN BOOLEAN             UserOptionWhea;              ///< When set to TRUE, the WHEA data table is generated.
  IN UINT32              PowerCeiling;                ///< P-State Ceiling Enabling Deck - Max power milli-watts.
  IN BOOLEAN             ForcePstateIndependent;      ///< P-State _PSD independence or dependence.
                                                      ///< @BldCfgItem{BLDCFG_FORCE_INDEPENDENT_PSD_OBJECT}
  IN UINT32              NumberOfIoApics;             ///< Number of I/O APICs in the system
                                                      ///< @BldCfgItem{BLDCFG_PLATFORM_NUM_IO_APICS}
  IN PLATFORM_VRM_CONFIGURATION VrmProperties[MaxVrmType]; ///< Several configuration settings for the voltage regulator modules.
  IN BOOLEAN             ProcessorScopeInSb;          ///< ACPI Processor Object in \\_SB scope
                                                      ///< @BldCfgItem{BLDCFG_PROCESSOR_SCOPE_IN_SB}
  IN CHAR8               ProcessorScopeName0;         ///< OEM specific 1st character of processor scope name.
                                                      ///< @BldCfgItem{BLDCFG_PROCESSOR_SCOPE_NAME0}
  IN CHAR8               ProcessorScopeName1;         ///< OEM specific 2nd character of processor scope name.
                                                      ///< @BldCfgItem{BLDCFG_PROCESSOR_SCOPE_NAME1}
  IN UINT8               GnbHdAudio;                  ///< Control GFX HD Audio controller(Used for HDMI and DP display output),
                                                      ///< essentially it enables function 1 of graphics device.
                                                      ///< @li 0 = HD Audio disable
                                                      ///< @li 1 = HD Audio enable
                                                      ///< @BldCfgItem{BLDCFG_CFG_GNB_HD_AUDIO}
  IN UINT8               AbmSupport;                  ///< Automatic adjust LVDS/eDP Back light level support.It is
                                                      ///< characteristic specific to display panel which used by platform design.
                                                      ///< @li 0 = ABM support disabled
                                                      ///< @li 1 = ABM support enabled
                                                      ///< @BldCfgItem{BLDCFG_CFG_ABM_SUPPORT}
  IN UINT8               DynamicRefreshRate;          ///< Adjust refresh rate on LVDS/eDP.
                                                      ///< @BldCfgItem{BLDCFG_CFG_DYNAMIC_REFRESH_RATE}
  IN UINT16              LcdBackLightControl;         ///< The PWM frequency to LCD backlight control.
                                                      ///< If equal to 0 backlight not controlled by iGPU
                                                      ///< @BldCfgItem{BLDCFG_CFG_LCD_BACK_LIGHT_CONTROL}
} PLATFORM_CONFIGURATION;


/**********************************************************************
 * Structures for: AmdInitLate
 **********************************************************************/
#define PROC_VERSION_LENGTH 48
#define MAX_DIMMS_PER_SOCKET 16

/*  Interface Parameter Structures  */
/// DMI Type4 - Processor ID
typedef struct {
  OUT UINT32                    ProcIdLsd;              ///< Lower half of 64b ID
  OUT UINT32                    ProcIdMsd;              ///< Upper half of 64b ID
} TYPE4_PROC_ID;

/// DMI Type 4 - Processor information
typedef struct {
  OUT UINT8                     T4ProcType;             ///< CPU Type
  OUT UINT8                     T4ProcFamily;           ///< Family 1
  OUT TYPE4_PROC_ID             T4ProcId;               ///< Id
  OUT UINT8                     T4Voltage;              ///< Voltage
  OUT UINT16                    T4ExternalClock;        ///< External clock
  OUT UINT16                    T4MaxSpeed;             ///< Max speed
  OUT UINT16                    T4CurrentSpeed;         ///< Current speed
  OUT UINT8                     T4Status;               ///< Status
  OUT UINT8                     T4ProcUpgrade;          ///< Up grade
  OUT UINT8                     T4CoreCount;            ///< Core count
  OUT UINT8                     T4CoreEnabled;          ///< Core Enable
  OUT UINT8                     T4ThreadCount;          ///< Thread count
  OUT UINT16                    T4ProcCharacteristics;  ///< Characteristics
  OUT UINT16                    T4ProcFamily2;          ///< Family 2
  OUT CHAR8                     T4ProcVersion[PROC_VERSION_LENGTH]; ///< Cpu version
} TYPE4_DMI_INFO;

/// DMI Type 7 - Cache information
typedef struct _TYPE7_DMI_INFO {
  OUT UINT16                    T7CacheCfg;             ///< Cache cfg
  OUT UINT16                    T7MaxCacheSize;         ///< Max size
  OUT UINT16                    T7InstallSize;          ///< Install size
  OUT UINT16                    T7SupportedSramType;    ///< Supported Sram Type
  OUT UINT16                    T7CurrentSramType;      ///< Current type
  OUT UINT8                     T7CacheSpeed;           ///< Speed
  OUT UINT8                     T7ErrorCorrectionType;  ///< ECC type
  OUT UINT8                     T7SystemCacheType;      ///< Cache type
  OUT UINT8                     T7Associativity;        ///< Associativity
} TYPE7_DMI_INFO;

/// DMI Type 16 offset 04h - Location
typedef enum {
  OtherLocation = 0x01,                                 ///< Assign 01 to Other
  UnknownLocation,                                      ///< Assign 02 to Unknown
  SystemboardOrMotherboard,                             ///< Assign 03 to systemboard or motherboard
  IsaAddonCard,                                         ///< Assign 04 to ISA add-on card
  EisaAddonCard,                                        ///< Assign 05 to EISA add-on card
  PciAddonCard,                                         ///< Assign 06 to PCI add-on card
  McaAddonCard,                                         ///< Assign 07 to MCA add-on card
  PcmciaAddonCard,                                      ///< Assign 08 to PCMCIA add-on card
  ProprietaryAddonCard,                                 ///< Assign 09 to proprietary add-on card
  NuBus,                                                ///< Assign 0A to NuBus
  Pc98C20AddonCard,                                     ///< Assign 0A0 to PC-98/C20 add-on card
  Pc98C24AddonCard,                                     ///< Assign 0A1 to PC-98/C24 add-on card
  Pc98EAddoncard,                                       ///< Assign 0A2 to PC-98/E add-on card
  Pc98LocalBusAddonCard                                 ///< Assign 0A3 to PC-98/Local bus add-on card
} DMI_T16_LOCATION;

/// DMI Type 16 offset 05h - Memory Error Correction
typedef enum {
  OtherUse = 0x01,                                      ///< Assign 01 to Other
  UnknownUse,                                           ///< Assign 02 to Unknown
  SystemMemory,                                         ///< Assign 03 to system memory
  VideoMemory,                                          ///< Assign 04 to video memory
  FlashMemory,                                          ///< Assign 05 to flash memory
  NonvolatileRam,                                       ///< Assign 06 to non-volatile RAM
  CacheMemory                                           ///< Assign 07 to cache memory
} DMI_T16_USE;

/// DMI Type 16 offset 07h - Maximum Capacity
typedef enum {
  Dmi16OtherErrCorrection = 0x01,                       ///< Assign 01 to Other
  Dmi16UnknownErrCorrection,                            ///< Assign 02 to Unknown
  Dmi16NoneErrCorrection,                               ///< Assign 03 to None
  Dmi16Parity,                                          ///< Assign 04 to parity
  Dmi16SingleBitEcc,                                    ///< Assign 05 to Single-bit ECC
  Dmi16MultiBitEcc,                                     ///< Assign 06 to Multi-bit ECC
  Dmi16Crc                                              ///< Assign 07 to CRC
} DMI_T16_ERROR_CORRECTION;

/// DMI Type 16 - Physical Memory Array
typedef struct {
  OUT DMI_T16_LOCATION          Location;               ///< The physical location of the Memory Array,
                                                        ///< whether on the system board or an add-in board.
  OUT DMI_T16_USE               Use;                    ///< Identifies the function for which the array
                                                        ///< is used.
  OUT DMI_T16_ERROR_CORRECTION  MemoryErrorCorrection;  ///< The primary hardware error correction or
                                                        ///< detection method supported by this memory array.
  OUT UINT32                    MaximumCapacity;        ///< The maximum memory capacity, in kilobytes,
                                                        ///< for the array.
  OUT UINT16                    NumberOfMemoryDevices;  ///< The number of slots or sockets available
                                                        ///< for memory devices in this array.
} TYPE16_DMI_INFO;

/// DMI Type 17 offset 0Eh - Form Factor
typedef enum {
  OtherFormFactor = 0x01,                               ///< Assign 01 to Other
  UnknowFormFactor,                                     ///< Assign 02 to Unknown
  SimmFormFactor,                                       ///< Assign 03 to SIMM
  SipFormFactor,                                        ///< Assign 04 to SIP
  ChipFormFactor,                                       ///< Assign 05 to Chip
  DipFormFactor,                                        ///< Assign 06 to DIP
  ZipFormFactor,                                        ///< Assign 07 to ZIP
  ProprietaryCardFormFactor,                            ///< Assign 08 to Proprietary Card
  DimmFormFactorFormFactor,                             ///< Assign 09 to DIMM
  TsopFormFactor,                                       ///< Assign 10 to TSOP
  RowOfChipsFormFactor,                                 ///< Assign 11 to Row of chips
  RimmFormFactor,                                       ///< Assign 12 to RIMM
  SodimmFormFactor,                                     ///< Assign 13 to SODIMM
  SrimmFormFactor,                                      ///< Assign 14 to SRIMM
  FbDimmFormFactor                                      ///< Assign 15 to FB-DIMM
} DMI_T17_FORM_FACTOR;

/// DMI Type 17 offset 12h - Memory Type
typedef enum {
  OtherMemType = 0x01,                                  ///< Assign 01 to Other
  UnknownMemType,                                       ///< Assign 02 to Unknown
  DramMemType,                                          ///< Assign 03 to DRAM
  EdramMemType,                                         ///< Assign 04 to EDRAM
  VramMemType,                                          ///< Assign 05 to VRAM
  SramMemType,                                          ///< Assign 06 to SRAM
  RamMemType,                                           ///< Assign 07 to RAM
  RomMemType,                                           ///< Assign 08 to ROM
  FlashMemType,                                         ///< Assign 09 to Flash
  EepromMemType,                                        ///< Assign 10 to EEPROM
  FepromMemType,                                        ///< Assign 11 to FEPROM
  EpromMemType,                                         ///< Assign 12 to EPROM
  CdramMemType,                                         ///< Assign 13 to CDRAM
  ThreeDramMemType,                                     ///< Assign 14 to 3DRAM
  SdramMemType,                                         ///< Assign 15 to SDRAM
  SgramMemType,                                         ///< Assign 16 to SGRAM
  RdramMemType,                                         ///< Assign 17 to RDRAM
  DdrMemType,                                           ///< Assign 18 to DDR
  Ddr2MemType,                                          ///< Assign 19 to DDR2
  Ddr2FbdimmMemType,                                    ///< Assign 20 to DDR2 FB-DIMM
  Ddr3MemType = 0x18,                                   ///< Assign 24 to DDR3
  Fbd2MemType                                           ///< Assign 25 to FBD2
} DMI_T17_MEMORY_TYPE;

/// DMI Type 17 offset 13h - Type Detail
typedef struct {
  OUT UINT16                    Reserved1:1;            ///< Reserved
  OUT UINT16                    Other:1;                ///< Other
  OUT UINT16                    Unknown:1;              ///< Unknown
  OUT UINT16                    FastPaged:1;            ///< Fast-Paged
  OUT UINT16                    StaticColumn:1;         ///< Static column
  OUT UINT16                    PseudoStatic:1;         ///< Pseudo-static
  OUT UINT16                    Rambus:1;               ///< RAMBUS
  OUT UINT16                    Synchronous:1;          ///< Synchronous
  OUT UINT16                    Cmos:1;                 ///< CMOS
  OUT UINT16                    Edo:1;                  ///< EDO
  OUT UINT16                    WindowDram:1;           ///< Window DRAM
  OUT UINT16                    CacheDram:1;            ///< Cache Dram
  OUT UINT16                    NonVolatile:1;          ///< Non-volatile
  OUT UINT16                    Reserved2:3;            ///< Reserved
} DMI_T17_TYPE_DETAIL;

/// DMI Type 17 - Memory Device
typedef struct {
  OUT UINT16                    TotalWidth;             ///< Total Width, in bits, of this memory device, including any check or error-correction bits.
  OUT UINT16                    DataWidth;              ///< Data Width, in bits, of this memory device.
  OUT UINT16                    MemorySize;             ///< The size of the memory device.
  OUT DMI_T17_FORM_FACTOR       FormFactor;             ///< The implementation form factor for this memory device.
  OUT UINT8                     DeviceSet;              ///< Identifies when the Memory Device is one of a set of
                                                        ///< Memory Devices that must be populated with all devices of
                                                        ///< the same type and size, and the set to which this device belongs.
  OUT CHAR8                     DeviceLocator[8];       ///< The string number of the string that identifies the physically labeled socket or board position where the memory device is located.
  OUT CHAR8                     BankLocator[10];        ///< The string number of the string that identifies the physically labeled bank where the memory device is located.
  OUT DMI_T17_MEMORY_TYPE       MemoryType;             ///< The type of memory used in this device.
  OUT DMI_T17_TYPE_DETAIL       TypeDetail;             ///< Additional detail on the memory device type
  OUT UINT16                    Speed;                  ///< Identifies the speed of the device, in megahertz (MHz).
  OUT UINT64                    ManufacturerIdCode;     ///< Manufacturer ID code.
  OUT CHAR8                     SerialNumber[9];        ///< Serial Number.
  OUT CHAR8                     PartNumber[19];         ///< Part Number.
  OUT UINT8                     Attributes;             ///< Bits 7-4: Reserved, Bits 3-0: rank.
  OUT UINT32                    ExtSize;                ///< Extended Size.
  OUT UINT16                    ConfigSpeed;            ///< Configured memory clock speed
} TYPE17_DMI_INFO;

/// Memory DMI Type 17 and 20 - for memory use
typedef struct {
  OUT UINT16                    TotalWidth;             ///< Total Width, in bits, of this memory device, including any check or error-correction bits.
  OUT UINT16                    DataWidth;              ///< Data Width, in bits, of this memory device.
  OUT UINT16                    MemorySize;             ///< The size of the memory device.
  OUT DMI_T17_FORM_FACTOR       FormFactor;             ///< The implementation form factor for this memory device.
  OUT UINT8                     DeviceLocator;          ///< The string number of the string that identifies the physically labeled socket or board position where the memory device is located.
  OUT UINT8                     BankLocator;            ///< The string number of the string that identifies the physically labeled bank where the memory device is located.
  OUT UINT16                    Speed;                  ///< Identifies the speed of the device, in megahertz (MHz).
  OUT UINT64                    ManufacturerIdCode;     ///< Manufacturer ID code.
  OUT UINT8                     SerialNumber[4];        ///< Serial Number.
  OUT UINT8                     PartNumber[18];         ///< Part Number.
  OUT UINT8                     Attributes;             ///< Bits 7-4: Reserved, Bits 3-0: rank.
  OUT UINT32                    ExtSize;                ///< Extended Size.
  OUT UINT8                     Socket:3;               ///< Socket ID
  OUT UINT8                     Channel:2;              ///< Channel ID
  OUT UINT8                     Dimm:2;                 ///< DIMM ID
  OUT UINT8                     DimmPresent:1;          ///< Dimm Present
  OUT UINT32                    StartingAddr;           ///< The physical address, in kilobytes, of a range
                                                        ///< of memory mapped to the referenced Memory Device.
  OUT UINT32                    EndingAddr;             ///< The handle, or instance number, associated with
                                                        ///< the Memory Device structure to which this address
                                                        ///< range is mapped.
  OUT UINT16                    ConfigSpeed;            ///< Configured memory clock speed
} MEM_DMI_INFO;

/// DMI Type 19 - Memory Array Mapped Address
typedef struct {
  OUT UINT32                    StartingAddr;           ///< The physical address, in kilobytes,
                                                        ///< of a range of memory mapped to the
                                                        ///< specified physical memory array.
  OUT UINT32                    EndingAddr;             ///< The physical ending address of the
                                                        ///< last kilobyte of a range of addresses
                                                        ///< mapped to the specified physical memory array.
  OUT UINT16                    MemoryArrayHandle;      ///< The handle, or instance number, associated
                                                        ///< with the physical memory array to which this
                                                        ///< address range is mapped.
  OUT UINT8                     PartitionWidth;         ///< Identifies the number of memory devices that
                                                        ///< form a single row of memory for the address
                                                        ///< partition defined by this structure.
} TYPE19_DMI_INFO;

///DMI Type 20 - Memory Device Mapped Address
typedef struct {
  OUT UINT32                    StartingAddr;           ///< The physical address, in kilobytes, of a range
                                                        ///< of memory mapped to the referenced Memory Device.
  OUT UINT32                    EndingAddr;             ///< The handle, or instance number, associated with
                                                        ///< the Memory Device structure to which this address
                                                        ///< range is mapped.
  OUT UINT16                    MemoryDeviceHandle;     ///< The handle, or instance number, associated with
                                                        ///< the Memory Device structure to which this address
                                                        ///< range is mapped.
  OUT UINT16                    MemoryArrayMappedAddressHandle; ///< The handle, or instance number, associated
                                                        ///< with the Memory Array Mapped Address structure to
                                                        ///< which this device address range is mapped.
  OUT UINT8                     PartitionRowPosition;   ///< Identifies the position of the referenced Memory
                                                        ///< Device in a row of the address partition.
  OUT UINT8                     InterleavePosition;     ///< The position of the referenced Memory Device in
                                                        ///< an interleave.
  OUT UINT8                     InterleavedDataDepth;   ///< The maximum number of consecutive rows from the
                                                        ///< referenced Memory Device that are accessed in a
                                                        ///< single interleaved transfer.
} TYPE20_DMI_INFO;

/// Collection of pointers to the DMI records
typedef struct {
  OUT TYPE4_DMI_INFO            T4[MAX_SOCKETS_SUPPORTED];    ///< Type 4 struc
  OUT TYPE7_DMI_INFO            T7L1[MAX_SOCKETS_SUPPORTED];  ///< Type 7 struc 1
  OUT TYPE7_DMI_INFO            T7L2[MAX_SOCKETS_SUPPORTED];  ///< Type 7 struc 2
  OUT TYPE7_DMI_INFO            T7L3[MAX_SOCKETS_SUPPORTED];  ///< Type 7 struc 3
  OUT TYPE16_DMI_INFO           T16;                          ///< Type 16 struc
  OUT TYPE17_DMI_INFO           T17[MAX_SOCKETS_SUPPORTED][MAX_CHANNELS_PER_SOCKET][MAX_DIMMS_PER_CHANNEL]; ///< Type 17 struc
  OUT TYPE19_DMI_INFO           T19;                          ///< Type 19 struc
  OUT TYPE20_DMI_INFO           T20[MAX_SOCKETS_SUPPORTED][MAX_CHANNELS_PER_SOCKET][MAX_DIMMS_PER_CHANNEL]; ///< Type 20 struc
} DMI_INFO;

/**********************************************************************
 * Interface call:  AllocateExecutionCache
 **********************************************************************/
#define MAX_CACHE_REGIONS    3

/// AllocateExecutionCache sub param structure for cached memory region
typedef struct {
  IN OUT   UINT32               ExeCacheStartAddr;      ///< Start address
  IN OUT   UINT32               ExeCacheSize;           ///< Size
} EXECUTION_CACHE_REGION;

/**********************************************************************
 * Interface call:  AmdGetAvailableExeCacheSize
 **********************************************************************/
/// Get available Cache remain
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS    StdHeader;              ///< Standard configuration header
     OUT   UINT32               AvailableExeCacheSize;  ///< Remain size
} AMD_GET_EXE_SIZE_PARAMS;

AGESA_STATUS
AmdGetAvailableExeCacheSize (
  IN OUT   AMD_GET_EXE_SIZE_PARAMS *AmdGetExeSizeParams
  );

/// Selection type for core leveling
typedef enum {
  CORE_LEVEL_LOWEST,            ///< Level to lowest common denominator
  CORE_LEVEL_TWO,               ///< Level to 2 cores
  CORE_LEVEL_POWER_OF_TWO,      ///< Level to 1,2,4 or 8
  CORE_LEVEL_NONE,              ///< Do no leveling
  CORE_LEVEL_COMPUTE_UNIT,      ///< Level cores to one core per compute unit
  CORE_LEVEL_ONE,               ///< Level to 1 core
  CORE_LEVEL_THREE,             ///< Level to 3 cores
  CORE_LEVEL_FOUR,              ///< Level to 4 cores
  CORE_LEVEL_FIVE,              ///< Level to 5 cores
  CORE_LEVEL_SIX,               ///< Level to 6 cores
  CORE_LEVEL_SEVEN,             ///< Level to 7 cores
  CORE_LEVEL_EIGHT,             ///< Level to 8 cores
  CORE_LEVEL_NINE,              ///< Level to 9 cores
  CORE_LEVEL_TEN,               ///< Level to 10 cores
  CORE_LEVEL_ELEVEN,            ///< Level to 11 cores
  CORE_LEVEL_TWELVE,            ///< Level to 12 cores
  CORE_LEVEL_THIRTEEN,          ///< Level to 13 cores
  CORE_LEVEL_FOURTEEN,          ///< Level to 14 cores
  CORE_LEVEL_FIFTEEN,           ///< Level to 15 cores
  CoreLevelModeMax              ///< Used for bounds checking
} CORE_LEVELING_TYPE;





/************************************************************************
 *
 *  AGESA Basic Level interface structure definition and function prototypes
 *
 ***********************************************************************/

/**********************************************************************
 * Interface call:  AmdCreateStruct
 **********************************************************************/
AGESA_STATUS
AmdCreateStruct (
  IN OUT   AMD_INTERFACE_PARAMS *InterfaceParams
  );

/**********************************************************************
 * Interface call:  AmdReleaseStruct
 **********************************************************************/
AGESA_STATUS
AmdReleaseStruct (
  IN OUT   AMD_INTERFACE_PARAMS *InterfaceParams
  );

/**********************************************************************
 * Interface call:  AmdInitReset
 **********************************************************************/
/// AmdInitReset param structure
typedef struct {
  IN       AMD_CONFIG_PARAMS         StdHeader;        ///< Standard configuration header
  IN       EXECUTION_CACHE_REGION    CacheRegion[3];   ///< The cached memory region
  IN       AMD_HT_RESET_INTERFACE    HtConfig;         ///< The interface for Ht Recovery
} AMD_RESET_PARAMS;

AGESA_STATUS
AmdInitReset (
  IN OUT   AMD_RESET_PARAMS     *ResetParams
  );


/**********************************************************************
 * Interface call:  AmdInitEarly
 **********************************************************************/
/// InitEarly param structure
///
/// Provide defaults or customizations to each service performed in AmdInitEarly.
///
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS      StdHeader;        ///< Standard configuration header
  IN       EXECUTION_CACHE_REGION CacheRegion[3];   ///< Execution Map Interface
  IN       PLATFORM_CONFIGURATION PlatformConfig;   ///< platform operational characteristics.
  IN       AMD_HT_INTERFACE       HtConfig;         ///< HyperTransport Interface
  IN       GNB_CONFIGURATION      GnbConfig;        ///< GNB configuration
} AMD_EARLY_PARAMS;

AGESA_STATUS
AmdInitEarly (
  IN OUT   AMD_EARLY_PARAMS     *EarlyParams
  );


/**********************************************************************
 * Interface call:  AmdInitPost
 **********************************************************************/
/// AmdInitPost param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS      StdHeader;        ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;   ///< platform operational characteristics.
  IN       MEM_PARAMETER_STRUCT   MemConfig;        ///< Memory post param
} AMD_POST_PARAMS;

AGESA_STATUS
AmdInitPost (
  IN OUT   AMD_POST_PARAMS      *PostParams         ///< Amd Cpu init param
  );


/**********************************************************************
 * Interface call:  AmdInitEnv
 **********************************************************************/
/// AmdInitEnv param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS      StdHeader;            ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;       ///< platform operational characteristics.
  IN       GNB_ENV_CONFIGURATION  GnbEnvConfiguration;  ///< platform operational characteristics.
} AMD_ENV_PARAMS;

AGESA_STATUS
AmdInitEnv (
  IN OUT   AMD_ENV_PARAMS       *EnvParams
  );


/**********************************************************************
 * Interface call:  AmdInitMid
 **********************************************************************/
/// AmdInitMid param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS      StdHeader;        ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;   ///< platform operational characteristics.
} AMD_MID_PARAMS;

AGESA_STATUS
AmdInitMid (
  IN OUT   AMD_MID_PARAMS       *MidParams
  );


/**********************************************************************
 * Interface call:  AmdInitLate
 **********************************************************************/
/// AmdInitLate param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS      StdHeader;              ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;         ///< platform operational characteristics.
     OUT   DMI_INFO               *DmiTable;              ///< DMI Interface
     OUT   VOID                   *AcpiPState;            ///< Acpi Pstate SSDT Table
     OUT   VOID                   *AcpiSrat;              ///< SRAT Table
     OUT   VOID                   *AcpiSlit;              ///< SLIT Table
     OUT   VOID                   *AcpiWheaMce;           ///< WHEA MCE Table
     OUT   VOID                   *AcpiWheaCmc;           ///< WHEA CMC Table
     OUT   VOID                   *AcpiAlib;              ///< ACPI SSDT table with ALIB implementation
} AMD_LATE_PARAMS;

AGESA_STATUS
AmdInitLate (
  IN OUT   AMD_LATE_PARAMS      *LateParams
  );

/**********************************************************************
 * Interface call:  AmdInitRecovery
 **********************************************************************/
/// CPU Recovery Parameters
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS StdHeader;             ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;   ///< platform operational characteristics.
} AMD_CPU_RECOVERY_PARAMS;

/// AmdInitRecovery param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS        StdHeader;            ///< Standard configuration header
  IN       MEM_PARAMETER_STRUCT     MemConfig;            ///< Memory post param
  IN       EXECUTION_CACHE_REGION   CacheRegion[3];       ///< The cached memory region. And the max cache region is 3
  IN       AMD_CPU_RECOVERY_PARAMS  CpuRecoveryParams;    ///< Params for CPU related recovery init.
} AMD_RECOVERY_PARAMS;

AGESA_STATUS
AmdInitRecovery (
  IN OUT   AMD_RECOVERY_PARAMS    *RecoveryParams
  );

/**********************************************************************
 * Interface call:  AmdInitResume
 **********************************************************************/
/// AmdInitResume param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS      StdHeader;      ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig; ///< Platform operational characteristics
  IN       AMD_S3_PARAMS          S3DataBlock;    ///< Save state data
} AMD_RESUME_PARAMS;

AGESA_STATUS
AmdInitResume (
  IN       AMD_RESUME_PARAMS    *ResumeParams
  );


/**********************************************************************
 * Interface call:  AmdS3LateRestore
 **********************************************************************/
/// AmdS3LateRestore param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS    StdHeader;          ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;   ///< platform operational characteristics.
  IN       AMD_S3_PARAMS          S3DataBlock;      ///< Save state data
} AMD_S3LATE_PARAMS;

AGESA_STATUS
AmdS3LateRestore (
  IN OUT   AMD_S3LATE_PARAMS    *S3LateParams
  );


/**********************************************************************
 * Interface call:  AmdS3Save
 **********************************************************************/
/// AmdS3Save param structure
typedef struct {
  IN OUT   AMD_CONFIG_PARAMS    StdHeader;          ///< Standard configuration header
  IN       PLATFORM_CONFIGURATION PlatformConfig;   ///< platform operational characteristics.
     OUT   AMD_S3_PARAMS          S3DataBlock;      ///< Standard header
} AMD_S3SAVE_PARAMS;

AGESA_STATUS
AmdS3Save (
  IN OUT   AMD_S3SAVE_PARAMS    *AmdS3SaveParams
  );


/**********************************************************************
 * Interface call:  AmdLateRunApTask
 **********************************************************************/
/**
 * Entry point for AP tasking.
 */
AGESA_STATUS
AmdLateRunApTask (
  IN       AP_EXE_PARAMS  *AmdApExeParams
);

//
// General Services API
//

/**********************************************************************
 * Interface service call:  AmdGetApicId
 **********************************************************************/
/// Request the APIC ID of a particular core.

typedef struct {
  IN       AMD_CONFIG_PARAMS StdHeader;        ///< Standard configuration header
  IN       UINT8             Socket;           ///< The Core's Socket.
  IN       UINT8             Core;             ///< The Core id.
     OUT   BOOLEAN           IsPresent;        ///< The Core is present, and  ApicAddress is valid.
     OUT   UINT8             ApicAddress;      ///< The Core's APIC ID.
} AMD_APIC_PARAMS;

/**
 * Get a specified Core's APIC ID.
 */
AGESA_STATUS
AmdGetApicId (
  IN OUT AMD_APIC_PARAMS *AmdParamApic
);

/**********************************************************************
 * Interface service call:  AmdGetPciAddress
 **********************************************************************/
/// Request the PCI Address of a Processor Module (that is, its Northbridge)

typedef struct {
  IN       AMD_CONFIG_PARAMS StdHeader;        ///< Standard configuration header
  IN       UINT8             Socket;           ///< The Processor's socket
  IN       UINT8             Module;           ///< The Module in that Processor
     OUT   BOOLEAN           IsPresent;        ///< The Core is present, and  PciAddress is valid.
     OUT   PCI_ADDR          PciAddress;       ///< The Processor's PCI Config Space address (Function 0, Register 0)
} AMD_GET_PCI_PARAMS;

/**
 * Get Processor Module's PCI Config Space address.
 */
AGESA_STATUS
AmdGetPciAddress (
  IN OUT   AMD_GET_PCI_PARAMS *AmdParamGetPci
);

/**********************************************************************
 * Interface service call:  AmdIdentifyCore
 **********************************************************************/
/// Request the identity (Socket, Module, Core) of the current Processor Core

typedef struct {
  IN       AMD_CONFIG_PARAMS StdHeader;         ///< Standard configuration header
     OUT   UINT8             Socket;            ///< The current Core's Socket
     OUT   UINT8             Module;            ///< The current Core's Processor Module
     OUT   UINT8             Core;              ///< The current Core's core id.
} AMD_IDENTIFY_PARAMS;

/**
 * "Who am I" for the current running core.
 */
AGESA_STATUS
AmdIdentifyCore (
  IN OUT  AMD_IDENTIFY_PARAMS *AmdParamIdentify
);

/**********************************************************************
 * Interface service call:  AmdReadEventLog
 **********************************************************************/
/// An Event Log Entry.
typedef struct {
  IN       AMD_CONFIG_PARAMS StdHeader;         ///< Standard configuration header
     OUT   UINT32            EventClass;        ///< The severity of this event, matches AGESA_STATUS.
     OUT   UINT32            EventInfo;         ///< The unique event identifier, zero means "no event".
     OUT   UINT32            DataParam1;        ///< Data specific to the Event.
     OUT   UINT32            DataParam2;        ///< Data specific to the Event.
     OUT   UINT32            DataParam3;        ///< Data specific to the Event.
     OUT   UINT32            DataParam4;        ///< Data specific to the Event.
} EVENT_PARAMS;

/**
 * Read an Event from the Event Log.
 */
AGESA_STATUS
AmdReadEventLog (
  IN       EVENT_PARAMS *Event
);

/**********************************************************************
 * Interface service call:  AmdIdentifyDimm
 **********************************************************************/
/// Request the identity of dimm from system address

typedef struct {
  IN OUT   AMD_CONFIG_PARAMS StdHeader;            ///< Standard configuration header
  IN       UINT64            MemoryAddress;        ///< System Address that needs to be translated to dimm identification.
  OUT      UINT8             SocketId;             ///< The socket on which the targeted address locates.
  OUT      UINT8             MemChannelId;         ///< The channel on which the targeted address locates.
  OUT      UINT8             DimmId;               ///< The dimm on which the targeted address locates.
} AMD_IDENTIFY_DIMM;

/**
 * Get the dimm identification for the address.
 */
AGESA_STATUS
AmdIdentifyDimm (
  IN OUT   AMD_IDENTIFY_DIMM *AmdDimmIdentify
);

/// Data structure for the Mapping Item between Unified ID for IDS Setup Option
/// and the option value.
///
typedef struct {
  IN    UINT16 IdsNvId;           ///< Unified ID for IDS Setup Option.
  OUT UINT16 IdsNvValue;        ///< The value of IDS Setup Option.
} IDS_NV_ITEM;

/// Data Structure for IDS CallOut Function
typedef struct {
  IN    AMD_CONFIG_PARAMS StdHeader;        ///< Standard configuration header
  IN    IDS_NV_ITEM *IdsNvPtr;              ///< Memory Pointer of IDS NV Table
  IN OUT UINTN Reserved;              ///< reserved
} IDS_CALLOUT_STRUCT;

AGESA_STATUS
AmdIdsRunApTaskLate (
  IN       AP_EXE_PARAMS  *AmdApExeParams
  );


#define AGESA_IDS_DFT_VAL   0xFFFF                  ///<  Default value of every uninitlized NV item, the action for it will be ignored
#define AGESA_IDS_NV_END    0xFFFF                  ///< Flag specify end of option structure
/// WARNING: Don't change the comment below, it used as signature for script
/// AGESA IDS NV ID Definitions
typedef enum {
  AGESA_IDS_EXT_ID_START                   = 0x0000,///< 0x0000                                                             specify the start of external NV id

  AGESA_IDS_NV_UCODE,                               ///< 0x0001                                                            Enable or disable microcode patching

  AGESA_IDS_NV_TARGET_PSTATE,                       ///< 0x0002                                                        Set the P-state required to be activated
  AGESA_IDS_NV_POSTPSTATE,                          ///< 0x0003                                           Set the P-state required to be activated through POST

  AGESA_IDS_NV_BANK_INTERLEAVE,                     ///< 0x0004                                                               Enable or disable Bank Interleave
  AGESA_IDS_NV_CHANNEL_INTERLEAVE,                  ///< 0x0005                                                            Enable or disable Channel Interleave
  AGESA_IDS_NV_NODE_INTERLEAVE,                     ///< 0x0006                                                               Enable or disable Node Interleave
  AGESA_IDS_NV_MEMHOLE,                             ///< 0x0007                                                                  Enables or disable memory hole

  AGESA_IDS_NV_SCRUB_REDIRECTION,                   ///< 0x0008                                           Enable or disable a write to dram with corrected data
  AGESA_IDS_NV_DRAM_SCRUB,                          ///< 0x0009                                                   Set the rate of background scrubbing for DRAM
  AGESA_IDS_NV_DCACHE_SCRUB,                        ///< 0x000A                                            Set the rate of background scrubbing for the DCache.
  AGESA_IDS_NV_L2_SCRUB,                            ///< 0x000B                                           Set the rate of background scrubbing for the L2 cache
  AGESA_IDS_NV_L3_SCRUB,                            ///< 0x000C                                           Set the rate of background scrubbing for the L3 cache
  AGESA_IDS_NV_ICACHE_SCRUB,                        ///< 0x000D                                             Set the rate of background scrubbing for the Icache
  AGESA_IDS_NV_SYNC_ON_ECC_ERROR,                   ///< 0x000E                                    Enable or disable the sync flood on un-correctable ECC error
  AGESA_IDS_NV_ECC_SYMBOL_SIZE,                     ///< 0x000F                                                                             Set ECC symbol size

  AGESA_IDS_NV_ALL_MEMCLKS,                         ///< 0x0010                                                      Enable or disable all memory clocks enable
  AGESA_IDS_NV_DCT_GANGING_MODE,                    ///< 0x0011                                                                             Set the Ganged mode
  AGESA_IDS_NV_DRAM_BURST_LENGTH32,                 ///< 0x0012                                                                    Set the DRAM Burst Length 32
  AGESA_IDS_NV_MEMORY_POWER_DOWN,                   ///< 0x0013                                                        Enable or disable Memory power down mode
  AGESA_IDS_NV_MEMORY_POWER_DOWN_MODE,              ///< 0x0014                                                                  Set the Memory power down mode
  AGESA_IDS_NV_DLL_SHUT_DOWN,                       ///< 0x0015                                                                   Enable or disable DLLShutdown
  AGESA_IDS_NV_ONLINE_SPARE,                        ///< 0x0016      Enable or disable the Dram controller to designate a DIMM bank as a spare for logical swap

  AGESA_IDS_NV_HT_ASSIST,                           ///< 0x0017                                                                     Enable or Disable HT Assist
  AGESA_IDS_NV_ATMMODE,                             ///< 0x0018                                                                      Enable or Disable ATM mode

  AGESA_IDS_NV_HDTOUT,                              ///< 0x0019                                                                Enable or disable HDTOUT feature

  AGESA_IDS_NV_HTLINKSOCKET,                        ///< 0x001A                                                                                  HT Link Socket
  AGESA_IDS_NV_HTLINKPORT,                          ///< 0x001B                                                                                    HT Link Port
  AGESA_IDS_NV_HTLINKFREQ,                          ///< 0x001C                                                                               HT Link Frequency
  AGESA_IDS_NV_HTLINKWIDTHIN,                       ///< 0x001D                                                                                HT Link In Width
  AGESA_IDS_NV_HTLINKWIDTHOUT,                      ///< 0x001E                                                                               HT Link Out Width

  AGESA_IDS_NV_GNBHDAUDIOEN,                        ///< 0x001F                                                                  Enable or disable GNB HD Audio

  AGESA_IDS_NV_CPB_EN,                              ///< 0x0020                                                                          Core Performance Boost

  AGESA_IDS_NV_HTC_EN,                              ///< 0x0021                                                                                      HTC Enable
  AGESA_IDS_NV_HTC_OVERRIDE,                        ///< 0x0022                                                                                    HTC Override
  AGESA_IDS_NV_HTC_PSTATE_LIMIT,                    ///< 0x0023                                                                        HTC P-state limit select
  AGESA_IDS_NV_HTC_TEMP_HYS,                        ///< 0x0024                                                                      HTC Temperature Hysteresis
  AGESA_IDS_NV_HTC_ACT_TEMP,                        ///< 0x0025                                                                             HTC Activation Temp

  AGESA_IDS_NV_POWER_POLICY,                        ///< 0x0026                                                                    Select Platform Power Policy
  AGESA_IDS_EXT_ID_END,                             ///< 0x0027                                                               specify the end of external NV ID
} IDS_EX_NV_ID;


#define IDS_NUM_EXT_NV_ITEM (AGESA_IDS_EXT_ID_END - AGESA_IDS_EXT_ID_START + 1)

#endif // _AGESA_H_
# 3065 "src/vendorcode/amd/agesa/f14/AGESA.h"
# 54 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c" 2
#if 0 /* expanded by -frewrite-includes */
#include "Ids.h"
#endif /* expanded by -frewrite-includes */
# 54 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
# 1 "src/vendorcode/amd/agesa/f14/Include/Ids.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * AMD IDS Routines
 *
 * Contains AMD AGESA Integrated Debug Macros
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  IDS
 * @e \$Revision: 44325 $   @e \$Date: 2010-12-22 03:29:53 -0700 (Wed, 22 Dec 2010) $
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***************************************************************************
 *
 */

  /* Macros to aid debugging */
  /* These definitions expand to zero (0) bytes of code when disabled */

#ifndef _IDS_H_
#define _IDS_H_

#undef FALSE
#undef TRUE
#define FALSE 0
#define TRUE  1
// Proto type for optionsids.h
typedef UINT32 IDS_STATUS;  ///< Status of IDS function.
#define IDS_SUCCESS         ((IDS_STATUS) 0x00000000) ///< IDS Function is Successful.
#define IDS_UNSUPPORTED     ((IDS_STATUS) 0xFFFFFFFF) ///< IDS Function is not existed.

#define IDS_STRINGIZE(a) #a ///< for define stringize macro
/**
 *  IDS Option Hook Points
 *
 *  These are the values to indicate hook point in AGESA for IDS Options.
 *
 */
typedef enum {                        //vv- for debug reference only
  IDS_INIT_EARLY_BEFORE,              ///< 00 Option Hook Point before AGESA function AMD_INIT_EARLY.
                                          ///<   IDS Object is initialized.
                                          ///<   Override CPU Core Leveling Mode.
                                          ///<   Set P-State in Post
  IDS_INIT_EARLY_AFTER,               ///< 01 Option Hook Point after AGESA function AMD_INIT_EARLY.
  IDS_INIT_LATE_BEFORE,               ///< 02 Option Hook Point before AGESA function AMD_INIT_LATE.
                                          ///< It will be used to control the following tables.
                                          ///<   ACPI P-State Table (_PSS, XPSS, _PCT, _PSD, _PPC)
                                          ///<   ACPI SRAT Table
                                          ///<   ACPI SLIT Table
                                          ///<   ACPI WHEA Table
                                          ///<   DMI Table
  IDS_INIT_LATE_AFTER,                ///< 03 Option Hook Point after AGESA function AMD_INIT_LATE.
  IDS_INIT_MID_BEFORE,                ///< 04 Option Hook Point before AGESA function AMD_INIT_MID.
  IDS_INIT_MID_AFTER,                 ///< 05 Option Hook Point after AGESA function AMD_INIT_MID.
  IDS_INIT_POST_BEFORE,               ///< 06 Option Hook Point before AGESA function AMD_INIT_POST.
                                          ///<   Control Interleaving and DRAM memory hole
                                          ///<   Override the setting of ECC Control
                                          ///<   Override the setting of Online Spare Rank
  IDS_INIT_POST_AFTER,                ///< 07 Option Hook Point after AGESA function AMD_INIT_POST.
  IDS_INIT_RESET_BEFORE,              ///< 08 Option Hook Point before AGESA function AMD_INIT_RESET.
  IDS_INIT_RESET_AFTER,               ///< 09 Option Hook Point after AGESA function AMD_INIT_RESET.
  IDS_INIT_POST_MID,                  ///< 0a Option Hook Point after AGESA function AMD_INIT_POST.
  IDS_BEFORE_S3_SAVE,                 ///< 0b override any settings before S3 save.
  IDS_BEFORE_S3_RESTORE,              ///< 0c  override any settings before S3 restore
  IDS_AFTER_S3_SAVE,                  ///< 0d Override any settings after S3 save
  IDS_AFTER_S3_RESTORE,               ///< 0e Override any settings after S3 restore
  IDS_BEFORE_DQS_TRAINING,            ///< 0f override any settings before DQS training
  IDS_BEFORE_DRAM_INIT,               ///< 10 override any settings before Dram initialization
  IDS_BEFORE_MEM_FREQ_CHG,            ///< 11 override settings before MemClk frequency change
  IDS_BEFORE_WARM_RESET ,             ///< 12 Override PCI or MSR Registers Before Warm Reset
  IDS_BEFORE_MEM_INIT,                ///< 13 Override PCI or MSR Registers Before Memory Init
  IDS_BEFORE_PCI_INIT,                ///< 14 Override PCI or MSR Registers Before PCI Init
  IDS_BEFORE_OS,                      ///< 15 Override PCI or MSR Registers Before booting to OS
  IDS_UCODE,                          ///< 16 Enable or Disable microcode patching
  IDS_BEFORE_AP_EARLY_HALT,           ///< 17 Option Hook Point before AP early halt

  IDS_PLATFORM_RSVD1 = 0x38,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD2 = 0x39,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD3 = 0x3a,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD4 = 0x3b,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD5 = 0x3c,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD6 = 0x3d,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD7 = 0x3e,          ///< from 0x38 to 0x3f will reserved for platform used
  IDS_PLATFORM_RSVD8 = 0x3f,          ///< from 0x38 to 0x3f will reserved for platform used

  // All the above timing point is used by BVM, their value should never be changed
  IDS_HT_CONTROL,                     ///< 40 Override the setting of HT Link Control
  IDS_HT_TRISTATE,                    ///< 41 Enable or Disable HT Tri-state during an LDTSTP#
  IDS_INIT_DRAM_TABLE,                ///< 42 Generate override table for Dram Timing
                                          ///< Dram Controller, Drive Strength and DQS Timing
  IDS_GET_DRAM_TABLE,                 ///< 43 Generate override table for Dram Timing
  IDS_GANGING_MODE,                   ///< 44 override Memory Mode Unganged
  IDS_POWERDOWN_MODE,                 ///< 45 override Power Down Mode
  IDS_BURST_LENGTH32,                 ///< 46 override Burst Length32
  IDS_ALL_MEMORY_CLOCK,               ///< 47 override All Memory Clks Enable
  IDS_ECC,                            ///< 48 override ECC parameter
  IDS_ECCSYMBOLSIZE,                  ///< 49 override ECC symbol size
  IDS_CPU_Early_Override,             ///< 4a override CPU early parameter
  IDS_CACHE_FLUSH_HLT,                ///< 4b override Cache Flush Hlt
  IDS_CHANNEL_INTERLEAVE,             ///< 4c override Channel Interleave
  IDS_MEM_ERROR_RECOVERY,             ///< 4d override memory error recovery
  IDS_MEM_RETRAIN_TIMES,              ///< 4e override memory retrain times
  IDS_MEM_SIZE_OVERLAY,               ///< 4f Override the syslimit
  IDS_HT_ASSIST,                      ///< 50 Override Probe Filter
  IDS_CHECK_NEGATIVE_WL,              ///< 51 Check for negative write leveling result
  IDS_DLL_SHUT_DOWN,                  ///< 52 Check for Dll Shut Down
  IDS_POR_MEM_FREQ,                   ///< 53 Entry to enable/disable MemClk frequency enforcement
  IDS_PHY_DLL_STANDBY_CTRL,           ///< 54 Enable/Disable Phy DLL standby feature
  IDS_PLATFORMCFG_OVERRIDE,           ///< 55 Hook for Override PlatformConfig structure
  IDS_LOADCARD_ERROR_RECOVERY,        ///< 56 Special error handling for load card support
  IDS_MEM_IGNORE_ERROR,               ///< 57 Ignore error and do not do fatal exit in memory
  IDS_GNB_SMU_SERVICE_CONFIG,         ///< 58 Config GNB SMU service
  IDS_GNB_ORBDYNAMIC_WAKE,            ///< 59 config GNB dynamic wake
  IDS_GNB_PLATFORMCFG_OVERRIDE,       ///< 5a override ids gnb platform config
  IDS_GNB_LCLK_DPM_EN,                ///< 5b override GNB LCLK DPM configuration
  IDS_GNB_LCLK_DEEP_SLEEP,            ///< 5c override GNB LCLK DPM deep sleep
  IDS_GNB_CLOCK_GATING,               ///< 5d Override GNB Clock gating config
  IDS_NB_PSTATE_DIDVID,               ///< 5e Override NB P-state settings
  IDS_CPB_CTRL,                       ///< 5f Config the Core peformance boost feature
  IDS_HTC_CTRL,                       ///< 60 Hook for Hardware Thermal Control
  IDS_CC6_WORKAROUND,                 ///< 61 Hook for skip CC6 work around
  IDS_MEM_MR0,                        ///< 62 Hook for override Memory Mr0 register
  IDS_REG_TABLE,                      ///< 63 Hook for add IDS register table to the loop
  IDS_NBBUFFERALLOCATIONATEARLY,      ///< 64 Hook for override North bridge bufer allocation
  IDS_BEFORE_S3_SPECIAL,              ///< 65 Hook to bypass S3 special functions
  IDS_SET_PCI_REGISTER_ENTRY,         ///< 66 Hook to SetRegisterForPciEntry
  IDS_ERRATUM463_WORKAROUND,          ///< 67 Hook to Erratum 463 workaround
  IDS_BEFORE_MEMCLR,                  ///< 68 Hook before set Memclr bit
  IDS_OVERRIDE_IO_CSTATE,             ///< 69 Hook for override io C-state setting
  IDS_NBPSDIS_OVERRIDE,               ///< 6a Hook for override NB pstate disable setting
  IDS_NBPS_REG_OVERRIDE,              ///< 6b Hook for override Memory NBps reg
  IDS_LOW_POWER_PSTATE,               ///< 6c Hook for disalbe Low power_Pstates feature
  IDS_CST_CREATE,                     ///< 6d Hook for create _CST
  IDS_CST_SIZE,                       ///< 6e Hook for get _CST size
  IDS_ENFORCE_VDDIO,                  ///< 6f Hook to override VDDIO
  IDS_SKIP_PERFORMANCE_OPT,           ///< 70 Hook to skip performance optimization
  IDS_INIT_MEM_REG_TABLE,             ///< 71 Hook for init memory register table
  IDS_SKIP_FUSED_MAX_RATE             ///< 72 Hook to skip fused max rate cap
} AGESA_IDS_OPTION;

#if 0 /* expanded by -frewrite-includes */
#include "OptionsIds.h"
#endif /* expanded by -frewrite-includes */
# 170 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
# 1 "src/mainboard/jetway/nf81-t56n-lf/OptionsIds.h" 1
/*
 * This file is part of the coreboot project.
 *
 * Copyright (C) 2011 Advanced Micro Devices, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

/**
 * @file
 *
 * IDS Option File
 *
 * This file is used to switch on/off IDS features.
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Core
 * @e \$Revision: 12067 $   @e \$Date: 2009-04-11 04:34:13 +0800 (Sat, 11 Apr 2009) $
 */
#ifndef _OPTION_IDS_H_
#define _OPTION_IDS_H_

/**
 *
 *  This file generates the defaults tables for the Integrated Debug Support
 * Module. The documented build options are imported from a user controlled
 * file for processing. The build options for the Integrated Debug Support
 * Module are listed below:
 *
 *    IDSOPT_IDS_ENABLED
 *    IDSOPT_ERROR_TRAP_ENABLED
 *    IDSOPT_CONTROL_ENABLED
 *    IDSOPT_TRACING_ENABLED
 *    IDSOPT_PERF_ANALYSIS
 *    IDSOPT_ASSERT_ENABLED
 *    IDS_DEBUG_PORT
 *    IDSOPT_CAR_CORRUPTION_CHECK_ENABLED
 *
 **/

#define IDSOPT_IDS_ENABLED     TRUE
//#define IDSOPT_TRACING_ENABLED TRUE
#define IDSOPT_ASSERT_ENABLED  TRUE

//#define IDSOPT_DEBUG_ENABLED  FALSE
//#undef IDSOPT_HOST_SIMNOW
//#define IDSOPT_HOST_SIMNOW    FALSE
//#undef IDSOPT_HOST_HDT
//#define IDSOPT_HOST_HDT       FALSE
//#define IDS_DEBUG_PORT    0x80

#endif
# 65 "src/mainboard/jetway/nf81-t56n-lf/OptionsIds.h"
# 171 "src/vendorcode/amd/agesa/f14/Include/Ids.h" 2
#if 0 /* expanded by -frewrite-includes */
#include "Filecode.h"
#endif /* expanded by -frewrite-includes */
# 171 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
# 1 "src/vendorcode/amd/agesa/f14/Include/Filecode.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * Collectively assign unique filecodes for assert and debug to each source file.
 *
 * Publish values for decorated filenames, which can be used for
 * ASSERT and debug support using a preprocessor define like:
 * @n <tt> \#define FILECODE MY_C_FILENAME_FILECODE </tt> @n
 * This file serves as a reference for debugging to associate the code and filename.
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Include
 * @e \$Revision: 46485 $   @e \$Date: 2011-02-03 09:03:14 -0700 (Thu, 03 Feb 2011) $
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */

#ifndef _FILECODE_H_
#define _FILECODE_H_

#define UNASSIGNED_FILE_FILECODE                                         (0xFFFF)

/// For debug use in any Platform's options C file.
/// Can be reused for platforms and image builds, since only one options file can be built.
#define PLATFORM_SPECIFIC_OPTIONS_FILECODE                               (0xBBBB)


#define PROC_GNB_COMMON_GNBLIBFEATURES_FILECODE                          (0xA001)
#define PROC_GNB_GFX_FAMILY_0X12_F12GFXSERVICES_FILECODE                 (0xA002)
#define PROC_GNB_GFX_FAMILY_0X14_F14GFXSERVICES_FILECODE                 (0xA003)
#define PROC_GNB_GFX_GFXCONFIGDATA_FILECODE                              (0xA004)
#define PROC_GNB_GFX_GFXDEBUGBAR_FILECODE                                (0xA005)
#define PROC_GNB_GFX_GFXGMCINIT_FILECODE                                 (0xA006)
#define PROC_GNB_GFX_GFXINITATENVPOST_FILECODE                           (0xA010)
#define PROC_GNB_GFX_GFXINITATMIDPOST_FILECODE                           (0xA011)
#define PROC_GNB_GFX_GFXINITATPOST_FILECODE                              (0xA012)
#define PROC_GNB_GFX_GFXINTEGRATEDINFOTABLEINIT_FILECODE                 (0xA013)
#define PROC_GNB_GFX_GFXLIB_FILECODE                                     (0xA014)
#define PROC_GNB_GFX_GFXREGISTERACC_FILECODE                             (0xA015)
#define PROC_GNB_GFX_GFXSTRAPSINIT_FILECODE                              (0xA016)
#define PROC_GNB_GNBINITATEARLY_FILECODE                                 (0xA017)
#define PROC_GNB_GNBINITATENV_FILECODE                                   (0xA020)
#define PROC_GNB_GNBINITATLATE_FILECODE                                  (0xA021)
#define PROC_GNB_GNBINITATMID_FILECODE                                   (0xA022)
#define PROC_GNB_GNBINITATPOST_FILECODE                                  (0xA023)
#define PROC_GNB_GNBINITATRESET_FILECODE                                 (0xA024)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIB_FILECODE                    (0xA025)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIBCPUACC_FILECODE              (0xA026)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIBHEAP_FILECODE                (0xA027)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIBIOACC_FILECODE               (0xA028)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIBMEMACC_FILECODE              (0xA029)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIBPCI_FILECODE                 (0xA02A)
#define PROC_GNB_MODULES_GNBCOMMONLIB_GNBLIBPCIACC_FILECODE              (0xA030)
#define PROC_GNB_MODULES_GNBGFXINITLIBV1_GFXCARDINFO_FILECODE            (0xA031)
#define PROC_GNB_MODULES_GNBGFXINITLIBV1_GFXENUMCONNECTORS_FILECODE      (0xA032)
#define PROC_GNB_MODULES_GNBGFXINITLIBV1_GFXPOWERPLAYTABLE_FILECODE      (0xA033)
#define PROC_GNB_MODULES_GNBNBINITLIBV1_GNBNBINITLIBV1_FILECODE          (0xA034)
#define PROC_GNB_MODULES_GNBPCIEALIBV1_PCIEALIB_FILECODE                 (0xA035)
#define PROC_GNB_MODULES_GNBPCIECONFIG_PCIECONFIGDATA_FILECODE           (0xA036)
#define PROC_GNB_MODULES_GNBPCIECONFIG_PCIECONFIGLIB_FILECODE            (0xA037)
#define PROC_GNB_MODULES_GNBPCIECONFIG_PCIEINPUTPARSER_FILECODE          (0xA038)
#define PROC_GNB_MODULES_GNBPCIECONFIG_PCIEMAPTOPOLOGY_FILECODE          (0xA039)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEASPM_FILECODE              (0xA03A)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEASPMBLACKLIST_FILECODE     (0xA03B)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEASPMEXITLATENCY_FILECODE   (0xA03C)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEPHYSERVICES_FILECODE       (0xA03D)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEPIFSERVICES_FILECODE       (0xA03E)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEPORTREGACC_FILECODE        (0xA03F)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEPORTSERVICES_FILECODE      (0xA041)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEPOWERMGMT_FILECODE         (0xA043)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIESBLINK_FILECODE            (0xA044)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIESILICONSERVICES_FILECODE   (0xA045)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIETIMER_FILECODE             (0xA046)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIETOPOLOGYSERVICES_FILECODE  (0xA047)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEUTILITYLIB_FILECODE        (0xA048)
#define PROC_GNB_MODULES_GNBPCIEINITLIBV1_PCIEWRAPPERREGACC_FILECODE     (0xA049)
#define PROC_GNB_MODULES_GNBPCIETRAININGV1_PCIETRAINING_FILECODE         (0xA04A)
#define PROC_GNB_MODULES_GNBPCIETRAININGV1_PCIEWORKAROUNDS_FILECODE      (0xA04B)
#define PROC_GNB_NB_FAMILY_0X12_F12NBPOWERGATE_FILECODE                  (0xA04C)
#define PROC_GNB_NB_FAMILY_0X12_F12NBSERVICES_FILECODE                   (0xA04D)
#define PROC_GNB_NB_FAMILY_0X12_F12NBSMU_FILECODE                        (0xA04E)
#define PROC_GNB_NB_FAMILY_0X14_F14NBLCLKNCLKRATIO_FILECODE              (0xA04F)
#define PROC_GNB_NB_FAMILY_0X14_F14NBPOWERGATE_FILECODE                  (0xA050)
#define PROC_GNB_NB_FAMILY_0X14_F14NBSERVICES_FILECODE                   (0xA051)
#define PROC_GNB_NB_FAMILY_0X14_F14NBSMU_FILECODE                        (0xA052)
#define PROC_GNB_NB_FEATURE_NBFUSETABLE_FILECODE                         (0xA053)
#define PROC_GNB_NB_FEATURE_NBLCLKDPM_FILECODE                           (0xA054)
#define PROC_GNB_NB_FAMILY_0X12_F12NBLCLKDPM_FILECODE                    (0xA055)
#define PROC_GNB_NB_FAMILY_0X14_F14NBLCLKDPM_FILECODE                    (0xA056)
#define PROC_GNB_NB_NBCONFIGDATA_FILECODE                                (0xA060)
#define PROC_GNB_NB_NBINIT_FILECODE                                      (0xA061)
#define PROC_GNB_NB_NBINITATEARLY_FILECODE                               (0xA062)
#define PROC_GNB_NB_NBINITATENV_FILECODE                                 (0xA063)
#define PROC_GNB_NB_NBINITATLATEPOST_FILECODE                            (0xA070)
#define PROC_GNB_NB_NBINITATPOST_FILECODE                                (0xA071)
#define PROC_GNB_NB_NBINITATRESET_FILECODE                               (0xA072)
#define PROC_GNB_NB_NBPOWERMGMT_FILECODE                                 (0xA073)
#define PROC_GNB_NB_NBSMULIB_FILECODE                                    (0xA074)
#define PROC_GNB_PCIE_FAMILY_0X12_F12PCIEALIB_FILECODE                   (0xA075)
#define PROC_GNB_PCIE_FAMILY_0X12_F12PCIECOMPLEXCONFIG_FILECODE          (0xA076)
#define PROC_GNB_PCIE_FAMILY_0X12_F12PCIECOMPLEXSERVICES_FILECODE        (0xA077)
#define PROC_GNB_PCIE_FAMILY_0X12_F12PCIEPHYSERVICES_FILECODE            (0xA078)
#define PROC_GNB_PCIE_FAMILY_0X12_F12PCIEPIFSERVICES_FILECODE            (0xA079)
#define PROC_GNB_PCIE_FAMILY_0X12_F12PCIEWRAPPERSERVICES_FILECODE        (0xA07A)
#define PROC_GNB_PCIE_FAMILY_0X14_F14PCIEALIB_FILECODE                   (0xA07D)
#define PROC_GNB_PCIE_FAMILY_0X14_F14PCIECOMPLEXCONFIG_FILECODE          (0xA07E)
#define PROC_GNB_PCIE_FAMILY_0X14_F14PCIECOMPLEXSERVICES_FILECODE        (0xA07F)
#define PROC_GNB_PCIE_FAMILY_0X14_F14PCIEPHYSERVICES_FILECODE            (0xA080)
#define PROC_GNB_PCIE_FAMILY_0X14_F14PCIEPIFSERVICES_FILECODE            (0xA081)
#define PROC_GNB_PCIE_FAMILY_0X14_F14PCIEWRAPPERSERVICES_FILECODE        (0xA082)
#define PROC_GNB_PCIE_FEATURE_PCIEPOWERGATE_FILECODE                     (0xA083)
#define PROC_GNB_PCIE_PCIEINIT_FILECODE                                  (0xA084)
#define PROC_GNB_PCIE_PCIEINITATEARLYPOST_FILECODE                       (0xA085)
#define PROC_GNB_PCIE_PCIEINITATENV_FILECODE                             (0xA086)
#define PROC_GNB_PCIE_PCIEINITATLATEPOST_FILECODE                        (0xA087)
#define PROC_GNB_PCIE_PCIEINITATPOST_FILECODE                            (0xA088)
#define PROC_GNB_PCIE_PCIELATEINIT_FILECODE                              (0xA089)
#define PROC_GNB_PCIE_PCIEMISCLIB_FILECODE                               (0xA08A)
#define PROC_GNB_PCIE_PCIEPORTINIT_FILECODE                              (0xA08B)
#define PROC_GNB_PCIE_PCIEPORTLATEINIT_FILECODE                          (0xA08C)
#define PROC_GNB_MODULES_GNBCABLESAFE_GNBCABLESAFE_FILECODE              (0xA08D)
#define PROC_GNB_MODULES_GNBGFXCONFIG_GFXCONFIGENV_FILECODE              (0xA08E)
#define PROC_GNB_MODULES_GNBGFXCONFIG_GFXCONFIGPOST_FILECODE             (0xA08F)

#define PROC_RECOVERY_GNB_GNBRECOVERY_FILECODE                           (0xAE01)
#define PROC_RECOVERY_GNB_NBINITRECOVERY_FILECODE                        (0xAE02)

// FCH
#define PROC_COMMON_AMDFCH_FILECODE                                      (0xB000)
#define PROC_FCH_AZALIA_AZALIA_FILECODE                                  (0xB001)
#define PROC_FCH_AZALIA_AZALIARESET_FILECODE                             (0xB002)
#define PROC_FCH_COMMON_ACPILIB_FILECODE                                 (0xB010)
#define PROC_FCH_COMMON_AMDSBLIB_FILECODE                                (0xB011)
#define PROC_FCH_COMMON_FCHCOMMON_FILECODE                               (0xB012)
#define PROC_FCH_COMMON_FCHCOMMONSMM_FILECODE                            (0xB013)
#define PROC_FCH_COMMON_MEMLIB_FILECODE                                  (0xB014)
#define PROC_FCH_COMMON_PCILIB_FILECODE                                  (0xB015)
#define PROC_FCH_COMMON_SBPELIB_FILECODE                                 (0xB016)
#define PROC_FCH_GEC_FAMILY_HUDSON2_GEC_FILECODE                        (0xB020)
#define PROC_FCH_GEC_FAMILY_HUDSON2_GECRESET_FILECODE                   (0xB021)
#define PROC_FCH_HWACPI_FAMILY_HUDSON2_HWACPI_FILECODE                  (0xB030)
#define PROC_FCH_HWACPI_FAMILY_HUDSON2_HWACPIRESET_FILECODE             (0xB031)
#define PROC_FCH_HWM_FAMILY_HUDSON2_HWM_FILECODE                        (0xB032)
#define PROC_FCH_HWM_FAMILY_HUDSON2_HWMRESET_FILECODE                   (0xB033)
#define PROC_FCH_IDE_IDE_FILECODE                                        (0xB040)
#define PROC_FCH_IMC_FAMILY_HUDSON2_IMC_FILECODE                        (0xB050)
#define PROC_FCH_IMC_FAMILY_HUDSON2_IMCLIB_FILECODE                     (0xB051)
#define PROC_FCH_IMC_FAMILY_HUDSON2_IMCRESET_FILECODE                   (0xB052)
#define PROC_FCH_IMC_FAMILY_HUDSON2_SBEC_FILECODE                       (0xB053)
#define PROC_FCH_IMC_FAMILY_HUDSON2_SBECRESET_FILECODE                  (0xB054)
#define PROC_FCH_INTERFACE_INITRESETDEF_FILECODE                         (0xB060)
#define PROC_FCH_INTERFACE_INITENVDEF_FILECODE                           (0xB061)
#define PROC_FCH_INTERFACE_FCHINITRESET_FILECODE                         (0xB062)
#define PROC_FCH_INTERFACE_FCHINITENV_FILECODE                           (0xB063)
#define PROC_FCH_INTERFACE_FCHINITLATE_FILECODE                          (0xB064)
#define PROC_FCH_INTERFACE_FCHINITMID_FILECODE                           (0xB065)
#define PROC_FCH_INTERFACE_FCHINITS3_FILECODE                            (0xB066)
#define PROC_FCH_INTERFACE_FCHTASKLAUNCHER_FILECODE                      (0xB067)
#define PROC_FCH_IR_IR_FILECODE                                          (0xB070)
#define PROC_FCH_PCIB_PCIB_FILECODE                                      (0xB080)
#define PROC_FCH_PCIB_PCIBRESET_FILECODE                                 (0xB081)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_AB_FILECODE                        (0xB090)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_ABRESET_FILECODE                   (0xB091)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_GPP_FILECODE                       (0xB092)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_GPPHP_FILECODE                     (0xB093)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_GPPLIB_FILECODE                    (0xB094)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_GPPRESET_FILECODE                  (0xB095)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_PCIE_FILECODE                      (0xB096)
#define PROC_FCH_PCIE_FAMILY_HUDSON2_PCIERESET_FILECODE                 (0xB097)
#define PROC_FCH_SATA_FAMILY_HUDSON2_AHCI_FILECODE                      (0xB0A0)
#define PROC_FCH_SATA_FAMILY_HUDSON2_AHCILIB_FILECODE                   (0xB0A1)
#define PROC_FCH_SATA_FAMILY_HUDSON2_IDE2AHCI_FILECODE                  (0xB0A2)
#define PROC_FCH_SATA_FAMILY_HUDSON2_IDE2AHCILIB_FILECODE               (0xB0A3)
#define PROC_FCH_SATA_FAMILY_HUDSON2_RAID_FILECODE                      (0xB0A4)
#define PROC_FCH_SATA_FAMILY_HUDSON2_RAIDLIB_FILECODE                   (0xB0A5)
#define PROC_FCH_SATA_FAMILY_HUDSON2_SATA_FILECODE                      (0xB0A6)
#define PROC_FCH_SATA_FAMILY_HUDSON2_SATAIDE_FILECODE                   (0xB0A7)
#define PROC_FCH_SATA_FAMILY_HUDSON2_SATAIDELIB_FILECODE                (0xB0A8)
#define PROC_FCH_SATA_FAMILY_HUDSON2_SATALIB_FILECODE                   (0xB0A9)
#define PROC_FCH_SATA_FAMILY_HUDSON2_SATARESET_FILECODE                 (0xB0AA)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_EHCI_FILECODE                     (0xB0B0)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_EHCIRESET_FILECODE                (0xB0B1)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_OHCI_FILECODE                     (0xB0B2)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_OHCIRESET_FILECODE                (0xB0B3)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_USB_FILECODE                      (0xB0B4)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_USBRESET_FILECODE                 (0xB0B5)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_XHCI_FILECODE                     (0xB0B6)
#define PROC_FCH_SBUSB_FAMILY_HUDSON2_XHCIRESET_FILECODE                (0xB0B7)
#define PROC_FCH_SD_SD_FILECODE                                          (0xB0C0)
#define PROC_FCH_SPI_LPC_FILECODE                                        (0xB0D0)
#define PROC_FCH_SPI_LPCRESET_FILECODE                                   (0xB0D1)
#define PROC_FCH_SPI_SPI_FILECODE                                        (0xB0D2)
#define PROC_FCH_SPI_SPIRESET_FILECODE                                   (0xB0D3)

#define UEFI_DXE_AMDSBDXE_AMDSBDXE_FILECODE                              (0xB200)
#define UEFI_DXE_AMDSBWHEA_AMDSBWHEA_FILECODE                            (0xB210)
#define UEFI_DXE_AMDSBWHEA_BERTTABLE_FILECODE                            (0xB211)
#define UEFI_DXE_AMDSBWHEA_EINJTABLE_FILECODE                            (0xB212)
#define UEFI_DXE_AMDSBWHEA_ERSTTABLE_FILECODE                            (0xB213)
#define UEFI_DXE_AMDSBWHEA_HESTTABLE_FILECODE                            (0xB214)
#define UEFI_DXE_CF9RESET_CF9RESET_FILECODE                              (0xB220)
#define UEFI_DXE_CF9RESET_IA32_IA32CF9RESET_FILECODE                     (0xB221)
#define UEFI_DXE_CF9RESET_X64_X64CF9RESET_FILECODE                       (0xB222)
#define UEFI_DXE_LEGACYINTERRUPT_LEGACYINTERRUPT_FILECODE                (0xB230)
#define UEFI_DXE_SMMCONTROL_SMMCONTROL_FILECODE                          (0xB240)
#define UEFI_LIBRARY_DECCAN_FCHSMMLIB_FCHDXECOMMON_FILECODE              (0xB250)
#define UEFI_LIBRARY_DECCAN_FCHSMMLIB_FCHSMMLIB_FILECODE                 (0xB251)
#define UEFI_LIBRARY_DECCAN_FCHDXELIB_FCHDXELIB_FILECODE                 (0xB252)
#define UEFI_PEI_AMDSBPEI_AMDSBPEI_FILECODE                              (0xB260)
#define UEFI_PEI_AMDSBPEI_SBRESET_FILECODE                               (0xB261)
#define UEFI_PEI_AMDSBPEI_SBSTALL_FILECODE                               (0xB262)
#define UEFI_PEI_SMBUS_SMBUS_FILECODE                                    (0xB270)
#define UEFI_SMM_AMDSBSMM_AMDSBSMM_FILECODE                              (0xB280)
#define UEFI_SMM_AMDSBSMM_GECSMI_FILECODE                                (0xB281)
#define UEFI_SMM_AMDSBSMM_GPESMI_FILECODE                                (0xB282)
#define UEFI_SMM_AMDSBSMM_IOTRAPSMI_FILECODE                             (0xB283)
#define UEFI_SMM_AMDSBSMM_MISCSMI_FILECODE                               (0xB284)
#define UEFI_SMM_AMDSBSMM_PERIODICTIMERSMI_FILECODE                      (0xB285)
#define UEFI_SMM_AMDSBSMM_POWERBUTTONSMI_FILECODE                        (0xB286)
#define UEFI_SMM_AMDSBSMM_SWSMI_FILECODE                                 (0xB287)
#define UEFI_SMM_AMDSBSMM_SXSMI_FILECODE                                 (0xB288)
#define UEFI_DXE_SMBUS_SMBUSLIGHT_FILECODE                               (0xB2A0)
#define UEFI_SMM_AMDSBSMMDISPATCHER_AMDSBSMMDISPATCHER_FILECODE                     (0xB290)
#define UEFI_SMM_AMDSBSMMGECROMDISPATCHER_AMDSBSMMGECROMDISPATCHER_FILECODE         (0xB291)
#define UEFI_SMM_AMDSBSMMGPEDISPATCHER_AMDSBSMMGPEDISPATCHER_FILECODE               (0xB292)
#define UEFI_SMM_AMDSBSMMIOTRAPDISPATCHER_AMDSBSMMIOTRAPDISPATCHER_FILECODE         (0xB293)
#define UEFI_SMM_AMDSBSMMMISCDISPATCHER_AMDSBSMMMISCDISPATCHER_FILECODE             (0xB294)
#define UEFI_SMM_AMDSBSMMPERIODICALDISPATCHER_AMDSBSMMPERIODICALDISPATCHER_FILECODE (0xB295)
#define UEFI_SMM_AMDSBSMMPWRBTNDISPATCHER_AMDSBSMMPWRBTNDISPATCHER_FILECODE         (0xB296)
#define UEFI_SMM_AMDSBSMMSWDISPATCHER_AMDSBSMMSWDISPATCHER_FILECODE                 (0xB297)
#define UEFI_SMM_AMDSBSMMSXDISPATCHER_AMDSBSMMSXDISPATCHER_FILECODE                 (0xB298)
#define UEFI_SMM_AMDSBSMMUSBDISPATCHER_AMDSBSMMUSBDISPATCHER_FILECODE               (0xB299)

#define LIB_AMDLIB_FILECODE                                              (0xC001)

#define LEGACY_PROC_AGESACALLOUTS_FILECODE                               (0xC010)
#define LEGACY_PROC_HOBTRANSFER_FILECODE                                 (0xC011)
#define LEGACY_PROC_DISPATCHER_FILECODE                                  (0xC012)

#define UEFI_DXE_AMDAGESADXEDRIVER_AMDAGESADXEDRIVER_FILECODE            (0xC120)

#define UEFI_PEI_AMDINITPOSTPEIM_AMDINITPOSTPEIM_FILECODE                (0xC140)
#define UEFI_PEI_AMDPROCESSORINITPEIM_AMDPROCESSORINITPEIM_FILECODE      (0xC141)
#define UEFI_PEI_AMDRESETMANAGER_AMDRESETMANAGER_FILECODE                (0xC142)
#define UEFI_PROC_HOBTRANSFERUEFI_FILECODE                               (0xC162)

#define PROC_COMMON_AMDINITEARLY_FILECODE                                (0xC020)
#define PROC_COMMON_AMDINITENV_FILECODE                                  (0xC021)
#define PROC_COMMON_AMDINITLATE_FILECODE                                 (0xC022)
#define PROC_COMMON_AMDINITMID_FILECODE                                  (0xC023)
#define PROC_COMMON_AMDINITPOST_FILECODE                                 (0xC024)
#define PROC_COMMON_AMDINITRECOVERY_FILECODE                             (0xC025)
#define PROC_COMMON_AMDINITRESET_FILECODE                                (0xC026)
#define PROC_COMMON_AMDINITRESUME_FILECODE                               (0xC027)
#define PROC_COMMON_AMDS3LATERESTORE_FILECODE                            (0xC028)
#define PROC_COMMON_AMDS3SAVE_FILECODE                                   (0xC029)
#define PROC_COMMON_AMDLATERUNAPTASK_FILECODE                            (0xC02A)

#define PROC_COMMON_COMMONRETURNS_FILECODE                               (0xC0C0)
#define PROC_COMMON_CREATESTRUCT_FILECODE                                (0xC0D0)
#define PROC_COMMON_COMMONINITS_FILECODE                                 (0xC0F0)
#define PROC_COMMON_S3RESTORESTATE_FILECODE                              (0xC0F8)
#define PROC_COMMON_S3SAVESTATE_FILECODE                                 (0xC0F9)

#define PROC_CPU_CPUAPICUTILITIES_FILECODE                               (0xC401)
#define PROC_CPU_CPUBRANDID_FILECODE                                     (0xC402)
#define PROC_CPU_TABLE_FILECODE                                          (0xC403)
#define PROC_CPU_CPUEARLYINIT_FILECODE                                   (0xC405)
#define PROC_CPU_CPUEVENTLOG_FILECODE                                    (0xC406)
#define PROC_CPU_CPUFAMILYTRANSLATION_FILECODE                           (0xC407)
#define PROC_CPU_CPUGENERALSERVICES_FILECODE                             (0xC408)
#define PROC_CPU_CPUINITEARLYTABLE_FILECODE                              (0xC409)
#define PROC_CPU_CPULATEINIT_FILECODE                                    (0xC40A)
#define PROC_CPU_CPUMICROCODEPATCH_FILECODE                              (0xC40B)
#define PROC_CPU_CPUWARMRESET_FILECODE                                   (0xC40C)
#define PROC_CPU_HEAPMANAGER_FILECODE                                    (0xC40D)
#define PROC_CPU_CPUBIST_FILECODE                                        (0xC40E)

#define PROC_CPU_CPUPOSTINIT_FILECODE                                    (0xC420)
#define PROC_CPU_CPUPOWERMGMT_FILECODE                                   (0xC430)
#define PROC_CPU_CPUPOWERMGMTMULTISOCKET_FILECODE                        (0xC431)
#define PROC_CPU_CPUPOWERMGMTSINGLESOCKET_FILECODE                       (0xC432)
#define PROC_CPU_S3_FILECODE                                             (0xC460)

// Family 10h
#define PROC_CPU_FAMILY_0X10_CPUCOMMONF10UTILITIES_FILECODE              (0xC801)
#define PROC_CPU_FAMILY_0X10_CPUF10BRANDID_FILECODE                      (0xC802)
#define PROC_CPU_FAMILY_0X10_CPUF10CACHEDEFAULTS_FILECODE                (0xC803)
#define PROC_CPU_FAMILY_0X10_CPUF10CACHEFLUSHONHALT_FILECODE             (0xC804)
#define PROC_CPU_FAMILY_0X10_CPUF10DMI_FILECODE                          (0xC805)
#define PROC_CPU_FAMILY_0X10_CPUF10EARLYINIT_FILECODE                    (0xC806)
#define PROC_CPU_FAMILY_0X10_CPUF10FEATURELEVELING_FILECODE              (0xC807)
#define PROC_CPU_FAMILY_0X10_CPUF10HTPHYTABLES_FILECODE                  (0xC808)
#define PROC_CPU_FAMILY_0X10_CPUF10MSRTABLES_FILECODE                    (0xC809)
#define PROC_CPU_FAMILY_0X10_CPUF10PCITABLES_FILECODE                    (0xC80A)
#define PROC_CPU_FAMILY_0X10_CPUF10POWERCHECK_FILECODE                   (0xC80B)
#define PROC_CPU_FAMILY_0X10_CPUF10POWERMGMTSYSTEMTABLES_FILECODE        (0xC80C)
#define PROC_CPU_FAMILY_0X10_CPUF10POWERPLANE_FILECODE                   (0xC80D)
#define PROC_CPU_FAMILY_0X10_CPUF10SOFTWARETHERMAL_FILECODE              (0xC80E)
#define PROC_CPU_FAMILY_0X10_CPUF10UTILITIES_FILECODE                    (0xC80F)
#define PROC_CPU_FAMILY_0X10_CPUF10WHEAINITDATATABLES_FILECODE           (0xC810)
#define PROC_CPU_FAMILY_0X10_CPUF10PSTATE_FILECODE                       (0xC811)
#define PROC_CPU_FAMILY_0X10_CPUF10CPB_FILECODE                          (0xC812)
#define PROC_CPU_FAMILY_0X10_CPUF10WORKAROUNDSTABLE_FILECODE             (0xC813)
#define PROC_CPU_FAMILY_0X10_F10PMNBCOFVIDINIT_FILECODE                  (0xC820)
#define PROC_CPU_FAMILY_0X10_F10SINGLELINKPCITABLES_FILECODE             (0xC821)
#define PROC_CPU_FAMILY_0X10_F10MULTILINKPCITABLES_FILECODE              (0xC822)
#define PROC_CPU_FAMILY_0X10_F10PMNBPSTATEINIT_FILECODE                  (0xC823)
#define PROC_CPU_FAMILY_0X10_F10PMASYMBOOSTINIT_FILECODE                 (0xC824)
#define PROC_CPU_FAMILY_0X10_F10INITEARLYTABLE_FILECODE                  (0xC825)
#define PROC_CPU_FAMILY_0X10_F10PMDUALPLANEONLYSUPPORT_FILECODE          (0xC826)
#define PROC_CPU_FAMILY_0X10_F10IOCSTATE_FILECODE                        (0xC827)
#define PROC_CPU_FAMILY_0X10_REVC_F10REVCUTILITIES_FILECODE              (0xC830)
#define PROC_CPU_FAMILY_0X10_REVC_F10REVCHWC1E_FILECODE                  (0xC831)
#define PROC_CPU_FAMILY_0X10_REVC_F10REVCSWC1E_FILECODE                  (0xC832)
#define PROC_CPU_FAMILY_0X10_REVC_F10REVCPCITABLES_FILECODE              (0xC833)
#define PROC_CPU_FAMILY_0X10_REVC_F10REVCMSRTABLES_FILECODE              (0xC834)
#define PROC_CPU_FAMILY_0X10_REVC_F10REVCHTPHYTABLES_FILECODE            (0xC835)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLHTPHYTABLES_FILECODE           (0xC836)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLLOGICALIDTABLES_FILECODE       (0xC837)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLMICROCODEPATCHTABLES_FILECODE  (0xC838)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLMSRTABLES_FILECODE             (0xC839)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLEQUIVALENCETABLE_FILECODE      (0xC83A)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLPCITABLES_FILECODE             (0xC83B)
#define PROC_CPU_FAMILY_0X10_REVC_BL_F10BLCACHEFLUSHONHALT_FILECODE      (0xC83C)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DAHTPHYTABLES_FILECODE           (0xC83D)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DALOGICALIDTABLES_FILECODE       (0xC83E)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DAMICROCODEPATCHTABLES_FILECODE  (0xC83F)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DAMSRTABLES_FILECODE             (0xC840)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DAEQUIVALENCETABLE_FILECODE      (0xC841)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DAPCITABLES_FILECODE             (0xC842)
#define PROC_CPU_FAMILY_0X10_REVC_DA_F10DACACHEFLUSHONHALT_FILECODE      (0xC843)
#define PROC_CPU_FAMILY_0X10_REVC_RB_F10RBHTPHYTABLES_FILECODE           (0xC844)
#define PROC_CPU_FAMILY_0X10_REVC_RB_F10RBLOGICALIDTABLES_FILECODE       (0xC845)
#define PROC_CPU_FAMILY_0X10_REVC_RB_F10RBMICROCODEPATCHTABLES_FILECODE  (0xC846)
#define PROC_CPU_FAMILY_0X10_REVC_RB_F10RBMSRTABLES_FILECODE             (0xC847)
#define PROC_CPU_FAMILY_0X10_REVC_RB_F10RBEQUIVALENCETABLE_FILECODE      (0xC848)
#define PROC_CPU_FAMILY_0X10_REVC_RB_F10RBPCITABLES_FILECODE             (0xC849)
#define PROC_CPU_FAMILY_0X10_REVD_F10REVDUTILITIES_FILECODE              (0xC850)
#define PROC_CPU_FAMILY_0X10_REVD_F10REVDMSGBASEDC1E_FILECODE            (0xC851)
#define PROC_CPU_FAMILY_0X10_REVD_F10REVDHTASSIST_FILECODE               (0xC852)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYHTPHYTABLES_FILECODE           (0xC853)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYINITEARLYTABLE_FILECODE        (0xC854)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYLOGICALIDTABLES_FILECODE       (0xC855)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYMICROCODEPATCHTABLES_FILECODE  (0xC856)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYMSRTABLES_FILECODE             (0xC857)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYEQUIVALENCETABLE_FILECODE      (0xC858)
#define PROC_CPU_FAMILY_0X10_REVD_HY_F10HYPCITABLES_FILECODE             (0xC859)
#define PROC_CPU_FAMILY_0X10_REVE_F10REVEUTILITIES_FILECODE              (0xC860)
#define PROC_CPU_FAMILY_0X10_REVE_F10REVEMSRTABLES_FILECODE              (0xC861)
#define PROC_CPU_FAMILY_0X10_REVE_F10REVEPCITABLES_FILECODE              (0xC862)
#define PROC_CPU_FAMILY_0X10_REVE_F10REVEHTPHYTABLES_FILECODE            (0xC863)
#define PROC_CPU_FAMILY_0X10_REVE_PH_F10PHEQUIVALENCETABLE_FILECODE      (0xC864)
#define PROC_CPU_FAMILY_0X10_REVE_PH_F10PHHTPHYTABLES_FILECODE           (0xC865)
#define PROC_CPU_FAMILY_0X10_REVE_PH_F10PHLOGICALIDTABLES_FILECODE       (0xC866)
#define PROC_CPU_FAMILY_0X10_REVE_PH_F10PHMICROCODEPATCHTABLES_FILECODE  (0xC867)

// Family 12h
#define PROC_CPU_FAMILY_0X12_CPUCOMMONF12UTILITIES_FILECODE              (0xC901)
#define PROC_CPU_FAMILY_0X12_CPUF12BRANDID_FILECODE                      (0xC902)
#define PROC_CPU_FAMILY_0X12_CPUF12CACHEDEFAULTS_FILECODE                (0xC903)
#define PROC_CPU_FAMILY_0X12_CPUF12DMI_FILECODE                          (0xC904)
#define PROC_CPU_FAMILY_0X12_CPUF12MSRTABLES_FILECODE                    (0xC905)
#define PROC_CPU_FAMILY_0X12_CPUF12EARLYNBPSTATEINIT_FILECODE            (0xC906)
#define PROC_CPU_FAMILY_0X12_CPUF12PCITABLES_FILECODE                    (0xC907)
#define PROC_CPU_FAMILY_0X12_CPUF12POWERCHECK_FILECODE                   (0xC908)
#define PROC_CPU_FAMILY_0X12_CPUF12POWERMGMTSYSTEMTABLES_FILECODE        (0xC909)
#define PROC_CPU_FAMILY_0X12_CPUF12POWERPLANE_FILECODE                   (0xC90A)
#define PROC_CPU_FAMILY_0X12_CPUF12SOFTWARETHERMAL_FILECODE              (0xC90B)
#define PROC_CPU_FAMILY_0X12_CPUF12UTILITIES_FILECODE                    (0xC90C)
#define PROC_CPU_FAMILY_0X12_CPUF12WHEAINITDATATABLES_FILECODE           (0xC90D)
#define PROC_CPU_FAMILY_0X12_CPUF12PSTATE_FILECODE                       (0xC90E)
#define PROC_CPU_FAMILY_0X12_F12C6STATE_FILECODE                         (0xC90F)
#define PROC_CPU_FAMILY_0X12_F12CPB_FILECODE                             (0xC910)
#define PROC_CPU_FAMILY_0X12_F12IOCSTATE_FILECODE                        (0xC911)
#define PROC_CPU_FAMILY_0X12_LN_F12LNLOGICALIDTABLES_FILECODE            (0xC921)
#define PROC_CPU_FAMILY_0X12_LN_F12LNMICROCODEPATCHTABLES_FILECODE       (0xC922)
#define PROC_CPU_FAMILY_0X12_LN_F12LNEQUIVALENCETABLE_FILECODE           (0xC923)
#define PROC_CPU_FAMILY_0X12_CPUF12PERCOREPCITABLES_FILECODE             (0xC924)
#define PROC_CPU_FAMILY_0X12_LN_F12LNEARLYSAMPLES_FILECODE               (0xC925)

// Family 14h
#define PROC_CPU_FAMILY_0X14_CPUCOMMONF14UTILITIES_FILECODE              (0xCA01)
#define PROC_CPU_FAMILY_0X14_CPUF14BRANDID_FILECODE                      (0xCA02)
#define PROC_CPU_FAMILY_0X14_CPUF14CACHEDEFAULTS_FILECODE                (0xCA03)
#define PROC_CPU_FAMILY_0X14_CPUF14DMI_FILECODE                          (0xCA04)
#define PROC_CPU_FAMILY_0X14_CPUF14MSRTABLES_FILECODE                    (0xCA05)
#define PROC_CPU_FAMILY_0X14_CPUF14PCITABLES_FILECODE                    (0xCA06)
#define PROC_CPU_FAMILY_0X14_CPUF14POWERCHECK_FILECODE                   (0xCA07)
#define PROC_CPU_FAMILY_0X14_CPUF14POWERMGMTSYSTEMTABLES_FILECODE        (0xCA08)
#define PROC_CPU_FAMILY_0X14_CPUF14POWERPLANE_FILECODE                   (0xCA09)
#define PROC_CPU_FAMILY_0X14_CPUF14SOFTWARETHERMAL_FILECODE              (0xCA0A)
#define PROC_CPU_FAMILY_0X14_CPUF14UTILITIES_FILECODE                    (0xCA0B)
#define PROC_CPU_FAMILY_0X14_CPUF14WHEAINITDATATABLES_FILECODE           (0xCA0C)
#define PROC_CPU_FAMILY_0X14_CPUF14PSTATE_FILECODE                       (0xCA0D)
#define PROC_CPU_FAMILY_0X14_F14C6STATE_FILECODE                         (0xCA0E)
#define PROC_CPU_FAMILY_0X14_F14IOCSTATE_FILECODE                        (0xCA0F)
#define PROC_CPU_FAMILY_0X14_CPUF14PERCOREPCITABLES_FILECODE             (0xCA10)
#define PROC_CPU_FAMILY_0X14_CPUF14LOWPOWERINIT_FILECODE                 (0xCA11)
#define PROC_CPU_FAMILY_0X14_ON_F14ONLOGICALIDTABLES_FILECODE            (0xCA21)
#define PROC_CPU_FAMILY_0X14_ON_F14ONMICROCODEPATCHTABLES_FILECODE       (0xCA22)
#define PROC_CPU_FAMILY_0X14_ON_F14ONEQUIVALENCETABLE_FILECODE           (0xCA23)
#define PROC_CPU_FAMILY_0X14_ON_F14ONINITEARLYTABLE_FILECODE             (0xCA24)
#define PROC_CPU_FAMILY_0X14_ON_F14ONEARLYSAMPLES_FILECODE               (0xCA26)
#define PROC_CPU_FAMILY_0X14_ON_F14ONCPB_FILECODE                        (0xCA2C)
#define PROC_CPU_FAMILY_0X14_ON_F14ONPCITABLES_FILECODE                  (0xCA2D)

// Family 15h
#define PROC_CPU_FAMILY_0X15_CPUCOMMONF15UTILITIES_FILECODE              (0xCB01)
#define PROC_CPU_FAMILY_0X15_CPUF15BRANDID_FILECODE                      (0xCB02)
#define PROC_CPU_FAMILY_0X15_CPUF15CACHEDEFAULTS_FILECODE                (0xCB03)
#define PROC_CPU_FAMILY_0X15_CPUF15CACHEFLUSHONHALT_FILECODE             (0xCB04)
#define PROC_CPU_FAMILY_0X15_CPUF15COREAFTERRESET_FILECODE               (0xCB05)
#define PROC_CPU_FAMILY_0X15_CPUF15DMI_FILECODE                          (0xCB06)
#define PROC_CPU_FAMILY_0X15_CPUF15FEATURELEVELING_FILECODE              (0xCB07)
#define PROC_CPU_FAMILY_0X15_CPUF15HTPHYTABLES_FILECODE                  (0xCB08)
#define PROC_CPU_FAMILY_0X15_CPUF15MSRTABLES_FILECODE                    (0xCB09)
#define PROC_CPU_FAMILY_0X15_CPUF15NBAFTERRESET_FILECODE                 (0xCB0A)
#define PROC_CPU_FAMILY_0X15_CPUF15PCITABLES_FILECODE                    (0xCB0B)
#define PROC_CPU_FAMILY_0X15_CPUF15POWERCHECK_FILECODE                   (0xCB0C)
#define PROC_CPU_FAMILY_0X15_CPUF15POWERMGMTSYSTEMTABLES_FILECODE        (0xCB0D)
#define PROC_CPU_FAMILY_0X15_CPUF15POWERPLANE_FILECODE                   (0xCB0E)
#define PROC_CPU_FAMILY_0X15_CPUF15SOFTWARETHERMAL_FILECODE              (0xCB0F)
#define PROC_CPU_FAMILY_0X15_CPUF15UTILITIES_FILECODE                    (0xCB10)
#define PROC_CPU_FAMILY_0X15_CPUF15WHEAINITDATATABLES_FILECODE           (0xCB11)
#define PROC_CPU_FAMILY_0X15_CPUF15PSTATE_FILECODE                       (0xCB12)
#define PROC_CPU_FAMILY_0X15_F15PMNBCOFVIDINIT_FILECODE                  (0xCB13)
#define PROC_CPU_FAMILY_0X15_F15SINGLELINKPCITABLES_FILECODE             (0xCB14)
#define PROC_CPU_FAMILY_0X15_F15MULTILINKPCITABLES_FILECODE              (0xCB15)
#define PROC_CPU_FAMILY_0X15_F15C6STATE_FILECODE                         (0xCB16)
#define PROC_CPU_FAMILY_0X15_F15CPB_FILECODE                             (0xCB17)
#define PROC_CPU_FAMILY_0X15_F15INITEARLYTABLE_FILECODE                  (0xCB18)
#define PROC_CPU_FAMILY_0X15_F15LOWPWRPSTATE_FILECODE                    (0xCB19)
#define PROC_CPU_FAMILY_0X15_CPUF15WORKAROUNDSTABLE_FILECODE             (0xCB1A)
#define PROC_CPU_FAMILY_0X15_F15IOCSTATE_FILECODE                        (0xCB1B)
#define PROC_CPU_FAMILY_0X15_OR_F15ORHTASSIST_FILECODE                   (0xCB30)
#define PROC_CPU_FAMILY_0X15_OR_F15ORMSGBASEDC1E_FILECODE                (0xCB31)
#define PROC_CPU_FAMILY_0X15_OR_F15ORLOGICALIDTABLES_FILECODE            (0xCB32)
#define PROC_CPU_FAMILY_0X15_OR_F15ORMICROCODEPATCHTABLES_FILECODE       (0xCB33)
#define PROC_CPU_FAMILY_0X15_OR_F15ORMSRTABLES_FILECODE                  (0xCB34)
#define PROC_CPU_FAMILY_0X15_OR_F15ORSHAREDMSRTABLE_FILECODE             (0xCB35)
#define PROC_CPU_FAMILY_0X15_OR_F15OREQUIVALENCETABLE_FILECODE           (0xCB36)
#define PROC_CPU_FAMILY_0X15_OR_F15ORPCITABLES_FILECODE                  (0xCB37)



#define PROC_CPU_FEATURE_CPUCACHEFLUSHONHALT_FILECODE                    (0xDC01)
#define PROC_CPU_FEATURE_CPUCACHEINIT_FILECODE                           (0xDC02)
#define PROC_CPU_FEATURE_CPUDMI_FILECODE                                 (0xDC10)
#define PROC_CPU_FEATURE_CPUFEATURELEVELING_FILECODE                     (0xDC20)
#define PROC_CPU_FEATURE_CPUHTASSIST_FILECODE                            (0xDC30)
#define PROC_CPU_FEATURE_CPUPSTATEGATHER_FILECODE                        (0xDC41)
#define PROC_CPU_FEATURE_CPUPSTATELEVELING_FILECODE                      (0xDC42)
#define PROC_CPU_FEATURE_CPUPSTATETABLES_FILECODE                        (0xDC43)
#define PROC_CPU_FEATURE_CPUSLIT_FILECODE                                (0xDC50)
#define PROC_CPU_FEATURE_CPUSRAT_FILECODE                                (0xDC60)
#define PROC_CPU_FEATURE_CPUWHEA_FILECODE                                (0xDC70)
#define PROC_CPU_FEATURE_CPUHWC1E_FILECODE                               (0xDC80)
#define PROC_CPU_FEATURE_CPUSWC1E_FILECODE                               (0xDC81)
#define PROC_CPU_FEATURE_CPUC6STATE_FILECODE                             (0xDC82)
#define PROC_CPU_FEATURE_CPUCPB_FILECODE                                 (0xDC83)
#define PROC_CPU_FEATURE_CPULOWPWRPSTATE_FILECODE                        (0xDC84)
#define PROC_CPU_FEATURE_CPUIOCSTATE_FILECODE                            (0xDC85)
#define PROC_CPU_FEATURE_CPUFEATURES_FILECODE                            (0xDC90)
#define PROC_CPU_FEATURE_CPUMSGBASEDC1E_FILECODE                         (0xDCA0)
#define PROC_CPU_FEATURE_CPUCORELEVELING_FILECODE                        (0xDCB0)
#define PROC_CPU_FEATURE_PRESERVEMAILBOX_FILECODE                        (0xDCC0)

#define PROC_RECOVERY_CPU_CPURECOVERY_FILECODE                           (0xDE01)

#define PROC_HT_FEATURES_HTFEATSETS_FILECODE                             (0xE001)
#define PROC_HT_FEATURES_HTFEATDYNAMICDISCOVERY_FILECODE                 (0xE002)
#define PROC_HT_FEATURES_HTFEATGANGING_FILECODE                          (0xE003)
#define PROC_HT_FEATURES_HTFEATNONCOHERENT_FILECODE                      (0xE004)
#define PROC_HT_FEATURES_HTFEATOPTIMIZATION_FILECODE                     (0xE005)
#define PROC_HT_FEATURES_HTFEATROUTING_FILECODE                          (0xE006)
#define PROC_HT_FEATURES_HTFEATSUBLINKS_FILECODE                         (0xE007)
#define PROC_HT_FEATURES_HTFEATTRAFFICDISTRIBUTION_FILECODE              (0xE008)
#define PROC_HT_FEATURES_HTIDS_FILECODE                                  (0xE009)
#define PROC_HT_HTFEAT_FILECODE                                          (0xE021)
#define PROC_HT_HTINTERFACE_FILECODE                                     (0xE022)
#define PROC_HT_HTINTERFACECOHERENT_FILECODE                             (0xE023)
#define PROC_HT_HTINTERFACEGENERAL_FILECODE                              (0xE024)
#define PROC_HT_HTINTERFACENONCOHERENT_FILECODE                          (0xE025)
#define PROC_HT_HTMAIN_FILECODE                                          (0xE026)
#define PROC_HT_HTNOTIFY_FILECODE                                        (0xE027)
#define PROC_HT_HTGRAPH_HTGRAPH_FILECODE                                 (0xE028)
#define PROC_HT_HTNB_FILECODE                                            (0xE081)
#define PROC_HT_NBCOMMON_HTNBCOHERENT_FILECODE                           (0xE082)
#define PROC_HT_NBCOMMON_HTNBNONCOHERENT_FILECODE                        (0xE083)
#define PROC_HT_NBCOMMON_HTNBOPTIMIZATION_FILECODE                       (0xE084)
#define PROC_HT_NBCOMMON_HTNBUTILITIES_FILECODE                          (0xE085)
#define PROC_HT_FAM10_HTNBFAM10_FILECODE                                 (0xE0C1)
#define PROC_HT_FAM10_HTNBCOHERENTFAM10_FILECODE                         (0xE0C2)
#define PROC_HT_FAM10_HTNBNONCOHERENTFAM10_FILECODE                      (0xE0C3)
#define PROC_HT_FAM10_HTNBOPTIMIZATIONFAM10_FILECODE                     (0xE0C4)
#define PROC_HT_FAM10_HTNBSYSTEMFAM10_FILECODE                           (0xE0C5)
#define PROC_HT_FAM10_HTNBUTILITIESFAM10_FILECODE                        (0xE0C6)
#define PROC_HT_FAM12_HTNBFAM12_FILECODE                                 (0xE101)
#define PROC_HT_FAM12_HTNBUTILITIESFAM12_FILECODE                        (0xE102)
#define PROC_HT_FAM14_HTNBFAM14_FILECODE                                 (0xE141)
#define PROC_HT_FAM14_HTNBUTILITIESFAM14_FILECODE                        (0xE142)
#define PROC_HT_FAM15_HTNBFAM15_FILECODE                                 (0xE181)
#define PROC_HT_FAM15_HTNBCOHERENTFAM15_FILECODE                         (0xE182)
#define PROC_HT_FAM15_HTNBNONCOHERENTFAM15_FILECODE                      (0xE183)
#define PROC_HT_FAM15_HTNBOPTIMIZATIONFAM15_FILECODE                     (0xE184)
#define PROC_HT_FAM15_HTNBSYSTEMFAM15_FILECODE                           (0xE185)
#define PROC_HT_FAM15_HTNBUTILITIESFAM15_FILECODE                        (0xE186)

#define PROC_RECOVERY_HT_HTINITRECOVERY_FILECODE                         (0xE302)
#define PROC_RECOVERY_HT_HTINITRESET_FILECODE                            (0xE301)

#define PROC_IDS_CONTROL_IDSCTRL_FILECODE                                (0xE801)
#define PROC_IDS_CONTROL_IDSLIB_FILECODE                                 (0xE802)
#define PROC_IDS_DEBUG_IDSDEBUG_FILECODE                                 (0xE803)
#define PROC_IDS_PERF_IDSPERF_FILECODE                                   (0xE804)
#define PROC_IDS_FAMILY_0X10_IDSF10ALLSERVICE_FILECODE                   (0xE805)
#define PROC_IDS_FAMILY_0X10_BL_IDSF10BLSERVICE_FILECODE                 (0xE806)
#define PROC_IDS_FAMILY_0X10_DA_IDSF10DASERVICE_FILECODE                 (0xE807)
#define PROC_IDS_FAMILY_0X10_HY_IDSF10HYSERVICE_FILECODE                 (0xE808)
#define PROC_IDS_FAMILY_0X10_RB_IDSF10RBSERVICE_FILECODE                 (0xE809)
#define PROC_IDS_FAMILY_0X12_IDSF12ALLSERVICE_FILECODE                   (0xE80A)
#define PROC_IDS_FAMILY_0X14_IDSF14ALLSERVICE_FILECODE                   (0xE80B)
#define PROC_IDS_FAMILY_0X15_IDSF15ALLSERVICE_FILECODE                   (0xE80C)

#define PROC_IDS_DEBUG_IDSIDTTABLE_FILECODE                              (0xE80D)
#define PROC_IDS_CONTROL_IDSNVTOCMOS_FILECODE                            (0xE80E)

///0xE820 ~ 0xE840 is reserved for ids extend module

#define PROC_MEM_ARDK_MA_FILECODE                                    (0xF001)
#define PROC_MEM_ARDK_DR_MARDR2_FILECODE                             (0xF002)
#define PROC_MEM_ARDK_DR_MARDR3_FILECODE                             (0xF003)
#define PROC_MEM_ARDK_HY_MARHY3_FILECODE                             (0xF004)
#define PROC_MEM_ARDK_LN_MASLN3_FILECODE                             (0xF005)
#define PROC_MEM_ARDK_DR_MAUDR3_FILECODE                             (0xF006)
#define PROC_MEM_ARDK_HY_MAUHY3_FILECODE                             (0xF007)
#define PROC_MEM_ARDK_LN_MAULN3_FILECODE                             (0xF008)
#define PROC_MEM_ARDK_DA_MAUDA3_FILECODE                             (0xF009)
#define PROC_MEM_ARDK_DA_MASDA2_FILECODE                             (0xF00A)
#define PROC_MEM_ARDK_DA_MASDA3_FILECODE                             (0xF00B)
#define PROC_MEM_ARDK_NI_MASNI3_FILECODE                             (0xF00C)
#define PROC_MEM_ARDK_C32_MARC32_3_FILECODE                          (0xF00D)
#define PROC_MEM_ARDK_C32_MAUC32_3_FILECODE                          (0xF00E)
#define PROC_MEM_ARDK_NI_MAUNI3_FILECODE                             (0xF00F)
#define PROC_MEM_ARDK_ON_MASON3_FILECODE                             (0xF010)
#define PROC_MEM_ARDK_ON_MAUON3_FILECODE                             (0xF011)
#define PROC_MEM_ARDK_PH_MASPH3_FILECODE                             (0xF012)
#define PROC_MEM_ARDK_PH_MAUPH3_FILECODE                             (0xF013)
#define PROC_MEM_ARDK_OR_MAROR3_FILECODE                             (0xF014)
#define PROC_MEM_ARDK_OR_MAUOR3_FILECODE                             (0xF017)
#define PROC_MEM_ARDK_RB_MASRB3_FILECODE                             (0xF018)
#define PROC_MEM_ARDK_RB_MAURB3_FILECODE                             (0xF019)

#define PROC_MEM_FEAT_CHINTLV_MFCHI_FILECODE                         (0xF081)
#define PROC_MEM_FEAT_CSINTLV_MFCSI_FILECODE                         (0xF082)
#define PROC_MEM_FEAT_ECC_MFECC_FILECODE                             (0xF083)
#define PROC_MEM_FEAT_ECC_MFEMP_FILECODE                             (0xF085)
#define PROC_MEM_FEAT_EXCLUDIMM_MFDIMMEXCLUD_FILECODE                (0xF086)
#define PROC_MEM_FEAT_IDENDIMM_MFIDENDIMM_FILECODE                   (0xF088)
#define PROC_MEM_FEAT_INTLVRN_MFINTLVRN_FILECODE                     (0xF089)
#define PROC_MEM_FEAT_LVDDR3_MFLVDDR3_FILECODE                       (0xF08A)
#define PROC_MEM_FEAT_MEMCLR_MFMEMCLR_FILECODE                       (0xF08B)
#define PROC_MEM_FEAT_NDINTLV_MFNDI_FILECODE                         (0xF08C)
#define PROC_MEM_FEAT_ODTHERMAL_MFODTHERMAL_FILECODE                 (0xF08D)
#define PROC_MEM_FEAT_OLSPARE_MFSPR_FILECODE                         (0xF08E)
#define PROC_MEM_FEAT_PARTRN_MFPARALLELTRAINING_FILECODE             (0xF08F)
#define PROC_MEM_FEAT_PARTRN_MFSTANDARDTRAINING_FILECODE             (0xF091)
#define PROC_MEM_FEAT_S3_MFS3_FILECODE                               (0xF092)
#define PROC_MEM_FEAT_TABLE_MFTDS_FILECODE                           (0xF093)

#define PROC_MEM_MAIN_MDEF_FILECODE                                  (0xF101)
#define PROC_MEM_MAIN_MINIT_FILECODE                                 (0xF102)
#define PROC_MEM_MAIN_MM_FILECODE                                    (0xF103)
#define PROC_MEM_FEAT_DMI_MFDMI_FILECODE                             (0xF104)
#define PROC_MEM_MAIN_MMECC_FILECODE                                 (0xF105)
#define PROC_MEM_MAIN_MMEXCLUDEDIMM_FILECODE                         (0xF106)
#define PROC_MEM_MAIN_DR_MMFLOWDR_FILECODE                           (0xF107)
#define PROC_MEM_MAIN_HY_MMFLOWHY_FILECODE                           (0xF108)
#define PROC_MEM_MAIN_LN_MMFLOWLN_FILECODE                           (0xF109)
#define PROC_MEM_MAIN_ON_MMFLOWON_FILECODE                           (0xF10A)
#define PROC_MEM_MAIN_MMNODEINTERLEAVE_FILECODE                      (0xF10B)
#define PROC_MEM_MAIN_MMONLINESPARE_FILECODE                         (0xF10C)
#define PROC_MEM_MAIN_MMPARALLELTRAINING_FILECODE                    (0xF10D)
#define PROC_MEM_MAIN_MMSTANDARDTRAINING_FILECODE                    (0xF10E)
#define PROC_MEM_MAIN_MUC_FILECODE                                   (0xF10F)
#define PROC_MEM_MAIN_MMMEMCLR_FILECODE                              (0xF110)
#define PROC_MEM_MAIN_DA_MMFLOWDA_FILECODE                           (0xF111)
#define PROC_MEM_MAIN_MMFLOW_FILECODE                                (0xF112)
#define PROC_MEM_MAIN_MERRHDL_FILECODE                               (0xF113)
#define PROC_MEM_MAIN_C32_MMFLOWC32_FILECODE                         (0xF114)
#define PROC_MEM_MAIN_MMLVDDR3_FILECODE                              (0xF115)
#define PROC_MEM_MAIN_MMUMAALLOC_FILECODE                            (0xF116)
#define PROC_MEM_MAIN_MMMEMRESTORE_FILECODE                          (0xF117)
#define PROC_MEM_MAIN_MMCONDITIONALPSO_FILECODE                      (0xF118)
#define PROC_MEM_MAIN_OR_MMFLOWOR_FILECODE                           (0xF119)
#define PROC_MEM_MAIN_RB_MMFLOWRB_FILECODE                           (0xF11A)
#define PROC_MEM_MAIN_PH_MMFLOWPH_FILECODE                           (0xF11B)

#define PROC_MEM_NB_DR_MNDR_FILECODE                                 (0XF213)
#define PROC_MEM_NB_DR_MNFLOWDR_FILECODE                             (0XF214)
#define PROC_MEM_NB_DR_MNIDENDIMMDR_FILECODE                         (0XF216)
#define PROC_MEM_NB_DR_MNMCTDR_FILECODE                              (0XF217)
#define PROC_MEM_NB_DR_MNDCTDR_FILECODE                              (0XF218)
#define PROC_MEM_NB_DR_MNOTDR_FILECODE                               (0XF219)
#define PROC_MEM_NB_DR_MNPARTRAINDR_FILECODE                         (0XF21A)
#define PROC_MEM_NB_DR_MNPROTODR_FILECODE                            (0XF21C)
#define PROC_MEM_NB_DR_MNS3DR_FILECODE                               (0XF21D)
#define PROC_MEM_NB_DR_MNREGDR_FILECODE                              (0XF21E)
#define PROC_MEM_NB_RB_MNRB_FILECODE                                 (0XF220)
#define PROC_MEM_NB_RB_MNFLOWRB_FILECODE                             (0XF221)
#define PROC_MEM_NB_RB_MNS3RB_FILECODE                               (0XF222)
#define PROC_MEM_NB_RB_MNIDENDIMMRB_FILECODE                         (0XF223)
#define PROC_MEM_NB_HY_MNFLOWHY_FILECODE                             (0XF233)
#define PROC_MEM_NB_HY_MNHY_FILECODE                                 (0XF235)
#define PROC_MEM_NB_HY_MNIDENDIMMHY_FILECODE                         (0XF236)
#define PROC_MEM_NB_HY_MNMCTHY_FILECODE                              (0XF237)
#define PROC_MEM_NB_HY_MNDCTHY_FILECODE                              (0XF238)
#define PROC_MEM_NB_HY_MNOTHY_FILECODE                               (0XF239)
#define PROC_MEM_NB_HY_MNPARTRAINHY_FILECODE                         (0XF23A)
#define PROC_MEM_NB_HY_MNPHYHY_FILECODE                              (0XF23B)
#define PROC_MEM_NB_HY_MNPROTOHY_FILECODE                            (0XF23C)
#define PROC_MEM_NB_HY_MNS3HY_FILECODE                               (0XF23D)
#define PROC_MEM_NB_HY_MNREGHY_FILECODE                              (0XF23E)
#define PROC_MEM_NB_ON_MNON_FILECODE                                 (0xF240)
#define PROC_MEM_NB_ON_MNREGON_FILECODE                              (0xF241)
#define PROC_MEM_NB_ON_MNDCTON_FILECODE                              (0xF242)
#define PROC_MEM_NB_ON_MNIDENDIMMON_FILECODE                         (0xF244)
#define PROC_MEM_NB_ON_MNMCTON_FILECODE                              (0xF245)
#define PROC_MEM_NB_ON_MNOTON_FILECODE                               (0xF246)
#define PROC_MEM_NB_ON_MNPHYON_FILECODE                              (0xF247)
#define PROC_MEM_NB_ON_MNS3ON_FILECODE                               (0xF248)
#define PROC_MEM_NB_ON_MNFLOWON_FILECODE                             (0xF249)
#define PROC_MEM_NB_ON_MNPROTOON_FILECODE                            (0xF24A)
#define PROC_MEM_NB_LN_MNDCTLN_FILECODE                              (0XF252)
#define PROC_MEM_NB_LN_MNFLOWLN_FILECODE                             (0XF253)
#define PROC_MEM_NB_LN_MNIDENDIMMLN_FILECODE                         (0XF254)
#define PROC_MEM_NB_LN_MNMCTLN_FILECODE                              (0XF255)
#define PROC_MEM_NB_LN_MNOTLN_FILECODE                               (0XF256)
#define PROC_MEM_NB_LN_MNPHYLN_FILECODE                              (0XF257)
#define PROC_MEM_NB_LN_MNPROTOLN_FILECODE                            (0XF258)
#define PROC_MEM_NB_LN_MNLN_FILECODE                                 (0XF259)
#define PROC_MEM_NB_LN_MNS3LN_FILECODE                               (0XF25A)
#define PROC_MEM_NB_LN_MNREGLN_FILECODE                              (0XF25B)
#define PROC_MEM_NB_DA_MNDA_FILECODE                                 (0XF260)
#define PROC_MEM_NB_DA_MNFLOWDA_FILECODE                             (0XF261)
#define PROC_MEM_NB_DA_MNIDENDIMMDA_FILECODE                         (0XF263)
#define PROC_MEM_NB_DA_MNMCTDA_FILECODE                              (0XF264)
#define PROC_MEM_NB_DA_MNDCTDA_FILECODE                              (0XF265)
#define PROC_MEM_NB_DA_MNOTDA_FILECODE                               (0XF266)
#define PROC_MEM_NB_DA_MNPARTRAINDA_FILECODE                         (0XF267)
#define PROC_MEM_NB_DA_MNPROTODA_FILECODE                            (0XF269)
#define PROC_MEM_NB_DA_MNS3DA_FILECODE                               (0XF26A)
#define PROC_MEM_NB_DA_MNREGDA_FILECODE                              (0XF26B)
#define PROC_MEM_NB_C32_MNC32_FILECODE                               (0XF26C)
#define PROC_MEM_NB_C32_MNDCTC32_FILECODE                            (0XF26D)
#define PROC_MEM_NB_C32_MNFLOWC32_FILECODE                           (0XF26E)
#define PROC_MEM_NB_C32_MNIDENDIMMC32_FILECODE                       (0XF26F)
#define PROC_MEM_NB_C32_MNMCTC32_FILECODE                            (0XF270)
#define PROC_MEM_NB_C32_MNOTC32_FILECODE                             (0XF271)
#define PROC_MEM_NB_C32_MNPARTRAINC32_FILECODE                       (0XF272)
#define PROC_MEM_NB_C32_MNPHYC32_FILECODE                            (0XF273)
#define PROC_MEM_NB_C32_MNPROTOC32_FILECODE                          (0XF274)
#define PROC_MEM_NB_C32_MNS3C32_FILECODE                             (0XF275)
#define PROC_MEM_NB_C32_MNREGC32_FILECODE                            (0XF277)
#define PROC_MEM_NB_MN_FILECODE                                      (0XF27C)
#define PROC_MEM_NB_MNDCT_FILECODE                                   (0XF27D)
#define PROC_MEM_NB_MNPHY_FILECODE                                   (0XF27E)
#define PROC_MEM_NB_MNMCT_FILECODE                                   (0XF27F)
#define PROC_MEM_NB_MNS3_FILECODE                                    (0XF280)
#define PROC_MEM_NB_MNFLOW_FILECODE                                  (0XF281)
#define PROC_MEM_NB_MNFEAT_FILECODE                                  (0XF282)
#define PROC_MEM_NB_MNTRAIN2_FILECODE                                (0XF283)
#define PROC_MEM_NB_MNTRAIN3_FILECODE                                (0XF284)
#define PROC_MEM_NB_MNREG_FILECODE                                   (0XF285)
#define PROC_MEM_NB_NI_MNNI_FILECODE                                 (0XF286)
#define PROC_MEM_NB_NI_MNS3NI_FILECODE                               (0XF287)
#define PROC_MEM_NB_NI_MNFLOWNI_FILECODE                             (0XF288)
#define PROC_MEM_NB_PH_MNFLOWPH_FILECODE                             (0XF289)
#define PROC_MEM_NB_PH_MNPH_FILECODE                                 (0XF28A)
#define PROC_MEM_NB_PH_MNS3PH_FILECODE                               (0XF28B)
#define PROC_MEM_NB_PH_MNIDENDIMMPH_FILECODE                         (0XF28C)
#define PROC_MEM_NB_OR_MNFLOWOR_FILECODE                             (0XF290)
#define PROC_MEM_NB_OR_MNOR_FILECODE                                 (0XF291)
#define PROC_MEM_NB_OR_MNIDENDIMMOR_FILECODE                         (0XF292)
#define PROC_MEM_NB_OR_MNMCTOR_FILECODE                              (0XF293)
#define PROC_MEM_NB_OR_MNDCTOR_FILECODE                              (0XF294)
#define PROC_MEM_NB_OR_MNOTOR_FILECODE                               (0XF295)
#define PROC_MEM_NB_OR_MNPARTRAINOR_FILECODE                         (0XF296)
#define PROC_MEM_NB_OR_MNPHYOR_FILECODE                              (0XF297)
#define PROC_MEM_NB_OR_MNPROTOOR_FILECODE                            (0XF298)
#define PROC_MEM_NB_OR_MNS3OR_FILECODE                               (0XF299)
#define PROC_MEM_NB_OR_MNREGOR_FILECODE                              (0XF29A)

#define PROC_MEM_PS_MP_FILECODE                                      (0XF401)
#define PROC_MEM_PS_DR_MPRDR3_FILECODE                               (0XF402)
#define PROC_MEM_PS_HY_MPRHY3_FILECODE                               (0XF403)
#define PROC_MEM_PS_LN_MPRLN3_FILECODE                               (0XF404)
#define PROC_MEM_PS_DR_MPSDR3_FILECODE                               (0XF405)
#define PROC_MEM_PS_HY_MPSHY3_FILECODE                               (0XF406)
#define PROC_MEM_PS_LN_MPSLN3_FILECODE                               (0XF407)
#define PROC_MEM_PS_DR_MPUDR3_FILECODE                               (0XF408)
#define PROC_MEM_PS_HY_MPUHY3_FILECODE                               (0XF409)
#define PROC_MEM_PS_LN_MPULN3_FILECODE                               (0XF40A)
#define PROC_MEM_PS_DA_MPUDA3_FILECODE                               (0XF40B)
#define PROC_MEM_PS_DA_MPSDA2_FILECODE                               (0XF40C)
#define PROC_MEM_PS_DA_MPSDA3_FILECODE                               (0XF40D)
#define PROC_MEM_PS_DR_MPRDR2_FILECODE                               (0XF40E)
#define PROC_MEM_PS_DR_MPUDR2_FILECODE                               (0XF40F)
#define PROC_MEM_PS_C32_MPRC32_3_FILECODE                            (0XF410)
#define PROC_MEM_PS_C32_MPUC32_3_FILECODE                            (0XF411)
#define PROC_MEM_PS_NI_MPSNI3_FILECODE                               (0XF412)
#define PROC_MEM_PS_NI_MPUNI3_FILECODE                               (0XF413)
#define PROC_MEM_PS_ON_MPSON3_FILECODE                               (0XF414)
#define PROC_MEM_PS_ON_MPUON3_FILECODE                               (0XF415)
#define PROC_MEM_PS_PH_MPSPH3_FILECODE                               (0XF416)
#define PROC_MEM_PS_PH_MPUPH3_FILECODE                               (0XF417)
#define PROC_MEM_PS_RB_MPSRB3_FILECODE                               (0XF418)
#define PROC_MEM_PS_RB_MPURB3_FILECODE                               (0XF419)
#define PROC_MEM_PS_OR_AM3_MPUORA3_FILECODE                          (0XF41A)
#define PROC_MEM_PS_OR_AM3_MPSORA3_FILECODE                          (0XF41B)
#define PROC_MEM_PS_OR_C32_MPRORC3_FILECODE                          (0XF41C)
#define PROC_MEM_PS_OR_C32_MPUORC3_FILECODE                          (0XF41D)
#define PROC_MEM_PS_OR_C32_MPLORC3_FILECODE                          (0XF41E)
#define PROC_MEM_PS_OR_G34_MPRORG3_FILECODE                          (0XF41F)
#define PROC_MEM_PS_OR_G34_MPUORG3_FILECODE                          (0XF420)
#define PROC_MEM_PS_OR_G34_MPLORG3_FILECODE                          (0XF421)
#define PROC_MEM_PS_MPRTT_FILECODE                                   (0XF422)
#define PROC_MEM_PS_MPMAXFREQ_FILECODE                               (0XF423)
#define PROC_MEM_PS_MPODTPAT_FILECODE                                (0XF424)
#define PROC_MEM_PS_MPSAO_FILECODE                                   (0XF425)
#define PROC_MEM_PS_MPMR0_FILECODE                                   (0XF426)
#define PROC_MEM_PS_MPRC2IBT_FILECODE                                (0XF427)
#define PROC_MEM_PS_MPRC10OPSPD_FILECODE                             (0XF428)
#define PROC_MEM_PS_MPLRIBT_FILECODE                                 (0XF429)
#define PROC_MEM_PS_MPLRNPR_FILECODE                                 (0XF42A)
#define PROC_MEM_PS_MPLRNLR_FILECODE                                 (0XF42B)
#define PROC_MEM_PS_OR_MPOR3_FILECODE                                (0XF42C)

#define PROC_MEM_TECH_MT_FILECODE                                    (0XF501)
#define PROC_MEM_TECH_MTHDI_FILECODE                                 (0XF502)
#define PROC_MEM_TECH_MTTDIMBT_FILECODE                              (0XF504)
#define PROC_MEM_TECH_MTTECC_FILECODE                                (0XF505)
#define PROC_MEM_TECH_MTTHRC_FILECODE                                (0XF506)
#define PROC_MEM_TECH_MTTML_FILECODE                                 (0XF507)
#define PROC_MEM_TECH_MTTOPTSRC_FILECODE                             (0XF509)
#define PROC_MEM_TECH_MTTSRC_FILECODE                                (0XF50B)
#define PROC_MEM_TECH_MTTEDGEDETECT_FILECODE                         (0XF50C)
#define PROC_MEM_TECH_DDR2_MT2_FILECODE                              (0XF541)
#define PROC_MEM_TECH_DDR2_MTOT2_FILECODE                            (0XF543)
#define PROC_MEM_TECH_DDR2_MTSPD2_FILECODE                           (0XF544)
#define PROC_MEM_TECH_DDR3_MT3_FILECODE                              (0XF581)
#define PROC_MEM_TECH_DDR3_MTOT3_FILECODE                            (0XF583)
#define PROC_MEM_TECH_DDR3_MTRCI3_FILECODE                           (0XF584)
#define PROC_MEM_TECH_DDR3_MTSDI3_FILECODE                           (0XF585)
#define PROC_MEM_TECH_DDR3_MTSPD3_FILECODE                           (0XF586)
#define PROC_MEM_TECH_DDR3_MTTWL3_FILECODE                           (0XF587)
#define PROC_MEM_TECH_DDR3_MTTECC3_FILECODE                          (0XF588)
#define PROC_MEM_TECH_DDR3_MTLRDIMM3_FILECODE                        (0XF589)

#define PROC_RECOVERY_MEM_MRDEF_FILECODE                             (0XF801)
#define PROC_RECOVERY_MEM_MRINIT_FILECODE                            (0XF802)
#define PROC_RECOVERY_MEM_MRM_FILECODE                               (0XF803)
#define PROC_RECOVERY_MEM_MRUC_FILECODE                              (0XF804)
#define PROC_RECOVERY_MEM_NB_DR_MRNDR_FILECODE                       (0XF812)
#define PROC_RECOVERY_MEM_NB_DR_MRNMCTDR_FILECODE                    (0XF813)
#define PROC_RECOVERY_MEM_NB_HY_MRNDCTHY_FILECODE                    (0XF821)
#define PROC_RECOVERY_MEM_NB_HY_MRNHY_FILECODE                       (0XF822)
#define PROC_RECOVERY_MEM_NB_HY_MRNMCTHY_FILECODE                    (0XF823)
#define PROC_RECOVERY_MEM_NB_HY_MRNPROTOHY_FILECODE                  (0XF825)
#define PROC_RECOVERY_MEM_NB_LN_MRNDCTLN_FILECODE                    (0XF831)
#define PROC_RECOVERY_MEM_NB_LN_MRNMCTLN_FILECODE                    (0XF832)
#define PROC_RECOVERY_MEM_NB_LN_MRNLN_FILECODE                       (0XF833)
#define PROC_RECOVERY_MEM_NB_DA_MRNDA_FILECODE                       (0XF842)
#define PROC_RECOVERY_MEM_NB_DA_MRNMCTDA_FILECODE                    (0XF843)
#define PROC_RECOVERY_MEM_NB_NI_MRNNI_FILECODE                       (0XF845)
#define PROC_RECOVERY_MEM_NB_C32_MRNC32_FILECODE                     (0XF851)
#define PROC_RECOVERY_MEM_NB_C32_MRNMCTC32_FILECODE                  (0XF852)
#define PROC_RECOVERY_MEM_NB_C32_MRNPROTOC32_FILECODE                (0XF853)
#define PROC_RECOVERY_MEM_NB_ON_MRNDCTON_FILECODE                    (0xF861)
#define PROC_RECOVERY_MEM_NB_ON_MRNMCTON_FILECODE                    (0xF862)
#define PROC_RECOVERY_MEM_NB_ON_MRNON_FILECODE                       (0xF863)
#define PROC_RECOVERY_MEM_NB_PH_MRNPH_FILECODE                       (0xF871)
#define PROC_RECOVERY_MEM_NB_RB_MRNRB_FILECODE                       (0xF881)
#define PROC_RECOVERY_MEM_TECH_MRTTPOS_FILECODE                      (0XF8C1)
#define PROC_RECOVERY_MEM_TECH_MRTTSRC_FILECODE                      (0XF8C2)
#define PROC_RECOVERY_MEM_TECH_DDR3_MRT3_FILECODE                    (0XF8C3)
#define PROC_RECOVERY_MEM_TECH_DDR3_MRTRCI3_FILECODE                 (0XF8C4)
#define PROC_RECOVERY_MEM_TECH_DDR3_MRTSDI3_FILECODE                 (0XF8C5)
#define PROC_RECOVERY_MEM_TECH_DDR3_MRTSPD3_FILECODE                 (0XF8C6)
#define PROC_RECOVERY_MEM_TECH_DDR3_MRTTWL3_FILECODE                 (0XF8C7)
#define PROC_RECOVERY_MEM_NB_MRN_FILECODE                            (0XF8C8)
#define PROC_RECOVERY_MEM_NB_MRNDCT_FILECODE                         (0XF8C9)
#define PROC_RECOVERY_MEM_NB_MRNMCT_FILECODE                         (0XF8CA)
#define PROC_RECOVERY_MEM_NB_MRNTRAIN3_FILECODE                      (0XF8CB)
#define PROC_RECOVERY_MEM_TECH_MRTTHRC_FILECODE                      (0XF8CC)
#define PROC_RECOVERY_MEM_NB_OR_MRNDCTOR_FILECODE                    (0XF8CD)
#define PROC_RECOVERY_MEM_NB_OR_MRNOR_FILECODE                       (0XF8CE)
#define PROC_RECOVERY_MEM_NB_OR_MRNMCTOR_FILECODE                    (0XF8CF)
#define PROC_RECOVERY_MEM_NB_OR_MRNPROTOOR_FILECODE                  (0XF8D0)
#define PROC_RECOVERY_MEM_PS_MRP_FILECODE                            (0XF8E0)
#define PROC_RECOVERY_MEM_PS_MRPRTT_FILECODE                         (0XF8E1)
#define PROC_RECOVERY_MEM_PS_MRPODTPAT_FILECODE                      (0XF8E2)
#define PROC_RECOVERY_MEM_PS_MRPSAO_FILECODE                         (0XF8E3)
#define PROC_RECOVERY_MEM_PS_MRPMR0_FILECODE                         (0XF8E4)
#define PROC_RECOVERY_MEM_PS_MRPRC2IBT_FILECODE                      (0XF8E5)
#define PROC_RECOVERY_MEM_PS_MRPRC10OPSPD_FILECODE                   (0XF8E6)
#define PROC_RECOVERY_MEM_PS_MRPLRIBT_FILECODE                       (0XF8E7)
#define PROC_RECOVERY_MEM_PS_MRPLRNPR_FILECODE                       (0XF8E8)
#define PROC_RECOVERY_MEM_PS_MRPLRNLR_FILECODE                       (0XF8E9)
#define PROC_RECOVERY_MEM_PS_OR_MRPOR3_FILECODE                      (0XF8EA)
#define PROC_RECOVERY_MEM_PS_OR_AM3_MRPSORA3_FILECODE                (0XF8EB)
#define PROC_RECOVERY_MEM_PS_OR_AM3_MRPUORA3_FILECODE                (0XF8EC)
#define PROC_RECOVERY_MEM_PS_OR_C32_MRPUORC3_FILECODE                (0XF8ED)
#define PROC_RECOVERY_MEM_PS_OR_C32_MRPRORC3_FILECODE                (0XF8EE)
#define PROC_RECOVERY_MEM_PS_OR_C32_MRPLORC3_FILECODE                (0XF8EF)
#define PROC_RECOVERY_MEM_PS_OR_G34_MRPUORG3_FILECODE                (0XF8F0)
#define PROC_RECOVERY_MEM_PS_OR_G34_MRPRORG3_FILECODE                (0XF8F1)
#define PROC_RECOVERY_MEM_PS_OR_G34_MRPLORG3_FILECODE                (0XF8F2)

#endif // _FILECODE_H_
# 853 "src/vendorcode/amd/agesa/f14/Include/Filecode.h"
# 172 "src/vendorcode/amd/agesa/f14/Include/Ids.h" 2

/* Initialize IDS controls */
#ifndef IDSOPT_IDS_ENABLED
  #define IDSOPT_IDS_ENABLED        FALSE
#endif
# 177 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_CONTROL_ENABLED
  #define IDSOPT_CONTROL_ENABLED    FALSE
#endif
# 181 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_TRACING_ENABLED
  #define IDSOPT_TRACING_ENABLED    FALSE
#endif
# 185 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_TRACE_USER_OPTIONS
  #define IDSOPT_TRACE_USER_OPTIONS TRUE
#endif
# 189 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_PERF_ANALYSIS
  #define IDSOPT_PERF_ANALYSIS      FALSE
#endif
# 193 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_HEAP_CHECKING
  #define IDSOPT_HEAP_CHECKING           FALSE
#endif
# 197 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_ASSERT_ENABLED
  #define IDSOPT_ASSERT_ENABLED         FALSE
#endif
# 201 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_ERROR_TRAP_ENABLED
  #define IDSOPT_ERROR_TRAP_ENABLED   FALSE
#endif
# 205 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_CAR_CORRUPTION_CHECK_ENABLED
  #define IDSOPT_CAR_CORRUPTION_CHECK_ENABLED   FALSE
#endif
# 209 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_DEBUG_CODE_ENABLED
  #define IDSOPT_DEBUG_CODE_ENABLED   FALSE
#endif
# 213 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDSOPT_C_OPTIMIZATION_DISABLED
  #define IDSOPT_C_OPTIMIZATION_DISABLED   FALSE
#endif
# 217 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#if IDSOPT_IDS_ENABLED == FALSE
  #undef  IDSOPT_CONTROL_ENABLED
  #undef  IDSOPT_TRACING_ENABLED
  #undef  IDSOPT_PERF_ANALYSIS
  #undef  IDSOPT_HEAP_CHECKING
  #undef  IDSOPT_ASSERT_ENABLED
  #undef  IDSOPT_ERROR_TRAP_ENABLED
  #undef  IDSOPT_CAR_CORRUPTION_CHECK_ENABLED
  #undef  IDSOPT_DEBUG_CODE_ENABLED
  #undef  IDSOPT_TRACE_USER_OPTIONS

  #define IDSOPT_CONTROL_ENABLED    FALSE
  #define IDSOPT_TRACING_ENABLED    FALSE
  #define IDSOPT_PERF_ANALYSIS      FALSE
  #define IDSOPT_HEAP_CHECKING      FALSE
  #define IDSOPT_ASSERT_ENABLED     FALSE
  #define IDSOPT_ERROR_TRAP_ENABLED FALSE
  #define IDSOPT_CAR_CORRUPTION_CHECK_ENABLED FALSE
  #define IDSOPT_DEBUG_CODE_ENABLED FALSE
  #define IDSOPT_TRACE_USER_OPTIONS FALSE
#endif
# 239 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

/**
 *  Make a Progress Report to the User.
 *
 *  This Macro is always enabled. The default action is to write the TestPoint value
 *  to an I/O port. The I/O port is 8 bits in size and the default address is 0x80.
 *  IBVs can change AGESA's default port by defining IDS_DEBUG_PORT to desired port
 *  in OptionsIds.h in their build tip.
 *
 *  @param[in]      TestPoint       The value for display indicating progress
 *  @param[in,out]  StdHeader       Pointer of AMD_CONFIG_PARAMS
 *
 **/

#define AGESA_TESTPOINT(TestPoint, StdHeader)

#ifndef IDS_DEBUG_PORT
  #define IDS_DEBUG_PORT  0x80
#endif
# 258 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

/**
 * @def STOP_HERE
 *  (macro) - Causes program to halt. This is @b only for use during active debugging .
 *
 *  Causes the program to halt and display the file number of the source of the
 *  halt (displayed in decimal).
 *
 **/
#if IDSOPT_IDS_ENABLED == TRUE
  #ifdef STOP_CODE
    #undef STOP_CODE
  #endif
# 271 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define STOP_CODE (((UINT32)FILECODE)*0x10000 + \
                      ((__LINE__) % 10) + (((__LINE__ / 10) % 10)*0x10) + \
                      (((__LINE__ / 100) % 10)*0x100) + (((__LINE__ / 1000) % 10)*0x1000))
  #define STOP_HERE
#else
# 276 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define STOP_HERE
#endif
# 278 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

/**
 * @def ASSERT
 *  Test an assertion that the given statement is True.
 *
 *  The statement is evaluated to a boolean value. If the statement is True,
 *  then no action is taken (no error). If the statement is False, a error stop
 *  is generated to halt the program. Used for testing for fatal errors that
 *  must be resolved before production. This is used to do parameter checks,
 *  bounds checking, range checks and 'sanity' checks.
 *
 * @param[in]   conditional    Assert that evaluating this conditional results in TRUE.
 *
 **/
#ifndef ASSERT
  #if IDSOPT_ASSERT_ENABLED == TRUE
    #ifdef STOP_CODE
      #undef STOP_CODE
    #endif
# 297 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #define STOP_CODE (((UINT32)FILECODE)*0x10000 + \
                        ((__LINE__) % 10) + (((__LINE__ / 10) % 10)*0x10) + \
                        (((__LINE__ / 100) % 10)*0x100) + (((__LINE__ / 1000) % 10)*0x1000))

    #define ASSERT(conditional)
  #else
# 303 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #define ASSERT(conditional)
  #endif
# 305 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
#endif
# 306 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#if IDSOPT_CAR_CORRUPTION_CHECK_ENABLED == TRUE
  #undef  IDSOPT_ERROR_TRAP_ENABLED
  #define IDSOPT_ERROR_TRAP_ENABLED TRUE
  #define IDS_CAR_CORRUPTION_CHECK(StdHeader)
#else
# 312 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define IDS_CAR_CORRUPTION_CHECK(StdHeader)
#endif
# 314 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
/**
 * @def DEBUG_CODE
 * Make the code active when IDSOPT_DEBUG_CODE_ENABLED enable
 *
 */
#ifndef DEBUG_CODE
  #if IDSOPT_DEBUG_CODE_ENABLED == TRUE
    #define  DEBUG_CODE(Code)
  #else
# 323 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #define  DEBUG_CODE(Code)
  #endif
# 325 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
#endif
# 326 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

/**
 * @def IDS_ERROR_TRAP
 * Trap AGESA Error events with stop code display.
 *
 * Works similarly to use of "ASSERT (FALSE);"
 *
 */
#if IDSOPT_ERROR_TRAP_ENABLED == TRUE
  #ifdef STOP_CODE
    #undef STOP_CODE
  #endif
# 338 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define STOP_CODE (((UINT32)FILECODE)*0x10000 + \
                      ((__LINE__) % 10) + (((__LINE__ / 10) % 10)*0x10) + \
                      (((__LINE__ / 100) % 10)*0x100) + (((__LINE__ / 1000) % 10)*0x1000))

  #define IDS_ERROR_TRAP
#else
# 344 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define IDS_ERROR_TRAP
#endif
# 346 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

///give the extended Macro default value
#ifndef __IDS_EXTENDED__
  #define IDS_EXTENDED_HOOK(idsoption, dataptr, idsnvptr, stdheader) IDS_SUCCESS
  #define IDS_INITIAL_F10_PM_STEP
  #define IDS_INITIAL_F12_PM_STEP
  #define IDS_INITIAL_F14_PM_STEP
  #define IDS_INITIAL_F15_PM_STEP
  #define IDS_EXTENDED_GET_DATA_EARLY(data, StdHeader)
  #define IDS_EXTENDED_GET_DATA_LATE(data, StdHeader)
  #define IDS_EXTENDED_HEAP_SIZE 0
  #define IDS_EXT_INCLUDE_F10(file)
  #define IDS_EXT_INCLUDE_F12(file)
  #define IDS_EXT_INCLUDE_F14(file)
  #define IDS_EXT_INCLUDE_F15(file)
  #define IDS_EXT_INCLUDE(file)
#endif
# 363 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#ifndef IDS_NUM_NV_ITEM
  #define IDS_NUM_NV_ITEM (IDS_NUM_EXT_NV_ITEM)
#endif
# 367 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#if IDSOPT_CONTROL_ENABLED == TRUE
  #define IDS_OPTION_HOOK(IdsOption, DataPtr, StdHeader)

  #define IDS_OPTION_CALLOUT(CallOutId, DataPtr, StdHeader)
#else
# 373 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define IDS_OPTION_HOOK(IdsOption, DataPtr, StdHeader)

  #define IDS_OPTION_CALLOUT(CallOutId, DataPtr, StdHeader)
#endif
# 377 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

/**
 *  Macro to add a *skip* hook for IDS options
 *
 *  The default minimal action is to do nothing and there is no any code to increase.
 *  For debug environments, IDS dispatcher function will be called to perform
 *  the detailed action and to skip AGESA code if necessary.
 *
 * @param[in]       IdsOption       IDS Option ID for this hook point
 * @param[in, out]  DataPtr         Data Pointer to override
 * @param[in, out]  StdHeader       Pointer of AMD_CONFIG_PARAMS
 *
 *
 **/

#if IDSOPT_CONTROL_ENABLED == TRUE
  #define IDS_SKIP_HOOK(IdsOption, DataPtr, StdHeader)
#else
# 395 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define IDS_SKIP_HOOK(IdsOption, DataPtr, StdHeader)
#endif
# 397 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

/**
 *  Macro to add a heap manager routine
 *
 *  when memory is allocated the heap manager actually allocates two extra dwords of data,
 *  one dword buffer before the actual memory, and one dword afterwards.
 *  a complete heap walk and check to be performed at any time.
 *  it would ASSERT if the heap is corrupt
 *
 * @param[in]  StdHeader       Pointer of AMD_CONFIG_PARAMS
 *
 *
 **/

// Heap debug feature
#define SENTINEL_BEFORE_VALUE 0x64616548    // "Head"
#define SENTINEL_AFTER_VALUE  0x6C696154    // "Tail"
#if IDSOPT_IDS_ENABLED == TRUE
  #if IDSOPT_HEAP_CHECKING == TRUE
    #define SIZE_OF_SENTINEL  0
    #define NUM_OF_SENTINEL   0
    #define SET_SENTINEL_BEFORE(NodePtr, AlignTo16Byte)
    #define SET_SENTINEL_AFTER(NodePtr)
    #define Heap_Check(stdheader)
  #else
# 422 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #define SIZE_OF_SENTINEL  0
    #define NUM_OF_SENTINEL   0
    #define SET_SENTINEL_BEFORE(NodePtr, AlignTo16Byte)
    #define SET_SENTINEL_AFTER(NodePtr)
    #define Heap_Check(stdheader)
  #endif
# 428 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
#else
# 429 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define SIZE_OF_SENTINEL    0
  #define NUM_OF_SENTINEL     0
  #define SET_SENTINEL_BEFORE(NodePtr, AlignTo16Byte)
  #define SET_SENTINEL_AFTER(NodePtr)
  #define Heap_Check(stdheader)
#endif
# 435 "src/vendorcode/amd/agesa/f14/Include/Ids.h"


 //Note a is from 0 to 63
#define DEBUG_PRINT_SHIFT(a)   ((UINT64)1 << a)
//If you change the Bitmap definition below, please change the Hash in ParseFilter of hdtout2008.pl accordingly
//Memory Masks
#define MEM_SETREG                                  DEBUG_PRINT_SHIFT (0)
#define MEM_GETREG                                  DEBUG_PRINT_SHIFT (1)
#define MEM_FLOW                                    DEBUG_PRINT_SHIFT (2)
#define MEM_STATUS                                  DEBUG_PRINT_SHIFT (3)
#define MEMORY_TRACE_RSV1                           DEBUG_PRINT_SHIFT (4)
#define MEMORY_TRACE_RSV2                           DEBUG_PRINT_SHIFT (5)
#define MEMORY_TRACE_RSV3                           DEBUG_PRINT_SHIFT (6)
#define MEMORY_TRACE_RSV4                           DEBUG_PRINT_SHIFT (7)
#define MEMORY_TRACE_RSV5                           DEBUG_PRINT_SHIFT (8)
#define MEMORY_TRACE_RSV6                           DEBUG_PRINT_SHIFT (9)



//CPU Masks
#define CPU_TRACE                                   DEBUG_PRINT_SHIFT (10)
#define CPU_TRACE_RSV1                              DEBUG_PRINT_SHIFT (11)
#define CPU_TRACE_RSV2                              DEBUG_PRINT_SHIFT (12)
#define CPU_TRACE_RSV3                              DEBUG_PRINT_SHIFT (13)
#define CPU_TRACE_RSV4                              DEBUG_PRINT_SHIFT (14)
#define CPU_TRACE_RSV5                              DEBUG_PRINT_SHIFT (15)
#define CPU_TRACE_RSV6                              DEBUG_PRINT_SHIFT (16)
#define CPU_TRACE_RSV7                              DEBUG_PRINT_SHIFT (17)
#define CPU_TRACE_RSV8                              DEBUG_PRINT_SHIFT (18)
#define CPU_TRACE_RSV9                              DEBUG_PRINT_SHIFT (19)

//GNB Masks
#define GNB_TRACE                                   DEBUG_PRINT_SHIFT (20)
#define PCIE_MISC                                   DEBUG_PRINT_SHIFT (21)
#define PCIE_PORTREG_TRACE                          DEBUG_PRINT_SHIFT (22)
#define PCIE_HOSTREG_TRACE                          DEBUG_PRINT_SHIFT (23)
#define GNB_TRACE_RSV2                              DEBUG_PRINT_SHIFT (24)
#define NB_MISC                                     DEBUG_PRINT_SHIFT (25)
#define GNB_TRACE_RSV3                              DEBUG_PRINT_SHIFT (26)
#define GFX_MISC                                    DEBUG_PRINT_SHIFT (27)
#define NB_SMUREG_TRACE                             DEBUG_PRINT_SHIFT (28)
#define GNB_TRACE_RSV1                              DEBUG_PRINT_SHIFT (29)

//HT Masks
#define HT_TRACE                                    DEBUG_PRINT_SHIFT (30)
#define HT_TRACE_RSV1                               DEBUG_PRINT_SHIFT (31)
#define HT_TRACE_RSV2                               DEBUG_PRINT_SHIFT (32)
#define HT_TRACE_RSV3                               DEBUG_PRINT_SHIFT (33)
#define HT_TRACE_RSV4                               DEBUG_PRINT_SHIFT (34)
#define HT_TRACE_RSV5                               DEBUG_PRINT_SHIFT (35)
#define HT_TRACE_RSV6                               DEBUG_PRINT_SHIFT (36)
#define HT_TRACE_RSV7                               DEBUG_PRINT_SHIFT (37)
#define HT_TRACE_RSV8                               DEBUG_PRINT_SHIFT (38)
#define HT_TRACE_RSV9                               DEBUG_PRINT_SHIFT (39)

//FCH Masks
#define FCH_TRACE                                    DEBUG_PRINT_SHIFT (40)
#define FCH_TRACE_RSV1                               DEBUG_PRINT_SHIFT (41)
#define FCH_TRACE_RSV2                               DEBUG_PRINT_SHIFT (42)
#define FCH_TRACE_RSV3                               DEBUG_PRINT_SHIFT (43)
#define FCH_TRACE_RSV4                               DEBUG_PRINT_SHIFT (44)
#define FCH_TRACE_RSV5                               DEBUG_PRINT_SHIFT (45)
#define FCH_TRACE_RSV6                               DEBUG_PRINT_SHIFT (46)
#define FCH_TRACE_RSV7                               DEBUG_PRINT_SHIFT (47)
#define FCH_TRACE_RSV8                               DEBUG_PRINT_SHIFT (48)
#define FCH_TRACE_RSV9                               DEBUG_PRINT_SHIFT (49)

//Other Masks
#define MAIN_FLOW                                    DEBUG_PRINT_SHIFT (50)
#define EVENT_LOG                                    DEBUG_PRINT_SHIFT (51)
#define PERFORMANCE_ANALYSE                          DEBUG_PRINT_SHIFT (52)

//Ids Masks
#define IDS_TRACE                                    DEBUG_PRINT_SHIFT (53)
#define IDS_REG                                      DEBUG_PRINT_SHIFT (54)
#define IDS_TRACE_RSV2                               DEBUG_PRINT_SHIFT (55)
#define IDS_TRACE_RSV3                               DEBUG_PRINT_SHIFT (56)

//S3
#define S3_TRACE                                     DEBUG_PRINT_SHIFT (57)


//Reserved
#define TRACE_RSV1                                   DEBUG_PRINT_SHIFT (58)
#define TRACE_RSV2                                   DEBUG_PRINT_SHIFT (59)
#define TRACE_RSV3                                   DEBUG_PRINT_SHIFT (60)
#define TRACE_RSV4                                   DEBUG_PRINT_SHIFT (61)
#define TRACE_RSV5                                   DEBUG_PRINT_SHIFT (62)
#define TRACE_RSV6                                   DEBUG_PRINT_SHIFT (63)

#define GNB_TRACE_DEFAULT   0

#define GNB_TRACE_REG       0

#define GNB_TRACE_ALL       0

#define CPU_TRACE_ALL       0

#define MEMORY_TRACE_ALL    0

#define HT_TRACE_ALL        0

#define FCH_TRACE_ALL       0

#define IDS_TRACE_ALL       0

#define OTHER_TRACE_ALL     0

#define TRACE_MASK_ALL (0ull)
#ifndef IDS_DEBUG_PRINT_MASK
  #define IDS_DEBUG_PRINT_MASK 0
#endif
# 547 "src/vendorcode/amd/agesa/f14/Include/Ids.h"


/**
 *  Macro to add HDT OUT
 *
 *  The default minimal action is to do nothing and there is no any code to increase.
 *  For debug environments, the debug information can be displayed in HDT or other
 *  devices.
 *
 **/
#if IDSOPT_IDS_ENABLED == TRUE
  #if IDSOPT_TRACING_ENABLED == TRUE
    #define IDS_HDT_CONSOLE_INIT(x)
    #define IDS_HDT_CONSOLE_EXIT(x)
    #define IDS_HDT_CONSOLE_S3_EXIT(x)
    #define IDS_HDT_CONSOLE_S3_AP_EXIT(x)

    #if IDSOPT_C_OPTIMIZATION_DISABLED == TRUE
      #ifdef __GNUC__
        #define IDS_HDT_CONSOLE(f, s, ...)
      #else
# 568 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
        #define IDS_HDT_CONSOLE(f, s, ...)
      #endif
# 570 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #else
# 571 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
      #ifndef __GNUC__	
        #pragma warning(disable: 4127)
        #define IDS_HDT_CONSOLE(f, s, ...)
	  #else
# 575 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
		#define IDS_HDT_CONSOLE(f, s, ...)        printk (BIOS_DEBUG, s, ##__VA_ARGS__);
      #endif                                            	
# 577 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #endif
# 578 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

    #define IDS_HDT_CONSOLE_FLUSH_BUFFER(x)
    #define IDS_HDT_CONSOLE_ASSERT(x)
    #define IDS_FUNCLIST_ADDR                   NULL
    #define IDS_FUNCLIST_EXTERN()
    #define IDS_TIMEOUT_CTL(t)
    #define IDS_HDT_CONSOLE_DEBUG_CODE(Code)
    #define CONSOLE(s, ...)
  #else
# 587 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
    #define IDS_HDT_CONSOLE_INIT(x)
    #define IDS_HDT_CONSOLE_EXIT(x)
    #define IDS_HDT_CONSOLE_S3_EXIT(x)
    #define IDS_HDT_CONSOLE_S3_AP_EXIT(x)
    #define IDS_HDT_CONSOLE(f, s, ...)
    #define IDS_HDT_CONSOLE_FLUSH_BUFFER(x)
    #define IDS_HDT_CONSOLE_ASSERT(x)
    #define IDS_FUNCLIST_ADDR                 NULL
    #define IDS_FUNCLIST_EXTERN()
    #define IDS_TIMEOUT_CTL(t)
    #define IDS_HDT_CONSOLE_DEBUG_CODE(Code)
    #define CONSOLE(s, ...)
  #endif
# 600 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
#else
# 601 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define IDS_HDT_CONSOLE_INIT(x)
  #define IDS_HDT_CONSOLE_EXIT(x)
  #define IDS_HDT_CONSOLE_S3_EXIT(x)
  #define IDS_HDT_CONSOLE_S3_AP_EXIT(x)
  #define IDS_HDT_CONSOLE(f, s, ...)
  #define IDS_HDT_CONSOLE_FLUSH_BUFFER(x)
  #define IDS_HDT_CONSOLE_ASSERT(x)
  #define IDS_FUNCLIST_ADDR                   NULL
  #define IDS_FUNCLIST_EXTERN()
  #define IDS_TIMEOUT_CTL(t)
  #define IDS_HDT_CONSOLE_DEBUG_CODE(Code)
  #define CONSOLE(s, ...)
#endif
# 614 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

#define IDS_TRACE_SHOW_BLD_OPT_CFG  IDSOPT_TRACE_USER_OPTIONS

#if IDSOPT_PERF_ANALYSIS == TRUE
  #define IDS_PERF_TIMESTAMP(StdHeader, TestPoint)
  #define IDS_PERF_ANALYSE(StdHeader)
  #define IDS_PERF_TIME_MEASURE(StdHeader)
#else
# 622 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
  #define IDS_PERF_TIMESTAMP(StdHeader, TestPoint)
  #define IDS_PERF_ANALYSE(StdHeader)
  #define IDS_PERF_TIME_MEASURE(StdHeader)
#endif
# 626 "src/vendorcode/amd/agesa/f14/Include/Ids.h"

///For IDS feat use
#define IDS_FAMILY_ALL  0xFFFFFFFFFFFFFFFFull
#define IDS_BSP_ONLY    TRUE
#define IDS_ALL_CORES   FALSE

#define IDS_LATE_RUN_AP_TASK_ID     PROC_IDS_CONTROL_IDSLIB_FILECODE

#define IDS_CALLOUT_INIT      0x00       ///< The function data of IDS callout function of initialization.

#define IDS_CALLOUT_GNB_PPFUSE_OVERRIDE      0x00       ///< The function data of IDS callout function of GNB pp fuse table.
#define IDS_CALLOUT_GNB_INTEGRATED_TABLE_CONFIG      0x00       ///< The function data of IDS callout function of GNB integrated table.
#define IDS_CALLOUT_GNB_NB_POWERGATE_CONFIG      0x00       ///< The function data of IDS callout function of GNB NB power gate config.
#define IDS_CALLOUT_GNB_PCIE_POWERGATE_CONFIG      0x00       ///< The function data of IDS callout function of GNB PCIE power gateconfig.
#define IDS_CALLOUT_GNB_PCIE_PLATFORM_CONFIG      0x00       ///< The function data of IDS callout function of GNB pcie platform config.
#define IDS_CALLOUT_GNB_PCIE_PHY_CONFIG           0x00       ///< The function data of IDS callout function of GNB pcie PHY config.
#define IDS_CALLOUT_GNB_GMM_REGISTER_OVERRIDE           0x00       ///< The function data of IDS callout function of GNB GMM register override

/// Function entry for HDT script to call
typedef struct _SCRIPT_FUNCTION {
  UINT32  FuncAddr;       ///< Function address in ROM
  CHAR8   FuncName[40];   ///< Function name
} SCRIPT_FUNCTION;

/// Data Structure for Mem ECC parameter override
typedef struct {
  IN BOOLEAN CfgEccRedirection;                   ///< ECC Redirection
  IN UINT16  CfgScrubDramRate;                    ///< Scrub Dram Rate
  IN UINT16  CfgScrubL2Rate;                      ///< Scrub L2Rate
  IN UINT16  CfgScrubL3Rate;                      ///< Scrub L3Rate
  IN UINT16  CfgScrubIcRate;                      ///< Scrub Ic Rate
  IN UINT16  CfgScrubDcRate;                      ///< Scrub Dc Rate
  IN BOOLEAN CfgEccSyncFlood;                     ///< ECC Sync Flood
} ECC_OVERRIDE_STRUCT;




/**
 *  AGESA Test Points
 *
 *  These are the values displayed to the user to indicate progress through boot.
 *  These can be used in a debug environment to stop the debugger at a specific
 *  test point:
 *  For SimNow!, this command
 *      bi 81 w vb 49
 *  will stop the debugger on one of the TracePoints (49 is the TP value in this example).
 *
 */
typedef enum {
  StartProcessorTestPoints,           ///< 00 Entry used for range testing for @b Processor related TPs

  // Memory test points
  TpProcMemBeforeMemDataInit,         ///< 01 .. Memory structure initialization (Public interface)
  TpProcMemBeforeSpdProcessing,       ///< 02 .. SPD Data processing  (Public interface)
  TpProcMemAmdMemAuto,                ///< 03 .. Memory configuration  (Public interface)
  TpProcMemDramInit,                  ///< 04 .. DRAM initialization
  TpProcMemSPDChecking,               ///< 05 ..
  TpProcMemModeChecking,              ///< 06 ..
  TpProcMemSpeedTclConfig,            ///< 07 .. Speed and TCL configuration
  TpProcMemSpdTiming,                 ///< 08 ..
  TpProcMemDramMapping,               ///< 09 ..
  TpProcMemPlatformSpecificConfig,    ///< 0A ..
  TPProcMemPhyCompensation,           ///< 0B ..
  TpProcMemStartDcts,                 ///< 0C ..
  TpProcMemBeforeDramInit,            ///< 0D .. (Public interface)
  TpProcMemPhyFenceTraining,          ///< 0E ..
  TpProcMemSynchronizeDcts,           ///< 0F ..
  TpProcMemSystemMemoryMapping,       ///< 10 ..
  TpProcMemMtrrConfiguration,         ///< 11 ..
  TpProcMemDramTraining,              ///< 12 ..
  TpProcMemBeforeAnyTraining,         ///< 13 .. (Public interface)
  TpProcMemWriteLevelizationTraining, ///< 14 ..
  TpProcMemWlFirstPass,               ///< 15 .. Below 800Mhz first pass start
  TpProcMemWlSecondPass,              ///< 16 .. Above 800Mhz second pass start
  TpProcMemWlDimmConfig,              ///< 17 .. Target DIMM configured
  TpProcMemWlPrepDimms,               ///< 18 ..  Prepare DIMMS for WL
  TpProcMemWlConfigDimms,             ///< 19 ..  Configure DIMMS for WL
  TpProcMemReceiverEnableTraining,    ///< 1A ..
  TpProcMemRcvrStartSweep,            ///< 1B .. Start sweep loop
  TpProcMemRcvrSetDelay,              ///< 1C .. Set receiver Delay
  TpProcMemRcvrWritePattern,          ///< 1D .. Write test pattern
  TpProcMemRcvrReadPattern,           ///< 1E .. Read test pattern
  TpProcMemRcvrTestPattern,           ///< 1F .. Compare test pattern
  TpProcMemRcvrCalcLatency,           ///< 20 .. Calculate MaxRdLatency per channel
  TpProcMemReceiveDqsTraining,        ///< 21 ..
  TpProcMemRcvDqsSetDelay,            ///< 22 .. Set Write Data delay
  TpProcMemRcvDqsWritePattern,        ///< 23 .. Write test pattern
  TpProcMemRcvDqsStartSweep,          ///< 24 .. Start read sweep
  TpProcMemRcvDqsSetRcvDelay,         ///< 25 .. Set Receive DQS delay
  TpProcMemRcvDqsReadPattern,         ///< 26 .. Read Test pattern
  TpProcMemRcvDqsTstPattern,          ///< 27 .. Compare Test pattern
  TpProcMemRcvDqsResults,             ///< 28 .. Update results
  TpProcMemRcvDqsFindWindow,          ///< 29 .. Start Find passing window
  TpProcMemTransmitDqsTraining,       ///< 2A ..
  TpProcMemTxDqStartSweep,            ///< 2B .. Start write sweep
  TpProcMemTxDqSetDelay,              ///< 2C .. Set Transmit DQ delay
  TpProcMemTxDqWritePattern,          ///< 2D .. Write test pattern
  TpProcMemTxDqReadPattern,           ///< 2E .. Read Test pattern
  TpProcMemTxDqTestPattern,           ///< 2F .. Compare Test pattern
  TpProcMemTxDqResults,               ///< 30 .. Update results
  TpProcMemTxDqFindWindow,            ///< 31 .. Start Find passing window
  TpProcMemMaxRdLatencyTraining,      ///< 32 ..
  TpProcMemMaxRdLatStartSweep,        ///< 33 .. Start sweep
  TpProcMemMaxRdLatSetDelay,          ///< 34 .. Set delay
  TpProcMemMaxRdLatWritePattern,      ///< 35 .. Write test pattern
  TpProcMemMaxRdLatReadPattern,       ///< 36 .. Read Test pattern
  TpProcMemMaxRdLatTestPattern,       ///< 37 .. Compare Test pattern
  TpProcMemOnlineSpareInit,           ///< 38 .. Online Spare init
  TpProcMemBankInterleaveInit,        ///< 39 .. Bank Interleave Init
  TpProcMemNodeInterleaveInit,        ///< 3A .. Node Interleave Init
  TpProcMemChannelInterleaveInit,     ///< 3B .. Channel Interleave Init
  TpProcMemEccInitialization,         ///< 3C .. ECC initialization
  TpProcMemPlatformSpecificInit,      ///< 3D .. Platform Specific Init
  TpProcMemBeforeAgesaReadSpd,        ///< 3E .. Before callout for "AgesaReadSpd"
  TpProcMemAfterAgesaReadSpd,         ///< 3F .. After callout for "AgesaReadSpd"
  TpProcMemBeforeAgesaHookBeforeDramInit,     ///< 40 .. Before optional callout "AgesaHookBeforeDramInit"
  TpProcMemAfterAgesaHookBeforeDramInit,      ///< 41 .. After optional callout "AgesaHookBeforeDramInit"
  TpProcMemBeforeAgesaHookBeforeDQSTraining, ///< 42 .. Before optional callout "AgesaHookBeforeDQSTraining"
  TpProcMemAfterAgesaHookBeforeDQSTraining,  ///< 43 .. After optional callout "AgesaHookBeforeDQSTraining"
  TpProcMemBeforeAgesaHookBeforeExitSelfRef,     ///< 44 .. Before optional callout "AgesaHookBeforeDramInit"
  TpProcMemAfterAgesaHookBeforeExitSelfRef,      ///< 45 .. After optional callout "AgesaHookBeforeDramInit"
  TpProcMemAfterMemDataInit,          ///< 46 .. After MemDataInit
  TpProcMemInitializeMCT,             ///< 47 .. Before InitializeMCT
  TpProcMemLvDdr3,                    ///< 48 .. Before LV DDR3
  TpProcMemInitMCT,                   ///< 49 .. Before InitMCT
  TpProcMemOtherTiming,               ///< 4A.. Before OtherTiming
  TpProcMemUMAMemTyping,              ///< 4B .. Before UMAMemTyping
  TpProcMemSetDqsEccTmgs,             ///< 4C .. Before SetDqsEccTmgs
  TpProcMemMemClr,                    ///< 4D .. Before MemClr
  TpProcMemOnDimmThermal,             ///< 4E .. Before On DIMM Thermal
  TpProcMemDmi,                       ///< 4F .. Before DMI
  TpProcMemEnd,                       ///< 50 .. End of memory code

  // CPU test points
  TpProcCpuEntryDmi,                  ///< 51 .. Entry point CreateDmiRecords
  TpProcCpuEntryPstate,               ///< 52 .. Entry point GenerateSsdt
  TpProcCpuEntryPstateLeveling,       ///< 53 .. Entry point PStateLeveling
  TpProcCpuEntryPstateGather,         ///< 54 .. Entry point PStateGatherData
  TpProcCpuEntryWhea,                 ///< 55 .. Entry point CreateAcpiWhea
  TpProcCpuEntrySrat,                 ///< 56 .. Entry point CreateAcpiSrat
  TpProcCpuEntrySlit,                 ///< 57 .. Entry point CreateAcpiSlit
  TpProcCpuProcessRegisterTables,     ///< 58 .. Register table processing
  TpProcCpuSetBrandID,                ///< 59 .. Set brand ID
  TpProcCpuLocalApicInit,             ///< 5A .. Initialize local APIC
  TpProcCpuLoadUcode,                 ///< 5B .. Load microcode patch
  TpProcCpuBeforePMFeatureInit,       ///< 5C .. BeforePM feature dispatch point
  TpProcCpuPowerMgmtInit,             ///< 5D .. Power Management table processing
  TpProcCpuEarlyFeatureInit,          ///< 5E .. Early feature dispatch point
  TpProcCpuCoreLeveling,              ///< 5F .. Core Leveling
  TpProcCpuApMtrrSync,                ///< 60 .. AP MTRR sync up
  TpProcCpuPostFeatureInit,           ///< 61 .. POST feature dispatch point
  TpProcCpuFeatureLeveling,           ///< 62 .. CPU Feature Leveling
  TpProcCpuBeforeAllocateWheaBuffer,  ///< 63 .. Before the WHEA init code calls out to allocate a buffer
  TpProcCpuAfterAllocateWheaBuffer,   ///< 64 .. After the WHEA init code calls out to allocate a buffer
  TpProcCpuBeforeAllocateSratBuffer,  ///< 65 .. Before the SRAT init code calls out to allocate a buffer
  TpProcCpuAfterAllocateSratBuffer,   ///< 66 .. After the SRAT init code calls out to allocate a buffer
  TpProcCpuBeforeLocateSsdtBuffer,    ///< 67 .. Before the P-state init code calls out to locate a buffer
  TpProcCpuAfterLocateSsdtBuffer,     ///< 68 .. After the P-state init code calls out to locate a buffer
  TpProcCpuBeforeAllocateSsdtBuffer,  ///< 69 .. Before the P-state init code calls out to allocate a buffer
  TpProcCpuAfterAllocateSsdtBuffer,   ///< 6A .. After the P-state init code calls out to allocate a buffer

  // HT test points
  TpProcHtEntry = 0x71,               ///< 71 .. Coherent Discovery begin (Public interface)
  TpProcHtTopology,                   ///< 72 .. Topology match, routing, begin
  TpProcHtManualNc,                   ///< 73 .. Manual Non-coherent Init begin
  TpProcHtAutoNc,                     ///< 74 .. Automatic Non-coherent init begin
  TpProcHtOptGather,                  ///< 75 .. Optimization: Gather begin
  TpProcHtOptRegang,                  ///< 76 .. Optimization: Regang begin
  TpProcHtOptLinks,                   ///< 77 .. Optimization: Link Begin
  TpProcHtOptSubLinks,                ///< 78 .. Optimization: Sublinks begin
  TpProcHtOptFinish,                  ///< 79 .. Optimization: Set begin
  TpProcHtTrafficDist,                ///< 7A .. Traffic Distribution begin
  TpProcHtTuning,                     ///< 7B .. Misc Tuning Begin
  TpProcHtDone,                       ///< 7C .. HT Init complete
  TpProcHtApMapEntry,                 ///< 7D .. AP HT: Init Maps begin
  TpProcHtApMapDone,                  ///< 7E .. AP HT: Complete

  StartNbTestPoints = 0x90,           ///< 90 Entry used for range testing for @b NorthBridge related TPs
  TpNbxxx,                            ///< 91 .
  EndNbTestPoints,                    ///< 92 End of TP range for NB

  StartSbTestPoints = 0xB0,           ///< B0 Entry used for range testing for @b SouthBridge related TPs
  TpSbxxx,                            ///< B1 .
  EndSbTestPoints,                    ///< B2 End of TP range for SB

  // Interface test points
  TpIfAmdInitResetEntry = 0xC0,       ///< C0 .. Entry to AmdInitReset
  TpIfAmdInitResetExit,               ///< C1 .. Exiting from AmdInitReset
  TpIfAmdInitRecoveryEntry,           ///< C2 .. Entry to AmdInitRecovery
  TpIfAmdInitRecoveryExit,            ///< C3 .. Exiting from AmdInitRecovery
  TpIfAmdInitEarlyEntry,              ///< C4 .. Entry to AmdInitEarly
  TpIfAmdInitEarlyExit,               ///< C5 .. Exiting from AmdInitEarly
  TpIfAmdInitPostEntry,               ///< C6 .. Entry to AmdInitPost
  TpIfAmdInitPostExit,                ///< C7 .. Exiting from AmdInitPost
  TpIfAmdInitEnvEntry,                ///< C8 .. Entry to AmdInitEnv
  TpIfAmdInitEnvExit,                 ///< C9 .. Exiting from AmdInitEnv
  TpIfAmdInitMidEntry,                ///< CA .. Entry to AmdInitMid
  TpIfAmdInitMidExit,                 ///< CB .. Exiting from AmdInitMid
  TpIfAmdInitLateEntry,               ///< CC .. Entry to AmdInitLate
  TpIfAmdInitLateExit,                ///< CD .. Exiting from AmdInitLate
  TpIfAmdS3SaveEntry,                 ///< CE .. Entry to AmdS3Save
  TpIfAmdS3SaveExit,                  ///< CF .. Exiting from AmdS3Save
  TpIfAmdInitResumeEntry,             ///< D0 .. Entry to AmdInitResume
  TpIfAmdInitResumeExit,              ///< D1 .. Exiting from AmdInitResume
  TpIfAmdS3LateRestoreEntry,          ///< D2 .. Entry to AmdS3LateRestore
  TpIfAmdS3LateRestoreExit,           ///< D3 .. Exiting from AmdS3LateRestore
  TpIfAmdLateRunApTaskEntry,          ///< D4 .. Entry to AmdS3LateRestore
  TpIfAmdLateRunApTaskExit,           ///< D5 .. Exiting from AmdS3LateRestore
  TpIfAmdReadEventLogEntry,           ///< D6 .. Entry to AmdReadEventLog
  TpIfAmdReadEventLogExit,            ///< D7 .. Exiting from AmdReadEventLog
  TpIfAmdGetApicIdEntry,              ///< D8 .. Entry to AmdGetApicId
  TpIfAmdGetApicIdExit,               ///< D9 .. Exiting from AmdGetApicId
  TpIfAmdGetPciAddressEntry,          ///< DA .. Entry to AmdGetPciAddress
  TpIfAmdGetPciAddressExit,           ///< DB .. Exiting from AmdGetPciAddress
  TpIfAmdIdentifyCoreEntry,           ///< DC .. Entry to AmdIdentifyCore
  TpIfAmdIdentifyCoreExit,            ///< DD .. Exiting from AmdIdentifyCore
  TpIfBeforeRunApFromIds,             ///< DE .. After IDS calls out to run code on an AP
  TpIfAfterRunApFromIds,              ///< DF .. After IDS calls out to run code on an AP
  TpIfBeforeGetIdsData,               ///< E0 .. Before IDS calls out to get IDS data
  TpIfAfterGetIdsData,                ///< E1 .. After IDS calls out to get IDS data
  TpIfBeforeAllocateHeapBuffer,       ///< E2 .. Before the heap manager calls out to allocate a buffer
  TpIfAfterAllocateHeapBuffer,        ///< E3 .. After the heap manager calls out to allocate a buffer
  TpIfBeforeDeallocateHeapBuffer,     ///< E4 .. Before the heap manager calls out to deallocate a buffer
  TpIfAfterDeallocateHeapBuffer,      ///< E5 .. After the heap manager calls out to deallocate a buffer
  TpIfBeforeLocateHeapBuffer,         ///< E6 .. Before the heap manager calls out to locate a buffer
  TpIfAfterLocateHeapBuffer,          ///< E7 .. After the heap manager calls out to locate a buffer
  TpIfBeforeRunApFromAllAps,          ///< E8 .. Before the BSP calls out to run code on an AP
  TpIfAfterRunApFromAllAps,           ///< E9 .. After the BSP calls out to run code on an AP
  TpIfBeforeRunApFromAllCore0s,       ///< EA .. Before the BSP calls out to run code on an AP
  TpIfAfterRunApFromAllCore0s,        ///< EB .. After the BSP calls out to run code on an AP
  TpIfBeforeAllocateS3SaveBuffer,     ///< EC .. Before the S3 save code calls out to allocate a buffer
  TpIfAfterAllocateS3SaveBuffer,      ///< ED .. After the S3 save code calls out to allocate a buffer
  TpIfBeforeAllocateMemoryS3SaveBuffer,  ///< EE .. Before the memory S3 save code calls out to allocate a buffer
  TpIfAfterAllocateMemoryS3SaveBuffer,   ///< EF .. After the memory S3 save code calls out to allocate a buffer
  TpIfBeforeLocateS3PciBuffer,        ///< F0 .. Before the memory code calls out to locate a buffer
  TpIfAfterLocateS3PciBuffer,         ///< F1 .. After the memory code calls out to locate a buffer
  TpIfBeforeLocateS3CPciBuffer,       ///< F2 .. Before the memory code calls out to locate a buffer
  TpIfAfterLocateS3CPciBuffer,        ///< F3 .. After the memory code calls out to locate a buffer
  TpIfBeforeLocateS3MsrBuffer,        ///< F4 .. Before the memory code calls out to locate a buffer
  TpIfAfterLocateS3MsrBuffer,         ///< F5 .. After the memory code calls out to locate a buffer
  TpIfBeforeLocateS3CMsrBuffer,       ///< F6 .. Before the memory code calls out to locate a buffer
  TpIfAfterLocateS3CMsrBuffer,        ///< F7 .. After the memory code calls out to locate a buffer
  TpPerfUnit,                              ///< F8 .. The Unit of performance measure.
  EndAgesaTps = 0xFF,                 ///< Last defined AGESA TP
} AGESA_TP;

///Ids Feat description
typedef enum {
  IDS_FEAT_UCODE_UPDATE = 0x0000,   ///< Feat for Ucode Update
  IDS_FEAT_TARGET_PSTATE,           ///< Feat for Target Pstate
  IDS_FEAT_POSTPSTATE,              ///< Feat for Post Pstate
  IDS_FEAT_ECC_CTRL,                ///< Feat for Ecc Control
  IDS_FEAT_ECC_SYMBOL_SIZE,         ///< Feat for Ecc symbol size
  IDS_FEAT_DCT_ALLMEMCLK,           ///< Feat for all memory clock
  IDS_FEAT_DCT_GANGMODE,            ///< Feat for Dct gang mode
  IDS_FEAT_DCT_BURSTLENGTH,         ///< Feat for dct burst length
  IDS_FEAT_DCT_POWERDOWN,           ///< Feat for dct power down
  IDS_FEAT_DCT_DLLSHUTDOWN,         ///< Feat for dct dll shut down
  IDS_FEAT_PROBE_FILTER,            ///< Feat for probe filter
  IDS_FEAT_HDTOUT,                  ///< Feat for hdt out
  IDS_FEAT_HT_SETTING,              ///< Feat for Ht setting
  IDS_FEAT_GNB_PLATFORMCFG,                 ///< Feat for override GNB platform config
  IDS_FEAT_CPB_CTRL,             ///< Feat for Config the Core peformance boost feature
  IDS_FEAT_HTC_CTRL,            ///< Feat for Hardware Thermal Control
  IDS_FEAT_MEMORY_MAPPING,              ///< Feat for Memory Mapping
  IDS_FEAT_POWER_POLICY,              ///< Feat for Power Policy
  IDS_FEAT_END = 0xFF                      ///< End of Common feat
} IDS_FEAT;

typedef IDS_STATUS IDS_COMMON_FUNC (
  IN OUT   VOID *DataPtr,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader,
  IN       IDS_NV_ITEM *IdsNvPtr
  );

typedef IDS_COMMON_FUNC *PIDS_COMMON_FUNC;

/// Data Structure of IDS Feature block
typedef  struct _IDS_FEAT_STRUCT {
  IDS_FEAT  IdsFeat;      ///< Ids Feat ID
  BOOLEAN IsBsp;          ///< swith for Bsp check
  AGESA_IDS_OPTION IdsOption;   ///< IDS option
  UINT64 CpuFamily;      ///<
  PIDS_COMMON_FUNC  pf_idsoption;     ///<pointer to function
} IDS_FEAT_STRUCT;


/// Data Structure of IDS option
typedef  struct _IDS_OPTION_STRUCT {
  AGESA_IDS_OPTION idsoption;   ///< IDS option
  PIDS_COMMON_FUNC  pf_idsoption;     ///<pointer to function
} IDS_OPTION_STRUCT;

/// Data Structure of IDS option table
typedef struct _IDS_OPTION_STRUCT_TBL {
  UINT8 version;      ///<Version of IDS option table
  UINT16 size;        ///<Size of IDS option table
  CONST IDS_OPTION_STRUCT  *pIdsOptionStruct; ///<pointer to array of  structure
} IDS_OPTION_STRUCT_TBL;

#endif // _IDS_H_
# 928 "src/vendorcode/amd/agesa/f14/Include/Ids.h"
# 55 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c" 2
#if 0 /* expanded by -frewrite-includes */
#include "cpuRegisters.h"
#endif /* expanded by -frewrite-includes */
# 55 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
# 1 "src/vendorcode/amd/agesa/f14/Proc/CPU/cpuRegisters.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * AMD CPU Register Table Related Functions
 *
 * Contains the definition of the CPU CPUID MSRs and PCI registers with BKDG recommended values
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  CPU
 * @e \$Revision: 48588 $   @e \$Date: 2011-03-10 08:57:36 -0700 (Thu, 10 Mar 2011) $
 *
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */

#ifndef _CPU_REGISTERS_H_
#define _CPU_REGISTERS_H_

#if 0 /* expanded by -frewrite-includes */
#include "cpuFamRegisters.h"
#endif /* expanded by -frewrite-includes */
# 50 "src/vendorcode/amd/agesa/f14/Proc/CPU/cpuRegisters.h"
# 1 "src/vendorcode/amd/agesa/f14/Proc/CPU/Family/cpuFamRegisters.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * AMD CPU Register Table Related Functions
 *
 * Contains the definition of the CPU CPUID MSRs and PCI registers with BKDG recommended values
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  CPU
 * @e \$Revision: 36421 $   @e \$Date: 2010-08-18 22:46:48 +0800 (Wed, 18 Aug 2010) $
 *
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */

#ifndef _CPU_FAM_REGISTERS_H_
#define _CPU_FAM_REGISTERS_H_

/*
 *--------------------------------------------------------------
 *
 *                      M O D U L E S    U S E D
 *
 *---------------------------------------------------------------
 */

/*
 *--------------------------------------------------------------
 *
 *                      D E F I N I T I O N S  /  M A C R O S
 *
 *---------------------------------------------------------------
 */

// This define should be equal to the total number of families
// in the cpuFamily enum.
#define MAX_CPU_FAMILIES    64
#define MAX_CPU_REVISIONS   63    // Max Cpu Revisions Per Family

// CPU_LOGICAL_ID.Family equates
// Family 10h equates
#define AMD_FAMILY_10_RB  0x0000000000000001ull
#define AMD_FAMILY_10_BL  0x0000000000000002ull
#define AMD_FAMILY_10_DA  0x0000000000000004ull
#define AMD_FAMILY_10_HY  0x0000000000000008ull
#define AMD_FAMILY_10_PH  0x0000000000000010ull
#define AMD_FAMILY_10_C32 AMD_FAMILY_10_HY

#define AMD_FAMILY_10 (AMD_FAMILY_10_RB | AMD_FAMILY_10_BL | AMD_FAMILY_10_DA | AMD_FAMILY_10_HY | AMD_FAMILY_10_PH)
#define AMD_FAMILY_GH    (AMD_FAMILY_10)

// Family 12h equates
#define AMD_FAMILY_12_LN  0x0000000000000020ull
#define AMD_FAMILY_12   (AMD_FAMILY_12_LN)
#define AMD_FAMILY_LN   (AMD_FAMILY_12_LN)

// Family 14h equates
#define AMD_FAMILY_14_ON  0x0000000000000040ull
#define AMD_FAMILY_14   (AMD_FAMILY_14_ON)
#define AMD_FAMILY_ON   (AMD_FAMILY_14_ON)

// Family 15h equates
#define AMD_FAMILY_15_OR  0x0000000000000100ull
#define AMD_FAMILY_15     (AMD_FAMILY_15_OR)
#define AMD_FAMILY_OR     (AMD_FAMILY_15_OR)

// Family 16h equates
#define AMD_FAMILY_16     0x0000000000000800ull
#define AMD_FAMILY_WF     (AMD_FAMILY_16)

// Family Unknown
#define AMD_FAMILY_UNKNOWN 0x8000000000000000ull

// Family Group equates
#define AMD_FAMILY_GE_12   (AMD_FAMILY_12 | AMD_FAMILY_14 | AMD_FAMILY_15 | AMD_FAMILY_16)

// Family 10h CPU_LOGICAL_ID.Revision equates
// -------------------------------------
  // Family 10h RB steppings
#define AMD_F10_RB_C0      0x0000000000000001ull
#define AMD_F10_RB_C1      0x0000000000000002ull
#define AMD_F10_RB_C2      0x0000000000000004ull
#define AMD_F10_RB_C3      0x0000000000000008ull
  // Family 10h BL steppings
#define AMD_F10_BL_C2      0x0000000000000010ull
#define AMD_F10_BL_C3      0x0000000000000020ull
  // Family 10h DA steppings
#define AMD_F10_DA_C2      0x0000000000000040ull
#define AMD_F10_DA_C3      0x0000000000000080ull
  // Family 10h HY SCM steppings
#define AMD_F10_HY_SCM_D0  0x0000000000000100ull
#define AMD_F10_HY_SCM_D1  0x0000000000000400ull
  // Family 10h HY MCM steppings
#define AMD_F10_HY_MCM_D0  0x0000000000000200ull
#define AMD_F10_HY_MCM_D1  0x0000000000000800ull
  // Family 10h PH steppings
#define AMD_F10_PH_E0      0x0000000000001000ull

  // Family 10h Unknown stepping
#define AMD_F10_UNKNOWN    0x8000000000000000ull

  // Family 10h Miscellaneous equates
#define AMD_F10_C0 (AMD_F10_RB_C0)
#define AMD_F10_C1 (AMD_F10_RB_C1)
#define AMD_F10_C2 (AMD_F10_RB_C2 | AMD_F10_DA_C2 | AMD_F10_BL_C2)
#define AMD_F10_C3 (AMD_F10_RB_C3 | AMD_F10_DA_C3 | AMD_F10_BL_C3)
#define AMD_F10_Cx (AMD_F10_C0 | AMD_F10_C1 | AMD_F10_C2 | AMD_F10_C3)

#define AMD_F10_RB_ALL (AMD_F10_RB_C0 | AMD_F10_RB_C1 | AMD_F10_RB_C2 | AMD_F10_RB_C3)

#define AMD_F10_BL_ALL (AMD_F10_BL_C2 | AMD_F10_BL_C3)
#define AMD_F10_BL_Cx  (AMD_F10_BL_C2 | AMD_F10_BL_C3)

#define AMD_F10_DA_ALL (AMD_F10_DA_C2 | AMD_F10_DA_C3)
#define AMD_F10_DA_Cx  (AMD_F10_DA_C2 | AMD_F10_DA_C3)

#define AMD_F10_D0 (AMD_F10_HY_SCM_D0 | AMD_F10_HY_MCM_D0)
#define AMD_F10_D1 (AMD_F10_HY_SCM_D1 | AMD_F10_HY_MCM_D1)
#define AMD_F10_Dx (AMD_F10_D0 | AMD_F10_D1)

#define AMD_F10_PH_ALL (AMD_F10_PH_E0)
#define AMD_F10_Ex (AMD_F10_PH_E0)

#define AMD_F10_HY_ALL (AMD_F10_Dx)
#define AMD_F10_C32_ALL (AMD_F10_HY_SCM_D0 | AMD_F10_HY_SCM_D1)

#define AMD_F10_GT_B0 (AMD_F10_Cx | AMD_F10_Dx | AMD_F10_Ex)
#define AMD_F10_GT_Bx (AMD_F10_Cx | AMD_F10_Dx | AMD_F10_Ex)
#define AMD_F10_GT_A2 (AMD_F10_Cx | AMD_F10_Dx | AMD_F10_Ex)
#define AMD_F10_GT_Ax (AMD_F10_Cx | AMD_F10_Dx | AMD_F10_Ex)
#define AMD_F10_GT_C0 ((AMD_F10_Cx & ~AMD_F10_C0) | AMD_F10_Dx | AMD_F10_Ex)
#define AMD_F10_GT_D0 (AMD_F10_Dx & ~AMD_F10_D0 | AMD_F10_Ex)

#define AMD_F10_ALL (AMD_F10_Cx | AMD_F10_Dx  | AMD_F10_Ex  | AMD_F10_UNKNOWN)

// Family 12h CPU_LOGICAL_ID.Revision equates
// -------------------------------------

  // Family 12h LN steppings
#define AMD_F12_LN_A0    0x0000000000000001ull
#define AMD_F12_LN_A1    0x0000000000000002ull
#define AMD_F12_LN_B0    0x0000000000000004ull
  // Family 12h Unknown stepping
#define AMD_F12_UNKNOWN  0x8000000000000000ull

#define AMD_F12_LN_Ax    (AMD_F12_LN_A0 | AMD_F12_LN_A1)
#define AMD_F12_LN_Bx    (AMD_F12_LN_B0)

#define AMD_F12_ALL      (AMD_F12_LN_Ax | AMD_F12_LN_Bx | AMD_F12_UNKNOWN)

// Family 14h CPU_LOGICAL_ID.Revision equates
// -------------------------------------

  // Family 14h ON steppings
#define AMD_F14_ON_A0    0x0000000000000001ull
#define AMD_F14_ON_A1    0x0000000000000002ull
#define AMD_F14_ON_B0    0x0000000000000004ull
#define AMD_F14_ON_C0    0x0000000000000008ull
  // Family 14h KR steppings
#define AMD_F14_KR_A0    0x0000000000000100ull
#define AMD_F14_KR_A1    0x0000000000000200ull
#define AMD_F14_KR_B0    0x0000000000000400ull
  // Family 14h Unknown stepping
#define AMD_F14_UNKNOWN  0x8000000000000000ull

#define AMD_F14_ON_Ax    (AMD_F14_ON_A0 | AMD_F14_ON_A1)
#define AMD_F14_ON_Bx    (AMD_F14_ON_B0)
#define AMD_F14_ON_Cx    (AMD_F14_ON_C0)
#define AMD_F14_ON_ALL   (AMD_F14_ON_Ax | AMD_F14_ON_Bx | AMD_F14_ON_Cx)

#define AMD_F14_ALL      (AMD_F14_ON_ALL | AMD_F14_UNKNOWN)

// Family 15h CPU_LOGICAL_ID.Revision equates
// -------------------------------------

  // Family 15h OROCHI steppings
#define AMD_F15_OR_A0    0x0000000000000001ull
#define AMD_F15_OR_A1    0x0000000000000002ull
#define AMD_F15_OR_B0    0x0000000000000004ull
  // Family 15h TN steppings
#define AMD_F15_TN_A0    0x0000000000000100ull
  // Family 15h Unknown stepping
#define AMD_F15_UNKNOWN  0x8000000000000000ull

#define AMD_F15_OR_Ax    (AMD_F15_OR_A0 | AMD_F15_OR_A1)
#define AMD_F15_OR_Bx    AMD_F15_OR_B0
#define AMD_F15_OR_GT_Ax (AMD_F15_OR_Bx)
#define AMD_F15_OR_LT_B1 (AMD_F15_OR_Ax | AMD_F15_OR_B0)
#define AMD_F15_OR_ALL   (AMD_F15_OR_Ax | AMD_F15_OR_Bx)

#define AMD_F15_ALL      (AMD_F15_OR_ALL | AMD_F15_UNKNOWN)

// Family 16h CPU_LOGICAL_ID.Revision equates
// TBD

#endif      // _CPU_FAM_REGISTERS_H_
# 228 "src/vendorcode/amd/agesa/f14/Proc/CPU/Family/cpuFamRegisters.h"

# 51 "src/vendorcode/amd/agesa/f14/Proc/CPU/cpuRegisters.h" 2
/*
 *--------------------------------------------------------------
 *
 *                      M O D U L E S    U S E D
 *
 *---------------------------------------------------------------
 */

/*
 *--------------------------------------------------------------
 *
 *                      D E F I N I T I O N S  /  M A C R O S
 *
 *---------------------------------------------------------------
 */

#define BIT0        0x0000000000000001ull
#define BIT1        0x0000000000000002ull
#define BIT2        0x0000000000000004ull
#define BIT3        0x0000000000000008ull
#define BIT4        0x0000000000000010ull
#define BIT5        0x0000000000000020ull
#define BIT6        0x0000000000000040ull
#define BIT7        0x0000000000000080ull
#define BIT8        0x0000000000000100ull
#define BIT9        0x0000000000000200ull
#define BIT10       0x0000000000000400ull
#define BIT11       0x0000000000000800ull
#define BIT12       0x0000000000001000ull
#define BIT13       0x0000000000002000ull
#define BIT14       0x0000000000004000ull
#define BIT15       0x0000000000008000ull
#define BIT16       0x0000000000010000ull
#define BIT17       0x0000000000020000ull
#define BIT18       0x0000000000040000ull
#define BIT19       0x0000000000080000ull
#define BIT20       0x0000000000100000ull
#define BIT21       0x0000000000200000ull
#define BIT22       0x0000000000400000ull
#define BIT23       0x0000000000800000ull
#define BIT24       0x0000000001000000ull
#define BIT25       0x0000000002000000ull
#define BIT26       0x0000000004000000ull
#define BIT27       0x0000000008000000ull
#define BIT28       0x0000000010000000ull
#define BIT29       0x0000000020000000ull
#define BIT30       0x0000000040000000ull
#define BIT31       0x0000000080000000ull
#define BIT32       0x0000000100000000ull
#define BIT33       0x0000000200000000ull
#define BIT34       0x0000000400000000ull
#define BIT35       0x0000000800000000ull
#define BIT36       0x0000001000000000ull
#define BIT37       0x0000002000000000ull
#define BIT38       0x0000004000000000ull
#define BIT39       0x0000008000000000ull
#define BIT40       0x0000010000000000ull
#define BIT41       0x0000020000000000ull
#define BIT42       0x0000040000000000ull
#define BIT43       0x0000080000000000ull
#define BIT44       0x0000100000000000ull
#define BIT45       0x0000200000000000ull
#define BIT46       0x0000400000000000ull
#define BIT47       0x0000800000000000ull
#define BIT48       0x0001000000000000ull
#define BIT49       0x0002000000000000ull
#define BIT50       0x0004000000000000ull
#define BIT51       0x0008000000000000ull
#define BIT52       0x0010000000000000ull
#define BIT53       0x0020000000000000ull
#define BIT54       0x0040000000000000ull
#define BIT55       0x0080000000000000ull
#define BIT56       0x0100000000000000ull
#define BIT57       0x0200000000000000ull
#define BIT58       0x0400000000000000ull
#define BIT59       0x0800000000000000ull
#define BIT60       0x1000000000000000ull
#define BIT61       0x2000000000000000ull
#define BIT62       0x4000000000000000ull
#define BIT63       0x8000000000000000ull

/// CPUID related registers
#define AMD_CPUID_FMF               0x80000001  // Family Model Features information
#define AMD_CPUID_APICID_LPC_BID    0x00000001  // Local APIC ID, Logical Processor Count, Brand ID
#define AMD_CPUID_L2L3Cache_L2TLB   0x80000006
#define AMD_CPUID_TLB_L1Cache       0x80000005
#define AMD_CPUID_APM               0x80000007
#define LOCAL_APIC_ID               24
#define LOGICAL_PROCESSOR_COUNT     16
#define AMD_CPUID_ASIZE_PCCOUNT     0x80000008  // Address Size, Physical Core Count

/// CPU Logical ID Transfer
typedef struct {
  UINT32         RawId;                         ///< RawID
  UINT64         LogicalId;                     ///< LogicalID
} CPU_LOGICAL_ID_XLAT;

/// Logical CPU ID Table
typedef struct {
  IN       UINT32  Elements;                    ///< Number of Elements
  IN       CPU_LOGICAL_ID_XLAT *LogicalIdTable; ///< CPU Logical ID Transfer table Pointer
} LOGICAL_ID_TABLE;

// MSRs
// ------------------------
#define MCG_CTL_P                   0x00000100              // bit 8  for MCG_CTL_P under MSRR
#define MSR_MCG_CAP                 0x00000179
#define MSR_MC0_CTL                 0x00000400

#define MSR_APIC_BAR                0x0000001B
#define MSR_PATCH_LEVEL             0x0000008B

#define CPUID_LONG_MODE_ADDR        0x80000008
#define AMD_CPUID_FMF               0x80000001

#define MSR_EXTENDED_FEATURE_EN     0xC0000080
#define MSR_MC_MISC_LINK_THRESHOLD  0xC0000408
#define MSR_MC_MISC_L3_THRESHOLD    0xC0000409
#define MSR_PATCH_LOADER            0xC0010020

/// Patch Loader Register
typedef struct {
  UINT64 PatchBase:32;                ///< Linear address of patch header address block
  UINT64 SBZ:32;                      ///< Should be zero
} PATCH_LOADER_MSR;

#define MSR_SYS_CFG                 0xC0010010      // SYSCFG - F15 Shared
#define MSR_TOM2                    0xC001001D      // TOP_MEM2 - F15 Shared
#define MSR_MC0_CTL_MASK            0xC0010044      // MC0 Control Mask
#define MSR_MC1_CTL_MASK            0xC0010045      // MC1 Control Mask
#define MSR_MC2_CTL_MASK            0xC0010046      // MC2 Control Mask
#define MSR_MC4_CTL_MASK            0xC0010048      // MC4 Control Mask

#define MSR_CPUID_FEATS             0xC0011004      // CPUID Features
#define MSR_CPUID_EXT_FEATS         0xC0011005      // CPUID Extended Features
#define MSR_HWCR                    0xC0010015
#define MSR_NB_CFG                  0xC001001F      // NB Config
#define ENABLE_CF8_EXT_CFG          0x00004000      // [46]
#define INIT_APIC_CPUID_LO          0x00400000      // [54]
#define MSR_LS_CFG                  0xC0011020
#define MSR_IC_CFG                  0xC0011021      // ICache Config - F15 Shared
#define MSR_DC_CFG                  0xC0011022
#define MSR_ME_CFG                  0xC0011029
#define MSR_BU_CFG                  0xC0011023
#define MSR_CU_CFG                  0xC0011023      // F15 Shared
#define MSR_DE_CFG                  0xC0011029      // F15 Shared
#define MSR_BU_CFG2                 0xC001102A
#define MSR_CU_CFG2                 0xC001102A      // F15 Shared
#define MSR_BU_CFG3                 0xC001102B
#define MSR_CU_CFG3                 0xC001102B      // F15 Shared
#define MSR_IBS_OP_DATA3            0xC0011037


#define MSR_CPUID_NAME_STRING0      0xC0010030      // First CPUID namestring register
#define MSR_CPUID_NAME_STRING1      0xC0010031
#define MSR_CPUID_NAME_STRING2      0XC0010032
#define MSR_CPUID_NAME_STRING3      0xC0010033
#define MSR_CPUID_NAME_STRING4      0xC0010034
#define MSR_CPUID_NAME_STRING5      0xC0010035      // Last CPUID namestring register
#define MSR_MMIO_Cfg_Base           0xC0010058      // MMIO Configuration Base Address Register
#define MSR_BIST                    0xC0010060      // BIST Results register
#define MSR_OSVW_ID_Length          0xC0010140
#define MSR_OSVW_Status             0xC0010141
#define MSR_PERF_CONTROL3           0xC0010003      // Perfromance control register number 3
#define MSR_PERF_COUNTER3           0xC0010007      // Performance counter register number 3
#define PERF_RESERVE_BIT_MASK       0x030FFFDFFFFF  // Mask of the Performance control Reserve bits
#define PERF_CAR_CORRUPTION_EVENT   0x040040F0E2    // Configure the controller to capture the
                                                    // CAR Corruption
// FUNC_0 registers
// ----------------
#define HT_LINK_FREQ_OFFSET         8           // Link HT Frequency from capability base
#define HT_LINK_CONTROL_REG_OFFSET  4
#define HT_LINK_TYPE_REG_OFFSET     0x18
#define HT_LINK_EXTENDED_FREQ       0x1C
#define HT_LINK_HOST_CAP_MAX        0x20        // HT Host Capability offsets are less than its size.
#define HT_CAPABILITIES_POINTER     0x34
#define NODE_ID                     0x60
#define HT_INIT_CTRL                0x6C
#define HT_INIT_CTRL_REQ_DIS        0x02        // [1] = ReqDis
#define HT_INIT_COLD_RST_DET        BIT4
#define HT_INIT_BIOS_RST_DET_0      BIT5
#define HT_INIT_BIOS_RST_DET_1      BIT9
#define HT_INIT_BIOS_RST_DET_2      BIT10
#define HT_INIT_BIOS_RST_DET        BIT9 | BIT10
#define HT_TRANS_CTRL               0x68
#define HT_TRANS_CTRL_CPU1_EN       0x00000020  // [5] = CPU1 Enable
#define HT_LINK_CONTROL_0           0x84
#define HT_LINK_FREQ_0              0x88        // Link HT Frequency
#define EXTENDED_NODE_ID            0x160
#define ECS_HT_TRANS_CTRL           0x168
#define ECS_HT_TRANS_CTRL_CPU2_EN   0x00000001  // [0] = CPU2 Enable
#define ECS_HT_TRANS_CTRL_CPU3_EN   0x00000002  // [1] = CPU3 Enable
#define ECS_HT_TRANS_CTRL_CPU4_EN   0x00000004  // [2] = CPU4 Enable
#define ECS_HT_TRANS_CTRL_CPU5_EN   0x00000008  // [3] = CPU5 Enable

#define CORE_CTRL                   0x1DC
#define CORE_CTRL_CORE1_EN          0x00000002
#define CORE_CTRL_CORE2_EN          0x00000004
#define CORE_CTRL_CORE3_EN          0x00000008
#define CORE_CTRL_CORE4_EN          0x00000010
#define CORE_CTRL_CORE5_EN          0x00000020
#define CORE_CTRL_CORE6_EN          0x00000040
#define CORE_CTRL_CORE7_EN          0x00000080

// FUNC_3 registers
// ----------------
#define HARDWARE_THERMAL_CTRL_REG       0x64
#define SOFTWARE_THERMAL_CTRL_REG       0x68

#define ACPI_PSC_0_REG                  0x80    // ACPI Power State Control Registers
#define ACPI_PSC_4_REG                  0x84

#define NB_CFG_HIGH_REG                 0x8C
#define POWER_CTRL_MISCELLANEOUS_REG    0xA0
#define CLOCK_POWER_TIMING_CTRL2_REG    0xDC
#define NORTH_BRIDGE_CAPABILITIES_REG   0xE8
#define MULTI_NODE_CPU                  29
#define CPUID_FMR                       0xFC    // Family / Model registers
#define DOWNCORE_CTRL                   0x190   // Downcore Control Register

#define LINK_TO_XCS_TOKEN_COUNT_REG_3X148 0x148
#define REG_HT4_PHY_OFFSET_BASE_4X180    0x180
#define REG_HT4_PHY_DATA_PORT_BASE_4X184 0x184

#define HTPHY_OFFSET_MASK         0xE00001FF
#define HTPHY_WRITE_CMD           0x40000000
#define HTPHY_IS_COMPLETE_MASK    0x80000000
#define HTPHY_DIRECT_MAP          0x20000000
#define HTPHY_DIRECT_OFFSET_MASK  0xE000FFFF

// FUNC_5 registers
// ----------------
#define COMPUTE_UNIT_STATUS       0x80
#define NORTH_BRIDGE_CAPABILITIES_2_REG  0x84


// Misc. defines.
#define PCI_DEV_BASE    24

#define CPU_STEPPING    0x0000000F
#define CPU_MODEL       0x000000F0
#define CPU_EMODEL      0x000F0000
#define CPU_EFAMILY     0x00F00000
#define CPU_FMS_MASK    CPU_EFAMILY | CPU_EMODEL | CPU_MODEL | CPU_STEPPING

#define HTPHY_SELECT        2
#define PCI_SELECT          1
#define MSR_SELECT          0

#define LOGICAL_ID      1
#define F_SCHEME        0
#define DR_SCHEME       1
#define GR_SCHEME       2

#define DR_NO_STRING        0
#define DR_SOCKET_C32       5
#define DR_SOCKET_ASB2      4
#define DR_SOCKET_G34       3
#define DR_SOCKET_S1G3      2
#define DR_SOCKET_S1G4      2
#define DR_SOCKET_AM3       1
#define DR_SOCKET_1207      0
#define LN_SOCKET_FM1       2
#define LN_SOCKET_FS1       1
#define LN_SOCKET_FP1       0
#define ON_SOCKET_FT1       0
#define OR_SOCKET_AM3       1
#define OR_SOCKET_G34       3
#define OR_SOCKET_C32       5
#define SOCKET_IGNORE       0xF

#define LAPIC_BASE_ADDR_MASK    0x0000FFFFFFFFF000
#define APIC_EXT_BRDCST_MASK    0x000E0000
#define APIC_ENABLE_BIT         0x00000800
#define LOCAL_APIC_ADDR         0xFEE00000
#define INT_CMD_REG_LO          0x300
#define INT_CMD_REG_HI          0x310
#define REMOTE_MSG_REG          0x380
#define REMOTE_READ_REG         0xC0
#define APIC_ID_REG             0x20
#define APIC20_ApicId           24
#define CMD_REG_TO_READ_DATA    0x338

#define MAX_CORE_ID_SIZE 8
#define MAX_CORE_ID_MASK ((1 << MAX_CORE_ID_SIZE) - 1)

/*-------------------------
 * Default definitions
 *-------------------------
 */
#define DOWNCORE_MASK_SINGLE    0xFFFFFFFE
#define DOWNCORE_MASK_DUAL      0xFFFFFFFC
#define DOWNCORE_MASK_TRI       0xFFFFFFF8
#define DOWNCORE_MASK_FOUR      0xFFFFFFF0
#define DOWNCORE_MASK_FIVE      0xFFFFFFE0
#define DOWNCORE_MASK_SIX       0xFFFFFFC0
#define DOWNCORE_MASK_DUAL_COMPUTE_UNIT  0xFFFFFFFA
#define DOWNCORE_MASK_TRI_COMPUTE_UNIT   0xFFFFFFEA
#define DOWNCORE_MASK_FOUR_COMPUTE_UNIT  0xFFFFFFAA

#define DELIVERY_STATUS             BIT13
#define REMOTE_READ_STAT_MASK       0x00030000
#define REMOTE_DELIVERY_PENDING     0x00010000
#define REMOTE_DELIVERY_DONE        0x00020000

/*
 * --------------------------------------------------------------------------------------
 *
 *             D E F I N E S    /   T Y P E D E F S   /  S T R U C T U R E S
 *
 * --------------------------------------------------------------------------------------
 */

/// CpuEarly param type
typedef struct {
  IN       UINT8                  MemInitPState;        ///< Pstate value during memory initial
  IN       PLATFORM_CONFIGURATION PlatformConfig;       ///< Runtime configurable user options
} AMD_CPU_EARLY_PARAMS;

/// Enum - Will be used to access each structure
///        related to each CPU family
typedef enum {
  REVF,                                       ///< NPT, RevF
  REVG,                                       ///< NPT, RevG
  DEERHOUND,                                  ///< Family 10h, Deerhound
  GRIFFIN                                     ///< Family 11h, Griffin
} CPU_FAMILY;

/// CPUID
typedef enum {
  REG_EAX,                                    ///< EAX
  REG_EBX,                                    ///< EBX
  REG_ECX,                                    ///< ECX
  REG_EDX                                     ///< EDX
} CPUID_REG;

/// Structure needed to load the IDTR using the lidt instruction
typedef struct {
  UINT16 Limit;        ///< Interrupt Descriptor Table size
  UINT64 Base;         ///< Interrupt Descriptor Table base address
} IDT_BASE_LIMIT;

#endif      // _CPU_REGISTERS_H_
# 394 "src/vendorcode/amd/agesa/f14/Proc/CPU/cpuRegisters.h"

# 56 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c" 2
#if 0 /* expanded by -frewrite-includes */
#include "amdlib.h"
#endif /* expanded by -frewrite-includes */
# 56 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
# 1 "src/vendorcode/amd/agesa/f14/Lib/amdlib.h" 1
/* $NoKeywords:$ */
/**
 * @file
 *
 * AMD Library
 *
 * Contains interface to the AMD AGESA library
 *
 * @xrefitem bom "File Content Label" "Release Content"
 * @e project:      AGESA
 * @e sub-project:  Lib
 * @e \$Revision: 34897 $   @e \$Date: 2010-07-14 10:07:10 +0800 (Wed, 14 Jul 2010) $
 *
 */
/*
 *****************************************************************************
 *
 * Copyright (c) 2011, Advanced Micro Devices, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Advanced Micro Devices, Inc. nor the names of 
 *       its contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ADVANCED MICRO DEVICES, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***************************************************************************
 *
 */

#ifndef _AMD_LIB_H_
#define _AMD_LIB_H_

/*----------------------------------------------------------------------------------------
 *                   D E F I N I T I O N S    A N D    M A C R O S
 *----------------------------------------------------------------------------------------
 */
#define IOCF8 0xCF8
#define IOCFC 0xCFC

// Reg Values for ReadCpuReg and WriteCpuReg
#define    CR0_REG  0x00
#define    CR4_REG  0x04
#define    DR0_REG  0x10
#define    DR1_REG  0x11
#define    DR2_REG  0x12
#define    DR3_REG  0x13
#define    DR7_REG  0x17

/*----------------------------------------------------------------------------------------
 *                  T Y P E D E F S     A N D     S T R U C T U  R E S
 *----------------------------------------------------------------------------------------
 */
/*----------------------------------------------------------------------------------------
 *           P R O T O T Y P E S     O F     L O C A L     F U  N C T I O N S
 *----------------------------------------------------------------------------------------
 */
 
 
/*----------------------------------------------------------------------------------------
 *                          E X P O R T E D    F U N C T I O N S
 *----------------------------------------------------------------------------------------
 */
 
#if !defined __GNUC__
// PROTOTYPES FOR amdlib32.asm
void _mm_stream_si128_fs (void *__A, void *__B);
void _mm_store_si128_fs (void *dest, void *data);
void _mm_clflush_fs (void *address32);
#endif
# 87 "src/vendorcode/amd/agesa/f14/Lib/amdlib.h"
/*---------------------------------------------------------------------------------------
 *                          L O C A L    F U N C T I O N S
 *---------------------------------------------------------------------------------------
 */
UINT8
ReadIo8 (
  IN       UINT16 Address
  );

UINT16
ReadIo16 (
  IN       UINT16 Address
  );

UINT32
ReadIo32 (
  IN       UINT16 Address
  );

VOID
WriteIo8 (
  IN       UINT16 Address,
  IN       UINT8 Data
  );

VOID
WriteIo16 (
  IN       UINT16 Address,
  IN       UINT16 Data
  );

VOID
WriteIo32 (
  IN       UINT16 Address,
  IN       UINT32 Data
  );

UINT8
Read64Mem8 (
  IN       UINT64 Address
  );

UINT16
Read64Mem16 (
  IN       UINT64 Address
  );

UINT32
Read64Mem32 (
  IN       UINT64 Address
  );

VOID
Write64Mem8 (
  IN       UINT64 Address,
  IN       UINT8 Data
  );

VOID
Write64Mem16 (
  IN       UINT64 Address,
  IN       UINT16 Data
  );

VOID
Write64Mem32 (
  IN       UINT64 Address,
  IN       UINT32 Data
  );

UINT64
ReadTSC (
  VOID
  );

// MSR
VOID
LibAmdMsrRead (
  IN       UINT32 MsrAddress,
     OUT   UINT64 *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdMsrWrite (
  IN       UINT32 MsrAddress,
  IN       UINT64 *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

// IO
VOID
LibAmdIoRead (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
     OUT   VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdIoWrite (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
  IN       VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdIoRMW (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdIoPoll (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN       UINT64 Delay,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

// Memory or MMIO
VOID
LibAmdMemRead (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
     OUT   VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdMemWrite (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
  IN       VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdMemRMW (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdMemPoll (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN       UINT64 Delay,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

// PCI
VOID
LibAmdPciRead (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
     OUT   VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdPciWrite (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
  IN       VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdPciRMW (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdPciPoll (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN       UINT64 Delay,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdPciReadBits (
  IN       PCI_ADDR Address,
  IN       UINT8 Highbit,
  IN       UINT8 Lowbit,
     OUT   UINT32 *Value,
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdPciWriteBits (
  IN       PCI_ADDR Address,
  IN       UINT8 Highbit,
  IN       UINT8 Lowbit,
  IN       UINT32 *Value,
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdPciFindNextCap (
  IN OUT   PCI_ADDR *Address,
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

// CPUID
VOID
LibAmdCpuidRead (
  IN       UINT32 CpuidFcnAddress,
     OUT   CPUID_DATA *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

// Utility Functions
VOID
LibAmdMemFill (
  IN       VOID *Destination,
  IN       UINT8 Value,
  IN       UINTN FillLength,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID
LibAmdMemCopy (
  IN       VOID *Destination,
  IN       VOID *Source,
  IN       UINTN CopyLength,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  );

VOID *
LibAmdLocateImage (
  IN       VOID *StartAddress,
  IN       VOID *EndAddress,
  IN       UINT32 Alignment,
  IN       CHAR8 ModuleSignature[8]
  );

UINT32
LibAmdGetPackageType (
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

BOOLEAN
LibAmdVerifyImageChecksum (
  IN       VOID *ImagePtr
  );

UINT8
LibAmdBitScanReverse (
  IN       UINT32 value
  );
UINT8
LibAmdBitScanForward (
  IN       UINT32 value
  );

VOID
LibAmdReadCpuReg (
  IN       UINT8 RegNum,
     OUT   UINT32 *Value
  );
VOID
LibAmdWriteCpuReg (
  IN       UINT8 RegNum,
  IN       UINT32 Value
  );

VOID
LibAmdWriteBackInvalidateCache (
  IN       VOID
  );

VOID
LibAmdSimNowEnterDebugger (VOID);

VOID
LibAmdHDTBreakPoint (VOID);

UINT8
LibAmdAccessWidth (
  IN       ACCESS_WIDTH AccessWidth
  );

VOID
LibAmdCLFlush (
  IN       UINT64 Address,
  IN       UINT8  Count
  );

VOID F10RevDProbeFilterCritical (
  IN       PCI_ADDR PciAddress,
  IN       UINT32   PciRegister
  );
VOID
IdsOutPort (
  IN       UINT32 Addr,
  IN       UINT32 Value,
  IN       UINT32 Flag
  );
  
VOID 
StopHere (
  VOID
  );
  
VOID 
CpuidRead (
  IN        UINT32      CpuidFcnAddress,
  OUT       CPUID_DATA  *Value
  );
  
UINT8 
ReadNumberOfCpuCores(
  VOID
  );
  
#endif // _AMD_LIB_H_
# 422 "src/vendorcode/amd/agesa/f14/Lib/amdlib.h"
# 57 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c" 2
#if 0 /* expanded by -frewrite-includes */
#include "Filecode.h"
#endif /* expanded by -frewrite-includes */
# 57 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
# 58 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"
CODE_GROUP (G1_PEICC)
RDATA_GROUP (G1_PEICC)

#define FILECODE LIB_AMDLIB_FILECODE

/*----------------------------------------------------------------------------------------
 *                   D E F I N I T I O N S    A N D    M A C R O S
 *----------------------------------------------------------------------------------------
 */


/*----------------------------------------------------------------------------------------
 *                  T Y P E D E F S     A N D     S T R U C T U R E S
 *----------------------------------------------------------------------------------------
 */


/*----------------------------------------------------------------------------------------
 *           P R O T O T Y P E S     O F     L O C A L     F U N C T I O N S
 *----------------------------------------------------------------------------------------
 */


BOOLEAN
STATIC
GetPciMmioAddress (
     OUT   UINT64            *MmioAddress,
     OUT   UINT32            *MmioSize,
  IN       AMD_CONFIG_PARAMS *StdHeader
  );

VOID
STATIC
LibAmdGetDataFromPtr (
  IN       ACCESS_WIDTH AccessWidth,
  IN       VOID         *Data,
  IN       VOID         *DataMask,
     OUT   UINT32       *TemData,
     OUT   UINT32       *TempDataMask
  );

/*----------------------------------------------------------------------------------------
 *                          E X P O R T E D    F U N C T I O N S
 *----------------------------------------------------------------------------------------
 */
UINT8
ReadIo8 (
  IN       UINT16 Address
  )
{
  return __inbyte (Address);
}
UINT16
ReadIo16 (
  IN       UINT16 Address
  )
{
  return __inword (Address);
}
UINT32
ReadIo32 (
  IN       UINT16 Address
  )
{
  return __indword (Address);
}
VOID
WriteIo8 (
  IN       UINT16 Address,
  IN       UINT8 Data
  )
{
  __outbyte (Address, Data);
}
VOID
WriteIo16 (
  IN       UINT16 Address,
  IN       UINT16 Data
  )
{
  __outword (Address, Data);
}
VOID
WriteIo32 (
  IN       UINT16 Address,
  IN       UINT32 Data
  )
{
   __outdword (Address, Data);
}
STATIC
UINT64 SetFsBase (
  UINT64 address
  )
{
  UINT64 hwcr;
  hwcr = __readmsr (0xC0010015);
  __writemsr (0xC0010015, hwcr | 1 << 17);
  __writemsr (0xC0000100, address);
  return hwcr;
}
STATIC
VOID
RestoreHwcr (
  UINT64
  value
  )
{
  __writemsr (0xC0010015, value);
}
UINT8
Read64Mem8 (
  IN       UINT64 Address
  )
{
  UINT8 dataRead;
  UINT64 hwcrSave;
  if ((Address >> 32) == 0) {
    return *(volatile UINT8 *) (UINTN) Address;
  }
  hwcrSave = SetFsBase (Address);
  dataRead = __readfsbyte (0);
  RestoreHwcr (hwcrSave);
  return dataRead;
}
UINT16
Read64Mem16 (
  IN       UINT64 Address
  )
{
  UINT16 dataRead;
  UINT64 hwcrSave;
  if ((Address >> 32) == 0) {
    return *(volatile UINT16 *) (UINTN) Address;
  }
  hwcrSave = SetFsBase (Address);
  dataRead = __readfsword (0);
  RestoreHwcr (hwcrSave);
  return dataRead;
}
UINT32
Read64Mem32 (
  IN       UINT64 Address
  )
{
  UINT32 dataRead;
  UINT64 hwcrSave;
  if ((Address >> 32) == 0) {
    return *(volatile UINT32 *) (UINTN) Address;
  }
  hwcrSave = SetFsBase (Address);
  dataRead = __readfsdword (0);
  RestoreHwcr (hwcrSave);
  return dataRead;
  }
VOID
Write64Mem8 (
  IN       UINT64 Address,
  IN       UINT8 Data
  )
{
  if ((Address >> 32) == 0){
    *(volatile UINT8 *) (UINTN) Address = Data;
  }
  else {
    UINT64 hwcrSave;
    hwcrSave = SetFsBase (Address);
    __writefsbyte (0, Data);
    RestoreHwcr (hwcrSave);
  }
}
VOID
Write64Mem16 (
  IN       UINT64 Address,
  IN       UINT16 Data
  )
{
 if ((Address >> 32) == 0){
   *(volatile UINT16 *) (UINTN) Address = Data;
 }
 else {
   UINT64 hwcrSave;
   hwcrSave = SetFsBase (Address);
   __writefsword (0, Data);
   RestoreHwcr (hwcrSave);
 }
}
VOID
Write64Mem32 (
  IN       UINT64 Address,
  IN       UINT32 Data
  )
{
  if ((Address >> 32) == 0){
    *(volatile UINT32 *) (UINTN) Address = Data;
  }
  else {
    UINT64 hwcrSave;
    hwcrSave = SetFsBase (Address);
    __writefsdword (0, Data);
    RestoreHwcr (hwcrSave);
  }
}
VOID
LibAmdReadCpuReg (
  IN       UINT8 RegNum,
     OUT   UINT32 *Value
  )
{
    *Value = 0;
    switch (RegNum){
    case CR4_REG:
      *Value = __readcr4 ();
      break;
    case DR0_REG:
      *Value = __readdr (0);
      break;
    case DR1_REG:
      *Value = __readdr (1);
      break;
    case DR2_REG:
      *Value = __readdr (2);
      break;
    case DR3_REG:
      *Value = __readdr (3);
      break;
    case DR7_REG:
      *Value = __readdr (7);
      break;
    default:
      *Value = -1;
  }
}
VOID
LibAmdWriteCpuReg (
  IN       UINT8 RegNum,
  IN       UINT32 Value
  )
{
   switch (RegNum){
    case CR4_REG:
      __writecr4 (Value);
      break;
    case DR0_REG:
      __writedr (0, Value);
      break;
    case DR1_REG:
      __writedr (1, Value);
      break;
    case DR2_REG:
      __writedr (2, Value);
      break;
    case DR3_REG:
      __writedr (3, Value);
      break;
    case DR7_REG:
      __writedr (7, Value);
      break;
    default:
      ;
  }
}
VOID
LibAmdWriteBackInvalidateCache (
  IN       VOID
  )
{
  __wbinvd ();
}
VOID
LibAmdHDTBreakPoint (
  VOID
  )
{
  __writemsr (0xC001100A, __readmsr (0xC001100A) | 1);
  __debugbreak (); // do you really need icebp? If so, go back to asm code
}
UINT8
LibAmdBitScanForward (
  IN       UINT32 value
  )
{
  UINTN Index;
  for (Index = 0; Index < 32; Index++){
    if (value & (1 << Index)) break;
  }
  return (UINT8) Index;
}
UINT8
LibAmdBitScanReverse (
  IN       UINT32 value
)
{
  int Index;
  for (Index = 31; Index >= 0; Index--){
      if (value & (1 << Index)) break;
  }
  return (UINT8) Index;
}
VOID
LibAmdMsrRead (
  IN       UINT32 MsrAddress,
     OUT   UINT64 *Value,
  IN OUT   AMD_CONFIG_PARAMS *ConfigPtr
  )
{
  *Value = __readmsr (MsrAddress);
}
VOID
LibAmdMsrWrite (
  IN       UINT32 MsrAddress,
  IN       UINT64 *Value,
  IN OUT   AMD_CONFIG_PARAMS *ConfigPtr
  )
{
  __writemsr (MsrAddress, *Value);
}
void LibAmdCpuidRead (
  IN       UINT32 CpuidFcnAddress,
     OUT   CPUID_DATA* Value,
  IN OUT   AMD_CONFIG_PARAMS *ConfigPtr
  )
{
  __cpuid ((int *)Value, CpuidFcnAddress);
}
UINT64
ReadTSC (
  VOID
  )
{
  return __rdtsc ();
}
VOID
LibAmdSimNowEnterDebugger (
  VOID
  )
{
  STATIC CONST UINT8 opcode [] = {0x60,                             // pushad
                                   0xBB, 0x02, 0x00, 0x00, 0x00,     // mov ebx, 2
                                   0xB8, 0x0B, 0xD0, 0xCC, 0xBA,     // mov eax, 0xBACCD00B
                                   0x0F, 0xA2,                       // cpuid
                                   0x61,                             // popad
                                   0xC3                              // ret
                                 };
  ((VOID (*)(VOID)) (size_t) opcode) (); // call the function
}

#ifdef __SSE3__
VOID F10RevDProbeFilterCritical (
  IN       PCI_ADDR PciAddress,
  IN       UINT32   PciRegister
  )
{
  UINT64 msrsave;
  msrsave = __readmsr (0xC001001F);
  __writemsr (0xC001001F, msrsave | 1ULL << 46);  // EnableCf8ExtCfg
  _mm_mfence ();
  __outdword (0xCF8, PciAddress.AddressValue);
  _mm_mfence ();
  __outdword (0xCFC, PciRegister | 2);
  _mm_mfence ();
  __writemsr (0xC001001F, msrsave);
}

VOID
LibAmdCLFlush (
  IN       UINT64 Address,
  IN       UINT8  Count
  )
{
  UINT64 hwcrSave;
  UINT8  *address32;
  UINTN  Index;
  address32 = 0;
  hwcrSave = SetFsBase (Address);
  for (Index = 0; Index < Count; Index++){
    _mm_mfence ();
    _mm_clflush_fs (&address32 [Index * 64]);
  }
  RestoreHwcr (hwcrSave);
}
#endif //__SSE3__
# 440 "src/vendorcode/amd/agesa/f14/Lib/amdlib.c"

VOID
IdsOutPort (
  IN       UINT32 Addr,
  IN       UINT32 Value,
  IN       UINT32 Flag
  )
{
  __outdword ((UINT16) Addr, Value);
}
VOID
StopHere (
  VOID
  )
{
  VOLATILE UINTN x = 1;
  while (x);
}

/*---------------------------------------------------------------------------------------*/
/**
 * Read IO port
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] IoAddress     IO port address
 * @param[in] Value         Pointer to save data
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdIoRead (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
     OUT   VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  switch (AccessWidth) {
    case AccessWidth8:
    case AccessS3SaveWidth8:
      *(UINT8 *) Value = ReadIo8 (IoAddress);
      break;
    case AccessWidth16:
    case AccessS3SaveWidth16:
      *(UINT16 *) Value = ReadIo16 (IoAddress);
      break;
    case AccessWidth32:
    case AccessS3SaveWidth32:
      *(UINT32 *) Value = ReadIo32 (IoAddress);
      break;
  default:
    ASSERT (FALSE);
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Write IO port
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] IoAddress     IO port address
 * @param[in] Value         Pointer to data
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdIoWrite (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
  IN       VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  switch (AccessWidth) {
    case AccessWidth8:
    case AccessS3SaveWidth8:
      WriteIo8 (IoAddress, *(UINT8 *) Value);
      break;
    case AccessWidth16:
    case AccessS3SaveWidth16:
      WriteIo16 (IoAddress, *(UINT16 *) Value);
      break;
    case AccessWidth32:
    case AccessS3SaveWidth32:
      WriteIo32 (IoAddress, *(UINT32 *) Value);
      break;
    default:
     ASSERT (FALSE);
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * IO read modify write
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] IoAddress     IO address
 * @param[in] Data          OR data
 * @param[in] DataMask      Mask to be used before data write back to register.
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdIoRMW (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32  TempData = 0;
  UINT32  TempMask = 0;
  UINT32  Value;
  LibAmdGetDataFromPtr (AccessWidth, Data,  DataMask, &TempData, &TempMask);
  LibAmdIoRead (AccessWidth, IoAddress, &Value, StdHeader);
  Value = (Value & (~TempMask)) | TempData;
  LibAmdIoWrite (AccessWidth, IoAddress, &Value, StdHeader);
}

/*---------------------------------------------------------------------------------------*/
/**
 * Poll IO register
 *
 *  Poll register until (RegisterValue & DataMask) ==  Data
 *
 * @param[in] AccessWidth   Access width
 * @param[in] IoAddress     IO address
 * @param[in] Data          Data to compare
 * @param[in] DataMask      And mask
 * @param[in] Delay         Poll for time in 100ns (not supported)
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdIoPoll (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT16 IoAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN       UINT64 Delay,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32  TempData = 0;
  UINT32  TempMask = 0;
  UINT32  Value;
  LibAmdGetDataFromPtr (AccessWidth, Data,  DataMask, &TempData, &TempMask);
  do {
    LibAmdIoRead (AccessWidth, IoAddress, &Value, StdHeader);
  } while (TempData != (Value & TempMask));
}

/*---------------------------------------------------------------------------------------*/
/**
 * Read memory/MMIO
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] MemAddress    Memory address
 * @param[in] Value         Pointer to data
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdMemRead (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
     OUT   VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  switch (AccessWidth) {
    case AccessWidth8:
    case AccessS3SaveWidth8:
      *(UINT8 *) Value = Read64Mem8 (MemAddress);
      break;
    case AccessWidth16:
    case AccessS3SaveWidth16:
      *(UINT16 *) Value = Read64Mem16 (MemAddress);
      break;
    case AccessWidth32:
    case AccessS3SaveWidth32:
      *(UINT32 *) Value = Read64Mem32 (MemAddress);
      break;
    default:
      ASSERT (FALSE);
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Write memory/MMIO
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] MemAddress    Memory address
 * @param[in] Value         Pointer to data
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdMemWrite (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
  IN       VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{

  switch (AccessWidth) {
    case AccessWidth8:
    case AccessS3SaveWidth8:
      Write64Mem8 (MemAddress, *((UINT8 *) Value));
      break;
    case AccessWidth16:
    case AccessS3SaveWidth16:
      Write64Mem16 (MemAddress, *((UINT16 *) Value));
      break;
    case AccessWidth32:
    case AccessS3SaveWidth32:
      Write64Mem32 (MemAddress, *((UINT32 *) Value));
      break;
    default:
      ASSERT (FALSE);
  }
}
/*---------------------------------------------------------------------------------------*/
/**
 * Memory/MMIO read modify write
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] MemAddress    Memory address
 * @param[in] Data          OR data
 * @param[in] DataMask      Mask to be used before data write back to register.
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdMemRMW (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32  TempData = 0;
  UINT32  TempMask = 0;
  UINT32  Value;
  LibAmdGetDataFromPtr (AccessWidth, Data,  DataMask, &TempData, &TempMask);
  LibAmdMemRead (AccessWidth, MemAddress, &Value, StdHeader);
  Value = (Value & (~TempMask)) | TempData;
  LibAmdMemWrite (AccessWidth, MemAddress, &Value, StdHeader);
}

/*---------------------------------------------------------------------------------------*/
/**
 * Poll Mmio
 *
 *  Poll register until (RegisterValue & DataMask) ==  Data
 *
 * @param[in] AccessWidth   Access width
 * @param[in] MemAddress    Memory address
 * @param[in] Data          Data to compare
 * @param[in] DataMask      AND mask
 * @param[in] Delay         Poll for time in 100ns (not supported)
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdMemPoll (
  IN       ACCESS_WIDTH AccessWidth,
  IN       UINT64 MemAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN       UINT64 Delay,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32  TempData = 0;
  UINT32  TempMask = 0;
  UINT32  Value;
  LibAmdGetDataFromPtr (AccessWidth, Data,  DataMask, &TempData, &TempMask);
  do {
    LibAmdMemRead (AccessWidth, MemAddress, &Value, StdHeader);
  } while (TempData != (Value & TempMask));
}

/*---------------------------------------------------------------------------------------*/
/**
 * Read PCI config space
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] PciAddress    Pci address
 * @param[in] Value         Pointer to data
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdPciRead (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
     OUT   VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32 LegacyPciAccess;
  UINT32 MMIOSize;
  UINT64 RMWrite;
  UINT64 RMWritePrevious;
  UINT64 MMIOAddress;

  ASSERT (StdHeader != NULL);
  ASSERT (PciAddress.AddressValue != ILLEGAL_SBDFO);
  if (!GetPciMmioAddress (&MMIOAddress, &MMIOSize, StdHeader)) {
    // We need to convert our "portable" PCI address into a "real" PCI access
    LegacyPciAccess = ((1 << 31) + (PciAddress.Address.Register & 0xFC) + (PciAddress.Address.Function << 8) + (PciAddress.Address.Device << 11) + (PciAddress.Address.Bus << 16) + ((PciAddress.Address.Register & 0xF00) << (24 - 8)));
    if (PciAddress.Address.Register <= 0xFF) {
      LibAmdIoWrite (AccessWidth32, IOCF8, &LegacyPciAccess, StdHeader);
      LibAmdIoRead (AccessWidth, IOCFC + (UINT16) (PciAddress.Address.Register & 0x3), Value, StdHeader);
    } else {
      LibAmdMsrRead  (NB_CFG, &RMWritePrevious, StdHeader);
      RMWrite = RMWritePrevious | 0x0000400000000000ull;
      LibAmdMsrWrite (NB_CFG, &RMWrite, StdHeader);
      LibAmdIoWrite (AccessWidth32, IOCF8, &LegacyPciAccess, StdHeader);
      LibAmdIoRead (AccessWidth, IOCFC + (UINT16) (PciAddress.Address.Register & 0x3), Value, StdHeader);
      LibAmdMsrWrite (NB_CFG, &RMWritePrevious, StdHeader);
    }
  } else {
    // Setup the MMIO address
    ASSERT ((MMIOAddress + MMIOSize) > (MMIOAddress + (PciAddress.AddressValue & 0x0FFFFFFF)));
    MMIOAddress += (PciAddress.AddressValue & 0x0FFFFFFF);
    LibAmdMemRead (AccessWidth, MMIOAddress, Value, StdHeader);
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Write PCI config space
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] PciAddress    Pci address
 * @param[in] Value         Pointer to data
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdPciWrite (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
  IN       VOID *Value,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32 LegacyPciAccess;
  UINT32 MMIOSize;
  UINT64 RMWrite;
  UINT64 RMWritePrevious;
  UINT64 MMIOAddress;

  ASSERT (StdHeader != NULL);
  ASSERT (PciAddress.AddressValue != ILLEGAL_SBDFO);
  if (!GetPciMmioAddress (&MMIOAddress, &MMIOSize, StdHeader)) {
    // We need to convert our "portable" PCI address into a "real" PCI access
    LegacyPciAccess = ((1 << 31) + (PciAddress.Address.Register & 0xFC) + (PciAddress.Address.Function << 8) + (PciAddress.Address.Device << 11) + (PciAddress.Address.Bus << 16) + ((PciAddress.Address.Register & 0xF00) << (24 - 8)));
    if (PciAddress.Address.Register <= 0xFF) {
      LibAmdIoWrite (AccessWidth32, IOCF8, &LegacyPciAccess, StdHeader);
      LibAmdIoWrite (AccessWidth, IOCFC + (UINT16) (PciAddress.Address.Register & 0x3), Value, StdHeader);
    } else {
      LibAmdMsrRead  (NB_CFG, &RMWritePrevious, StdHeader);
      RMWrite = RMWritePrevious | 0x0000400000000000ull;
      LibAmdMsrWrite (NB_CFG, &RMWrite, StdHeader);
      LibAmdIoWrite (AccessWidth32, IOCF8, &LegacyPciAccess, StdHeader);
      LibAmdIoWrite (AccessWidth, IOCFC + (UINT16) (PciAddress.Address.Register & 0x3), Value, StdHeader);
      LibAmdMsrWrite (NB_CFG, &RMWritePrevious, StdHeader);
    }
  } else {
    // Setup the MMIO address
    ASSERT ((MMIOAddress + MMIOSize) > (MMIOAddress + (PciAddress.AddressValue & 0x0FFFFFFF)));
    MMIOAddress += (PciAddress.AddressValue & 0x0FFFFFFF);
    LibAmdMemWrite (AccessWidth, MMIOAddress, Value, StdHeader);
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * PCI read modify write
 *
 *
 * @param[in] AccessWidth   Access width
 * @param[in] PciAddress    Pci address
 * @param[in] Data          OR Data
 * @param[in] DataMask      Mask to be used before data write back to register.
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdPciRMW (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32  TempData = 0;
  UINT32  TempMask = 0;
  UINT32  Value;
  LibAmdGetDataFromPtr (AccessWidth, Data,  DataMask, &TempData, &TempMask);
  LibAmdPciRead (AccessWidth, PciAddress, &Value, StdHeader);
  Value = (Value & (~TempMask)) | TempData;
  LibAmdPciWrite (AccessWidth, PciAddress, &Value, StdHeader);
}

/*---------------------------------------------------------------------------------------*/
/**
 * Poll PCI config space register
 *
 *  Poll register until (RegisterValue & DataMask) ==  Data
 *
 * @param[in] AccessWidth   Access width
 * @param[in] PciAddress    Pci address
 * @param[in] Data          Data to compare
 * @param[in] DataMask      AND mask
 * @param[in] Delay         Poll for time in 100ns (not supported)
 * @param[in] StdHeader     Standard configuration header
 *
 */
VOID
LibAmdPciPoll (
  IN       ACCESS_WIDTH AccessWidth,
  IN       PCI_ADDR PciAddress,
  IN       VOID *Data,
  IN       VOID *DataMask,
  IN       UINT64 Delay,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32  TempData = 0;
  UINT32  TempMask = 0;
  UINT32  Value;
  LibAmdGetDataFromPtr (AccessWidth, Data,  DataMask, &TempData, &TempMask);
  do {
    LibAmdPciRead (AccessWidth, PciAddress, &Value, StdHeader);
  } while (TempData != (Value & TempMask));
}

/*---------------------------------------------------------------------------------------*/
/**
 * Get MMIO base address for PCI accesses
 *
 * @param[out] MmioAddress   PCI MMIO base address
 * @param[out] MmioSize      Size of region in bytes
 * @param[in]  StdHeader     Standard configuration header
 *
 * @retval    TRUE          MmioAddress/MmioSize are valid
 */
BOOLEAN
STATIC
GetPciMmioAddress (
     OUT   UINT64            *MmioAddress,
     OUT   UINT32            *MmioSize,
  IN       AMD_CONFIG_PARAMS *StdHeader
  )
{
  BOOLEAN MmioIsEnabled;
  UINT32  EncodedSize;
  UINT64  MsrReg;

  ASSERT (StdHeader != NULL);

  MmioIsEnabled = FALSE;
  LibAmdMsrRead (MSR_MMIO_Cfg_Base, &MsrReg, StdHeader);
  if ((MsrReg & BIT0) != 0) {
    *MmioAddress = MsrReg & 0xFFFFFFFFFFF00000ull;
    EncodedSize = (UINT32) ((MsrReg & 0x3C) >> 2);
    *MmioSize = ((1 << EncodedSize) * 0x100000);
    MmioIsEnabled = TRUE;
  }
  return MmioIsEnabled;
}

/*---------------------------------------------------------------------------------------*/
/**
 * Read field of PCI config register.
 *
 *
 *
 * @param[in]   Address       Pci address  (register must be DWORD aligned)
 * @param[in]   Highbit       High bit position of the field in DWORD
 * @param[in]   Lowbit        Low bit position of the field in DWORD
 * @param[out]  Value         Pointer to data
 * @param[in]   StdHeader     Standard configuration header
 */
VOID
LibAmdPciReadBits (
  IN       PCI_ADDR Address,
  IN       UINT8 Highbit,
  IN       UINT8 Lowbit,
     OUT   UINT32 *Value,
  IN       AMD_CONFIG_PARAMS *StdHeader
  )
{
  ASSERT (Highbit < 32 && Lowbit < 32 && Highbit >= Lowbit && (Address.AddressValue & 3) == 0);

  LibAmdPciRead (AccessWidth32, Address, Value, StdHeader);
  *Value >>= Lowbit;  // Shift

  // A 1 << 32 == 1 << 0 due to x86 SHL instruction, so skip if that is the case

  if ((Highbit - Lowbit) != 31) {
    *Value &= (((UINT32) 1 << (Highbit - Lowbit + 1)) - 1);
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Write field of PCI config register.
 *
 *
 *
 * @param[in]   Address       Pci address  (register must be DWORD aligned)
 * @param[in]   Highbit       High bit position of the field in DWORD
 * @param[in]   Lowbit        Low bit position of the field in DWORD
 * @param[in]   Value         Pointer to data
 * @param[in]   StdHeader     Standard configuration header
 */
VOID
LibAmdPciWriteBits (
  IN       PCI_ADDR Address,
  IN       UINT8 Highbit,
  IN       UINT8 Lowbit,
  IN       UINT32 *Value,
  IN       AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32 Temp;
  UINT32 Mask;

  ASSERT (Highbit < 32 && Lowbit < 32 && Highbit >= Lowbit && (Address.AddressValue & 3) == 0);

  // A 1<<32 == 1<<0 due to x86 SHL instruction, so skip if that is the case

  if ((Highbit - Lowbit) != 31) {
    Mask = (((UINT32) 1 << (Highbit - Lowbit + 1)) - 1);
  } else {
    Mask = (UINT32) 0xFFFFFFFF;
  }

  LibAmdPciRead (AccessWidth32, Address, &Temp, StdHeader);
  Temp &= ~(Mask << Lowbit);
  Temp |= (*Value & Mask) << Lowbit;
  LibAmdPciWrite (AccessWidth32, Address, &Temp, StdHeader);
}

/*---------------------------------------------------------------------------------------*/
/**
 * Locate next capability pointer
 *
 *  Given a SBDFO this routine will find the next PCI capabilities list entry.
 *  if the end of the list is reached, or if a problem is detected, then ILLEGAL_SBDFO is
 *  returned.
 *  To start a new search from the head of the list, specify a SBDFO with an offset of zero.
 *
 * @param[in,out] Address       Pci address
 * @param[in]     StdHeader     Standard configuration header
 */

VOID
LibAmdPciFindNextCap (
  IN OUT   PCI_ADDR *Address,
  IN       AMD_CONFIG_PARAMS *StdHeader
  )
{
  PCI_ADDR Base;
  UINT32 Offset;
  UINT32 Temp;
  PCI_ADDR TempAddress;

  ASSERT (Address != NULL);
  ASSERT (*(UINT32 *) Address != ILLEGAL_SBDFO);

  Base.AddressValue = Address->AddressValue;
  Offset = Base.Address.Register;
  Base.Address.Register = 0;

  Address->AddressValue = (UINT32) ILLEGAL_SBDFO;

  // Verify that the SBDFO points to a valid PCI device SANITY CHECK
  LibAmdPciRead (AccessWidth32, Base, &Temp, StdHeader);
  if (Temp == 0xFFFFFFFF) {
    ASSERT (FALSE);
    return; // There is no device at this address
  }

  // Verify that the device supports a capability list
  TempAddress.AddressValue = Base.AddressValue + 0x04;
  LibAmdPciReadBits (TempAddress, 20, 20, &Temp, StdHeader);
  if (Temp == 0) {
    return; // This PCI device does not support capability lists
  }

  if (Offset != 0) {
    // If we are continuing on an existing list
    TempAddress.AddressValue = Base.AddressValue + Offset;
    LibAmdPciReadBits (TempAddress, 15, 8, &Temp, StdHeader);
  } else {
    // We are starting on a new list
    TempAddress.AddressValue = Base.AddressValue + 0x34;
    LibAmdPciReadBits (TempAddress, 7, 0, &Temp, StdHeader);
  }

  if (Temp == 0) {
    return; // We have reached the end of the capabilities list
  }

  // Error detection and recovery- The statement below protects against
  //   PCI devices with broken PCI capabilities lists.  Detect a pointer
  //   that is not uint32 aligned, points into the first 64 reserved DWORDs
  //   or points back to itself.
  if (((Temp & 3) != 0) || (Temp == Offset) || (Temp < 0x40)) {
    ASSERT (FALSE);
    return;
  }

  Address->AddressValue = Base.AddressValue + Temp;
  return;
}

/*---------------------------------------------------------------------------------------*/
/**
 * Set memory with value
 *
 *
 * @param[in,out] Destination   Pointer to memory range
 * @param[in]     Value         Value to set memory with
 * @param[in]     FillLength    Size of the memory range
 * @param[in]     StdHeader     Standard configuration header (Optional)
 */
VOID
LibAmdMemFill (
  IN       VOID *Destination,
  IN       UINT8 Value,
  IN       UINTN FillLength,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT8 *Dest;
  ASSERT (StdHeader != NULL);
  Dest = Destination;
  while ((FillLength--) != 0) {
    *Dest++ = Value;
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Copy memory
 *
 *
 * @param[in,out] Destination   Pointer to destination buffer
 * @param[in]     Source        Pointer to source buffer
 * @param[in]     CopyLength    buffer length
 * @param[in]     StdHeader     Standard configuration header (Optional)
 */
VOID
LibAmdMemCopy (
  IN       VOID *Destination,
  IN       VOID *Source,
  IN       UINTN CopyLength,
  IN OUT   AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT8 *Dest;
  UINT8 *SourcePtr;
  ASSERT (StdHeader != NULL);
  Dest = Destination;
  SourcePtr = Source;
  while ((CopyLength--) != 0) {
    *Dest++ = *SourcePtr++;
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Verify checksum of binary image (B1/B2/B3)
 *
 *
 * @param[in]   ImagePtr      Pointer to image  start
 * @retval      TRUE          Checksum valid
 * @retval      FALSE         Checksum invalid
 */
BOOLEAN
LibAmdVerifyImageChecksum (
  IN       VOID *ImagePtr
  )
{
  // Assume ImagePtr points to the binary start ($AMD)
  // Checksum is on an even boundary in AMD_IMAGE_HEADER

  UINT16 Sum;
  UINT32 i;

  Sum = 0;

  i = ((AMD_IMAGE_HEADER*) ImagePtr)->ImageSize;

  while (i > 1) {
    Sum = Sum + *((UINT16 *)ImagePtr);
    ImagePtr = (VOID *) ((UINT8 *)ImagePtr + 2);
    i = i - 2;
  }
  if (i > 0) {
    Sum = Sum + *((UINT8 *) ImagePtr);
  }

  return (Sum == 0)?TRUE:FALSE;
}

/*---------------------------------------------------------------------------------------*/
/**
 * Locate AMD binary image that contain specific module
 *
 *
 * @param[in]   StartAddress    Pointer to start range
 * @param[in]   EndAddress      Pointer to end range
 * @param[in]   Alignment       Image address alignment
 * @param[in]   ModuleSignature Module signature.
 * @retval     NULL  if image not found
 * @retval     pointer to image header
 */
VOID *
LibAmdLocateImage (
  IN       VOID *StartAddress,
  IN       VOID *EndAddress,
  IN       UINT32 Alignment,
  IN       CHAR8 ModuleSignature[8]
  )

{
  UINT8 *CurrentPtr;
  AMD_MODULE_HEADER *ModuleHeaderPtr;
  UINT64 *SearchStr;
  UINT64 *InputStr;

  CurrentPtr = StartAddress;
  InputStr = (UINT64 *)ModuleSignature;

  // Search from start to end incrementing by alignment
  while ((CurrentPtr >= (UINT8 *) StartAddress) && (CurrentPtr < (UINT8 *) EndAddress)) {
    // First find a binary image
    if (*((UINT32 *) CurrentPtr) == IMAGE_SIGNATURE) {
      if (LibAmdVerifyImageChecksum (CurrentPtr)) {
        // If we have a valid image, search module linked list for a match
        ModuleHeaderPtr = (AMD_MODULE_HEADER*) ((UINT8 *)CurrentPtr + ((AMD_IMAGE_HEADER *) CurrentPtr)->ModuleInfoOffset);
        while (ModuleHeaderPtr != NULL) {
          SearchStr = (UINT64 *)&ModuleHeaderPtr->ModuleIdentifier;
          if (*InputStr == *SearchStr) {
            return  CurrentPtr;
          }
          ModuleHeaderPtr = (AMD_MODULE_HEADER *)ModuleHeaderPtr->NextBlock;
        }
      }
    }
    CurrentPtr += Alignment;
  }
  return NULL;
}

/*---------------------------------------------------------------------------------------*/
/**
 * Returns the package type mask for the processor
 *
 *
 * @param[in]     StdHeader     Standard configuration header (Optional)
 */

//  Returns the package type mask for the processor
UINT32
LibAmdGetPackageType (
  IN       AMD_CONFIG_PARAMS *StdHeader
  )
{
  UINT32      ProcessorPackageType;
  CPUID_DATA  CpuId;

  LibAmdCpuidRead (0x80000001, &CpuId, StdHeader);
  ProcessorPackageType = (UINT32) (CpuId.EBX_Reg >> 28) & 0xF; // bit 31:28
  return (UINT32) (1 << ProcessorPackageType);
}

/*---------------------------------------------------------------------------------------*/
/**
 * Returns the package type mask for the processor
 *
 *
 * @param[in]     AccessWidth     Access width
 * @param[in]     Data            data
 * @param[in]     DataMask        data
 * @param[out]    TemData         typecast data
 * @param[out]    TempDataMask    typecast data
 */


VOID
STATIC
LibAmdGetDataFromPtr (
  IN       ACCESS_WIDTH AccessWidth,
  IN       VOID         *Data,
  IN       VOID         *DataMask,
     OUT   UINT32       *TemData,
     OUT   UINT32       *TempDataMask
  )
{
  switch (AccessWidth) {
    case AccessWidth8:
    case AccessS3SaveWidth8:
      *TemData = (UINT32)*(UINT8 *) Data;
      *TempDataMask = (UINT32)*(UINT8 *) DataMask;
      break;
    case AccessWidth16:
    case AccessS3SaveWidth16:
      *TemData = (UINT32)*(UINT16 *) Data;
      *TempDataMask = (UINT32)*(UINT16 *) DataMask;
      break;
    case AccessWidth32:
    case AccessS3SaveWidth32:
      *TemData = *(UINT32 *) Data;
      *TempDataMask = *(UINT32 *) DataMask;
      break;
    default:
      IDS_ERROR_TRAP;
  }
}

/*---------------------------------------------------------------------------------------*/
/**
 * Returns the package type mask for the processor
 *
 *
 * @param[in]     AccessWidth     Access width
 * @retval        Width in number of bytes
 */


UINT8
LibAmdAccessWidth (
  IN       ACCESS_WIDTH AccessWidth
  )
{
  UINT8 Width;

  switch (AccessWidth) {
    case AccessWidth8:
    case AccessS3SaveWidth8:
      Width = 1;
      break;
    case AccessWidth16:
    case AccessS3SaveWidth16:
      Width = 2;
      break;
    case AccessWidth32:
    case AccessS3SaveWidth32:
      Width = 4;
      break;
    case AccessWidth64:
    case AccessS3SaveWidth64:
      Width = 8;
      break;
    default:
      Width = 0;
      IDS_ERROR_TRAP;
  }
  return Width;
}

VOID
CpuidRead (
  IN        UINT32      CpuidFcnAddress,
  OUT       CPUID_DATA  *Value
  )
{
  __cpuid ((int *)Value, CpuidFcnAddress);
}

UINT8
ReadNumberOfCpuCores(
  VOID
  )
{
  CPUID_DATA  Value;
  CpuidRead (0x80000008, &Value);
  return   Value.ECX_Reg & 0xff;
}
